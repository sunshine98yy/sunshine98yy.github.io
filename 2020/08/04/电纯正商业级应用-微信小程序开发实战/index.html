<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">纯正商业级应用-微信小程序开发实战（更新中） | 风中的鱼</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "ひみつきちYUYU";
  mashiro_option.author_name = "YUYU";
  mashiro_option.site_url = "www.yulinblog.com";
  mashiro_option.v_appId = "4NBvruApUCpLtmlsyQLevDfx-gzGzoHsz";
  mashiro_option.v_appKey = "eTSHbT3jvLQPcVYMC7QFXQFd";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/5.jpg,https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/3.jpg,https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/4.jpg,https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/6.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop ">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="www.yulinblog.com">
          <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>在海边捡贝壳的孩子</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://github.com/sunshine98yy" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/social/github1.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="mailto:sunshine98yy@163.com" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/whchat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">ひみつきち</span>
            <span class="shironeko">YUYU</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fas fa-home" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/笔记/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          笔记
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/项目/">
                          <i class="fa fa-git" aria-hidden="true"></i>
                          项目
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-share" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/光影艺术/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          摄影
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/tags/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-tag" aria-hidden="true"></i>
                    标签
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/categories/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-bookmark" aria-hidden="true"></i>
                    分类
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    赞赏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200805.jpg);" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200805.jpg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      纯正商业级应用-微信小程序开发实战（更新中）</h1>
      <p class="entry-census">
        <span>
          <a href="www.yulinblog.com">
            <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="www.yulinblog.com">YUYU</a>
        </span>
        <span class="bull">
        ·</span>
        2020-8-4<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <p>实战项目笔记根据imooc七月的《纯正商业级应用-微信小程序开发实战》记录。</p>
<p>开发项目前提，有设计图，数据，需求。课程提供相应设计图原稿（PSD），在线API提供数据，线上案例参考。</p>
<p>学习小程序开发，建议多阅读参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">小程序开发者文档</a></p>
<h2 id="小程序杂记"><a href="#小程序杂记" class="headerlink" title="小程序杂记"></a>小程序杂记</h2><p>入手小程序前，务必理解回调函数。</p>
<h4 id="回调函数的理解"><a href="#回调函数的理解" class="headerlink" title="回调函数的理解"></a>回调函数的理解</h4><p><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="noopener">回调函数是什么</a></p>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
<p><a href="https://blog.csdn.net/samt007/article/details/54647361" target="_blank" rel="noopener">关于js的callback回调函数以及嵌套回调函数的执行过程理解</a></p>
<p><a href="https://blog.csdn.net/UnderIcon/article/details/81188923?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">JS中回调函数(callback)理解</a></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><a href="https://zhuanlan.zhihu.com/p/62482741" target="_blank" rel="noopener">JS中的箭头函数与this</a></p>
<h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p><a href="https://segmentfault.com/a/1190000016537685" target="_blank" rel="noopener">微信小程序踩坑系列——从wx.request谈谈异步处理</a></p>
<h4 id="微信小程序组件开发规范"><a href="#微信小程序组件开发规范" class="headerlink" title="微信小程序组件开发规范"></a>微信小程序组件开发规范</h4><p><a href="https://segmentfault.com/a/1190000015203935" target="_blank" rel="noopener">微信小程序组件开发规范</a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="申请appkey"><a href="#申请appkey" class="headerlink" title="申请appkey"></a>申请appkey</h3><p>提供了在线的API，开发者需要申请开发者key(appkey)，访问www.7yue.pro提供直接用，前提购买该课程</p>
<p>可以自己在github上搜，提供一下appkey</p>
<blockquote>
<p>纯正商业级应用-微信小程序开发实战 appkey</p>
</blockquote>
<ul>
<li>RdshydjBvcYZhMZC</li>
<li>GgRhTjUNUYn1fHke</li>
</ul>
<h3 id="注册微信小程序"><a href="#注册微信小程序" class="headerlink" title="注册微信小程序"></a>注册微信小程序</h3><p>1.进入微信公众平台官网，新用户需注册，点击立即注册</p>
<p><a href="http://mp.weixin.qq.com" target="_blank" rel="noopener">http://mp.weixin.qq.com</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_001.jpg" style="zoom:67%;"></p>
<p>2.注册微信小程序账号（个人、企业）</p>
<p>微信对个人小程序较保守，做产品上线时，分析自己需要取得哪些资质</p>
<p>微信公众号：小程序（小程序、小游戏）、服务号、订阅号、企业微信</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_002.jpg" style="zoom: 33%;"></p>
<p>注册完成后，在邮箱点击确认注册信息</p>
<p>3.下载微信开发者工具</p>
<p>在小程序首页中，选择【文档】—【开发】—【工具】—【下载】</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_008.jpg" style="zoom: 33%;"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_007.jpg" style="zoom:33%;"></p>
<p>下载软件后，按照安装向导进行安装（自定义安装路径）</p>
<p>4.获取appid</p>
<p>使用appid可以调用开放API，无ID无法调用开放API,建议填上</p>
<p>进入小程序后台管理界面，【开发】—【开发设置】—【开发者ID】查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_013.jpg" style="zoom:33%;"></p>
<h3 id="熟悉开发工具"><a href="#熟悉开发工具" class="headerlink" title="熟悉开发工具"></a>熟悉开发工具</h3><p>首次登陆微信开发者工具，需要扫码登陆</p>
<h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><p>填写项目名和AppID，选择项目目录</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_009.jpg" style="zoom: 50%;"></p>
<p>进入工作界面，开发工具为我们初始化了部分文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_014.jpg" style="zoom: 50%;"></p>
<p>机型适配观察上特别注意下iPhone X机型</p>
<h4 id="开发工具快捷键"><a href="#开发工具快捷键" class="headerlink" title="开发工具快捷键"></a>开发工具快捷键</h4><p>按F1快速查看快捷键，按需查询</p>
<p>常用快捷键</p>
<ul>
<li>快速打开文件 ctrl+p</li>
<li>搜索近期打开的文件 ctrl+e</li>
<li>格式化代码 ctrl+shift+F</li>
</ul>
<h4 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h4><p>外观设置或快捷键设置：勾选【设置】按钮选择</p>
<h3 id="小程序基础知识"><a href="#小程序基础知识" class="headerlink" title="小程序基础知识"></a>小程序基础知识</h3><h4 id="小程序文件类型"><a href="#小程序文件类型" class="headerlink" title="小程序文件类型"></a>小程序文件类型</h4><p>小程序有四种文件类型（wxss、wxml、js、json），和传统的css、html相比只是扩展名不同，其他大体无区别</p>
<p>上手小程序需要有js/css/javascript基础</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_015.jpg" style="zoom: 40%;"></p>
<p>json文件无注释，只用双引号</p>
<h4 id="小程序的组织结构"><a href="#小程序的组织结构" class="headerlink" title="小程序的组织结构"></a>小程序的组织结构</h4><h5 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h5><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatgit0612_018.jpg" style="zoom: 50%;"></p>
<p>每个小程序有三个全局文件，全局配置文件（app.json）、全局样式文件（app.wxss）和全局业务文件（app.js）,名字默认无法更改。</p>
<p>小程序由多个页面（page）组成，一个page页面一般由四种文件类型构成。</p>
<h5 id="进阶结构（组件式编程思想）"><a href="#进阶结构（组件式编程思想）" class="headerlink" title="进阶结构（组件式编程思想）"></a>进阶结构（组件式编程思想）</h5><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatgit0612_019.jpg" style="zoom:60%;"></p>
<p>一个页面由更多的组件构成，每个组件包含四种基本类型</p>
<p>如旧岛项目的目录</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0612_020.jpg" style="zoom: 50%;"></p>
<h4 id="新建第一个小程序页面"><a href="#新建第一个小程序页面" class="headerlink" title="新建第一个小程序页面"></a>新建第一个小程序页面</h4><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/" target="_blank" rel="noopener">小程序框架</a></p>
<p>新建空白项目，项目下<strong>新建app.js，app.json</strong>。新建pages文件夹，文件夹下新建classic文件夹，新建page，在page（目录下会自动生成四个文件classic新建前提需要补充前面两个新建文件的初始代码，否则无法创建）。</p>
<pre><code class="lang-js">#app.js
App(

)
</code></pre>
<pre><code class="lang-json">#app.json
{

}
</code></pre>
<p>新建page（classic）后，app.json内容自动生成如下,我们称为<strong>路径注册</strong>：</p>
<p>小程序中每新建一个页面，都必须在App.json中注册，否则小程序找不到page页面</p>
<pre><code class="lang-json">{
  &quot;pages&quot;: [
    &quot;pages/classic&quot;
  ]
}
</code></pre>
<p>要删除这四个文件方法：</p>
<p>在文件所在文件夹中删除</p>
<p>参考小程序开发文档</p>
<h5 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h5><p>用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 <code>.json</code>, <code>.js</code>, <code>.wxml</code>, <code>.wxss</code> 四个文件进行处理。</p>
<p><strong>数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。</strong></p>
<pre><code class="lang-json">#app.json
{
  &quot;pages&quot;: [
    &quot;pages/classic/classic&quot;
  ]
}
</code></pre>
<h5 id="window"><a href="#window" class="headerlink" title="window"></a>window</h5><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<pre><code class="lang-json">&quot;window&quot;: {
    &quot;navigationBarBackgroundColor&quot;: &quot;#FFFF00&quot;, //导航栏背景颜色
    &quot;navigationBarTitleText&quot;:&quot;微信接口功能演示&quot;,  //导航栏标题文字内容
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;,  //导航栏标题颜色，仅支持 black / white
    &quot;navigationStyle&quot;:&quot;default&quot; //导航栏样式，仅支持以下值：default 默认样式，custom 自定义导航栏
  }
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0613_001.jpg" style="zoom: 15%;"></p>
<p><code>backgroundColor</code>窗口的背景色:开发界面中不会显示background区域，开启下拉刷新，可实现。在真机上上拉或下拉可显示</p>
<p>通常情况下，background的颜色和page保持一致，默认白色。</p>
<pre><code class="lang-json">#app.json
{
  &quot;pages&quot;: [
    &quot;pages/classic/classic&quot;
  ],
  &quot;window&quot;: {
    &quot;navigationBarBackgroundColor&quot;: &quot;#FFFF00&quot;,
    &quot;navigationBarTitleText&quot;:&quot;鱼鱼的世界&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;,
    &quot;navigationStyle&quot;:&quot;default&quot;,
    &quot;backgroundColor&quot;:&quot;#D80000&quot;,
    &quot;enablePullDownRefresh&quot;:true //是否开启全局的下拉刷新。
  }
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0613_002.jpg" style="zoom:33%;"></p>
<h4 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h4><p>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合<a href="https://developers.weixin.qq.com/miniprogram/dev/component/index.html" target="_blank" rel="noopener">基础组件</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html" target="_blank" rel="noopener">事件系统</a>，可以构建出页面的结构</p>
<p><strong>wxml是一个或多个组件的集合</strong></p>
<p>小程序中的组件和html的标签类似，不同的组件支持不同的属性。</p>
<p>有些组件成对出现，也有不用成对出现。</p>
<ul>
<li>内置组件，微信提供，可直接用</li>
<li>自定义组件</li>
</ul>
<h4 id="flex布局（重要）"><a href="#flex布局（重要）" class="headerlink" title="*flex布局（重要）"></a>*flex布局（重要）</h4><p>布局 代码控制元素排布</p>
<p>需要布局的技巧和嵌套的思维</p>
<h5 id="block、inline和inline-block"><a href="#block、inline和inline-block" class="headerlink" title="block、inline和inline-block"></a>block、inline和inline-block</h5><p>块级元素独占一行，默认情况下，<strong>是否是块级元素通过display设置</strong>，默认是block</p>
<p>块状元素转为行内元素：<code>display:inline</code></p>
<p>行内元素默认不设置高宽，要实现行内元素有高宽属性，设置<code>display:inline-block;</code>(并列显示在一行)</p>
<pre><code class="lang-css">#wxss
.chunk{
  display: inline-block;
  width: 100px;
  height: 200px;
}
.color1{
  background-color: brown;
}
.color2{
  background-color: aqua;
}
.color3{
  background-color: blue;
}
</code></pre>
<pre><code class="lang-html">#wxml
&lt;view class=&quot;chunk color1&quot;/&gt;
&lt;view class=&quot;chunk color2&quot;/&gt;
&lt;view class=&quot;chunk color3&quot;/&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0613_005.jpg" style="zoom: 50%;"></p>
<h5 id="flex容器"><a href="#flex容器" class="headerlink" title="flex容器"></a>flex容器</h5><p>容器将消除容器内item的块状特性，块状元素放置于弹性盒子中，块状元素的特性会消除。flex是 flexible box(弹性盒子、弹性布局)的缩写</p>
<p>两个基本概念 flex container和flex item ，弹性布局需要container和item</p>
<pre><code class="lang-css">#wxss
.chunk{
  width: 100px;
  height: 200px;
}
.container{
  display: flex;
}
.color1{
  background-color: brown;
}
.color2{
  background-color: aqua;
}
.color3{
  background-color: blue;
}

#wxml，为3个小色块增加一个容器
&lt;view class = &quot;container&quot;&gt;
&lt;view class=&quot;chunk color1&quot;/&gt;
&lt;view class=&quot;chunk color2&quot;/&gt;
&lt;view class=&quot;chunk color3&quot;/&gt;
&lt;/view&gt;
</code></pre>
<h5 id="flex-direction属性解析"><a href="#flex-direction属性解析" class="headerlink" title="flex-direction属性解析"></a>flex-direction属性解析</h5><p><strong>设置容器下子项item的排布方向</strong></p>
<pre><code class="lang-css">.container{
  display: flex;
  flex-direction: column; //纵向排列
  flex-direction: row;//水平排列（默认是水平排列）
  flex-direction: row-reverse;//reverse倒序排布(靠右开始，有偏移现象)
  flex-direction: column-reverse;
}
</code></pre>
<p>view组件高度自适应，宽度默认100%</p>
<p>使用<strong>reverse</strong> ，元素的内容和位置都会倒序</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0613_008.jpg" style="zoom:33%;"></p>
<p>container容器内元素高度自适应。对于上面的view组件来说，不指定高度的话通常自适应填满高度。指定容器后出现偏移效果。</p>
<h5 id="justify-content属性解析"><a href="#justify-content属性解析" class="headerlink" title="justify-content属性解析"></a>justify-content属性解析</h5><p>控制子元素的对齐方向：</p>
<pre><code class="lang-css">justify-content:flex-end（下右）

justify-content:flex-start（上左）

justify-content:center（居中）
</code></pre>
<pre><code class="lang-css">justify-content:space-between //水平（垂直）方向平均分布

justify-content:space-around //实现等距分布（每个item之间的距离均相等）
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0613_009.jpg" style="zoom:50%;"></td>
<td><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chatchat0613_010.jpg" style="zoom:50%;"></td>
</tr>
</tbody>
</table>
</div>
<h5 id="主轴与交叉轴"><a href="#主轴与交叉轴" class="headerlink" title="主轴与交叉轴"></a>主轴与交叉轴</h5><p>主轴和交叉轴的方向取决于flex-direction</p>
<p><strong>justify-content指的是主轴上的排布和对齐方式，align-items指的是交叉轴上的排布和对齐方式</strong></p>
<pre><code class="lang-css">.container{
  display: flex;
  flex-direction: column; //此时垂直方向是主轴
  height: 400px;
  background: #999999;
  justify-content: start;
  align-items: center;
}
</code></pre>
<p>当flex-direction: column-reverse;或flex-direction: column-reverse;时，主轴水平垂直方向不变，变得是轴朝向（左-右，上-下）</p>
<h5 id="baseline与stretch属性"><a href="#baseline与stretch属性" class="headerlink" title="baseline与stretch属性"></a>baseline与stretch属性</h5><p>align-items: baseline; 并不是让子元素对齐，而是让元素内的文字对齐，以第一个元素的文字作为基线对齐</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/07291.jpg" style="zoom:33%;"></p>
<p>align-items:stretch:不让子 元素随其内容自适用（没有定义height的情况）</p>
<h5 id="flex-wrap与消除间距"><a href="#flex-wrap与消除间距" class="headerlink" title="flex-wrap与消除间距"></a>flex-wrap与消除间距</h5><p>一行中总元素的宽度大于行宽度，会默认让元素平均分配一行的宽度，不会出现换行</p>
<pre><code class="lang-css">flex-wrap: wrap; //元素换行
flex-wrap: nowrap; //默认，元素不换行
</code></pre>
<p>消除换行后的间距:间距是flex的默认特性，可以设置总高度消除换行的效果。</p>
<h4 id="小程序组件"><a href="#小程序组件" class="headerlink" title="小程序组件"></a>小程序组件</h4><h5 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h5><p>以项目中心形点赞按钮为例：</p>
<p>自定义组件，实现js，css，wxml的复用</p>
<p>新建存放所有组键的目录components，新建心形组件目录,如like，新建component，组件名为index。<strong>index只是组件的文件名，并不是组件的名字。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/072903.jpg" style="zoom: 50%;"></p>
<p>组件新建完成后不会有任何效果</p>
<h5 id="组件生效"><a href="#组件生效" class="headerlink" title="组件生效"></a>组件生效</h5><p><strong>要使组件生效：需在页面配置文件中引用组件，并在页面wmxl使用它才会生效</strong></p>
<p>like不是组件名，只是组件的目录。为了规范组件名，使用like-cmp(根据实际规范调整)</p>
<pre><code class="lang-json">配置文件中引入组件
#classic.json
{
  &quot;usingComponents&quot;: {
    &quot;like-cmp&quot;:&quot;/components/like/index&quot; //键名：键值
  }
}
页面中使用引入的组件
#classic.wxml
&lt;like-cmp/&gt;（自定义组件）
</code></pre>
<p>绝对路径：/components/like/index</p>
<p>相对路径：../../components/like/index</p>
<p>/表示根目录，../表示返回上一级目录。在同级别目录下才能访问</p>
<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h3 id="LIKE组件实现"><a href="#LIKE组件实现" class="headerlink" title="LIKE组件实现"></a>LIKE组件实现</h3><p>功能：点击心形图片，显示点赞数加1，并且图片有切换效果。</p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><h5 id="图片的存放"><a href="#图片的存放" class="headerlink" title="图片的存放"></a>图片的存放</h5><p>存放组件用图片的方式：</p>
<ol>
<li>在对应的组件目录下面新建images图片</li>
<li>component文件夹下新建images,统一存放</li>
</ol>
<p>根目录下的images存放和页面page相关的图片</p>
<p>​    此处选择把images文件夹放在like组件目录下</p>
<p>引用图片</p>
<pre><code class="lang-html">#index.wxml
&lt;image src=&quot;images/like.png&quot;&gt;&lt;/image&gt;
</code></pre>
<p>问题：图片显示尺寸过大</p>
<p>在小程序中使用image标签引入图片时必须用image标签设置高和宽，否则是默认尺寸。</p>
<p>设置图片的原始尺寸</p>
<pre><code class="lang-css">#index.wxss
.container{
    height:32px;
    width:28px;
}
</code></pre>
<pre><code class="lang-html">#index.wxml
&lt;image class=&quot;container&quot; src=&quot;images/like.png&quot;&gt;&lt;/image&gt;
</code></pre>
<p>问题：按照原始尺寸设计图片效果还是过大</p>
<h5 id="尺寸的单位"><a href="#尺寸的单位" class="headerlink" title="尺寸的单位"></a>尺寸的单位</h5><p>px是固定尺寸单位，px 和小程序系统中看到的图片大小比例是1：2，用的话除以2（iPhone6的标准），</p>
<p><strong>rpx</strong>可以屏幕自适应，px 和小程序系统中看到的图片大小比例是 1：1</p>
<p>根据不同的情况做不同的选择。如字体的大小推荐px,不随机型变化而变化。绝大多数情况可以使用rpx。</p>
<p>2倍换算的前提：以iphone6尺寸为前提（宽750，高1334像素）</p>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><h5 id="样式设计"><a href="#样式设计" class="headerlink" title="样式设计"></a>样式设计</h5><p>考虑数字和图标的布局问题</p>
<pre><code class="lang-css">#index.wxml
&lt;view class = &quot;container&quot;&gt;//放入容器
    &lt;image src=&quot;images/like.png&quot;/&gt;
    &lt;text&gt;9&lt;/text&gt;//真实数字取值从服务器中得到
&lt;/view&gt;

#index.wxss
.container{
  display: flex; //应用flex布局的第一步
  flex-direction: row;
  padding: 10rpx; //9不会被遮挡
  width: 80rpx;//限定宽度，无法自适应
}

//样式选择器写法，子元素少的情况使用
.container image{//image是子元素，此写法避免了给每个元素定义一个新的样式名称
  width: 32rpx;
  height: 28rpx;
}

.container text{
  position: relative;//数字进行偏移
  bottom: 10rpx;//上偏移
  left:6 rpx;//右偏移
  font-size: 24rpx;
  color: #bbbbbb;
  line-height:24rpx ; //文字上下本身有空白间距，消除字体自带上下空白间距
}
</code></pre>
<p>现在的效果组件占满了一行。<strong>容器设置了flex,并不会改变自身的块状属性，改变了子元素的块状属性。</strong></p>
<pre><code class="lang-css">#index.wxss
.container{
  display: inline-flex; //宽度自适应
  flex-direction: row;
  padding: 10rpx; //9不会被遮挡  
}
</code></pre>
<p>自适应缺陷：数字的位数跳动时，由于变化也会使页面产生跳动。根据实际情况确定</p>
<h5 id="组件样式继承"><a href="#组件样式继承" class="headerlink" title="组件样式继承"></a>组件样式继承</h5><p>全局样式（app.wxss）中设置的样式影响到组件的话，就说组件继承了全局样式。</p>
<pre><code class="lang-css">#app.wxss
page{
  font-family: cambria;
  font-size: 32rpx;
}
</code></pre>
<p>全局样式给了一种统一默认的样式，某个组件有自己样式可以覆盖</p>
<p><strong>问题：</strong>page设置样式为什么能影响组件？</p>
<p>虽然组件本身不是页面，但要使用组件时需要被引用到页面中</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/07294.jpg" style="zoom: 67%;"></p>
<p>组件能继承的样式只有两种：font,color</p>
<p>几乎所有的css样式可以被page页面继承</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><h5 id="组件状态切换和数字加减"><a href="#组件状态切换和数字加减" class="headerlink" title="组件状态切换和数字加减"></a>组件状态切换和数字加减</h5><p>监听到用户操作后触发业务逻辑,<strong>在js中写业务逻辑</strong></p>
<p><strong>监听用户的点击事件</strong>bind:tap=“onLike”</p>
<pre><code class="lang-css">#index.wxml
&lt;view bind:tap=&quot;onLike&quot; class = &quot;container&quot;&gt;
&lt;image src=&quot;images/like.png&quot;/&gt;
&lt;text&gt;9&lt;/text&gt;
&lt;/view&gt;

#index.js
 methods: {
    onLike:function(event){
      console.log(event);
    }
  }
</code></pre>
<p>index.js的默认代码结构</p>
<pre><code class="lang-js">Component({
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {

  }
})
</code></pre>
<p>catch:tap 和bind:tap  参考文档</p>
<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡</p>
<h3 id="组件数据、事件与属性"><a href="#组件数据、事件与属性" class="headerlink" title="组件数据、事件与属性"></a>组件数据、事件与属性</h3><h4 id="数据来源的三种途径"><a href="#数据来源的三种途径" class="headerlink" title="数据来源的三种途径"></a>数据来源的三种途径</h4><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chat0614_001.jpg" style="zoom: 50%;"></p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>数据从js传到wxml中，并由wxml来显示数据的模式叫做<strong>数据绑定</strong></p>
<p>数据从js传到wxml中，<strong>使用双括号进行引用</strong></p>
<pre><code class="lang-css">#index.wxml
&lt;view bind:tap=&quot;onLike&quot; class = &quot;container&quot;&gt;
&lt;image src=&quot;images/like.png&quot;/&gt;
&lt;text&gt;{{count}}&lt;/text&gt; //双花括号引用js中的数据
&lt;/view&gt;

#index.js
  /**
   * 组件的初始数据
   */
 data: {
    count:99
  }
</code></pre>
<h5 id="三元表达式与图片切换"><a href="#三元表达式与图片切换" class="headerlink" title="三元表达式与图片切换"></a>三元表达式与图片切换</h5><pre><code class="lang-css"> data: {
     like:true,
    count1:99,
    count2:999//true,显示99，false,显示999
  }

&lt;text&gt;{{like?count1:count2}}&lt;/text&gt; //使用三元表达式
</code></pre>
<pre><code class="lang-css">//三元表达式也可以用在属性中
&lt;image src=&quot;{{like?'images/like.png':'images/like@dis.png'}}&quot;/&gt;
可以用三元表达式实现点击后图片更换的效果
(在双引号中表示字符串时用单引号)
</code></pre>
<p><strong>写法可以优化，将路径定义成js变量</strong></p>
<pre><code class="lang-js">js
data: {
     like:true,
    count1:99,
    count2:999//true,显示99，false,显示999
    yesSrc:&#39;images/like.png&#39;
    nosrc:&#39;images/like@dis.png&#39;
  }
wxml  
&lt;image src=&quot;{{like?yesSrc:noSrc}}&quot;/&gt;
</code></pre>
<h5 id="组件的封装性和开放性"><a href="#组件的封装性和开放性" class="headerlink" title="组件的封装性和开放性"></a>组件的封装性和开放性</h5><pre><code class="lang-js">data: {
     like:true,
    count:99,  //从组件的外部可以访问开放的数据
    yesSrc:&#39;images/like.png&#39;
    nosrc:&#39;images/like@dis.png&#39; //内部数据不需开放
  }
</code></pre>
<p>开放的数据：可以从组件外部设置被开放出来的数据，如like,count,<strong>开放的数据也可以称为属性</strong></p>
<p><strong>properties下面定义的变量称为属性。属性是js对象</strong>,可以指定3个属性的特性，type必填，value和observer选填。value不填会自动选取默认值。</p>
<p>语法如下</p>
<pre><code class="lang-js">properties: {
    like:{
      type: Boolean,
      value: false,
      observer:function(){
      }
    },

    count:{
      type:Number,  
    }      
  },
  //count:Number(简写)  
data: {
    yesSrc:&#39;images/like.png&#39;
    nosrc:&#39;images/like@dis.png&#39; //内部数据不需开放
</code></pre>
<p>属性亦可以通过{{}}引用</p>
<h5 id="let-var与组件事件应用"><a href="#let-var与组件事件应用" class="headerlink" title="let,var与组件事件应用"></a><strong>let,var与组件事件应用</strong></h5><p><strong>ES6建议使用let定义变量</strong>。let声明变量的作用域局限在块级，var定义的变量作用域至少是一个函数之内，是全域。</p>
<h5 id="setData"><a href="#setData" class="headerlink" title="setData()"></a>setData()</h5><p>setData（）方法接收一个<strong>js对象</strong>，在对象中<strong>更新</strong>变量。</p>
<p>用于将数据从逻辑层发送到视图层 （异步），同时改变对应的 this.data 的值（同步）。对象以key:value形式表示，将this.data中key对应的值改变成value</p>
<p><strong>应用</strong>：通过鼠标点击切换like属性状态</p>
<p>在onlike函数中修改LIKE属性的取值</p>
<p>通过this关键字访问component下面的各种变量</p>
<pre><code class="lang-js"> methods: {
    onLike:function(event){
    let like = this.properties.like
    let count = this.properties.count

    count = like?count-1:count+1//like为真，点一次是假，-1
    //更新数值
    this.setData({
      count:count,
      like:!like
    })
    }
</code></pre>
<h3 id="访问API数据"><a href="#访问API数据" class="headerlink" title="访问API数据"></a>访问API数据</h3><p><strong>看待组件的两种观点</strong></p>
<p>组件实现代码的分离（对初学者来说更重要）</p>
<p>组件实现代码的复用</p>
<h4 id="访问和封装API"><a href="#访问和封装API" class="headerlink" title="访问和封装API"></a>访问和封装API</h4><h5 id="项目（Blink）-APl介绍和测试API"><a href="#项目（Blink）-APl介绍和测试API" class="headerlink" title="项目（Blink） APl介绍和测试API"></a>项目（Blink） APl介绍和测试API</h5><p>访问项目的API需要APPKEY，七月有风网站有开发文档，点击可查看API说明</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chat0614_002.jpg" style="zoom:50%;"></p>
<p><a href="http://bl.7yue.pro/v1/classic/latest?appkey=GgRhTjUNUYn1fHke" target="_blank" rel="noopener">http://bl.7yue.pro/v1/classic/latest?appkey=GgRhTjUNUYn1fHke</a></p>
<h5 id="小程序中访问API加载数据"><a href="#小程序中访问API加载数据" class="headerlink" title="小程序中访问API加载数据"></a>小程序中访问API加载数据</h5><p>加载时机：在classic页面初始化时向服务器发送请求获取数据</p>
<h6 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h6><p>微信提供生命周期函数监听页面的生命周期，描述了一个页面完整的生命历程。</p>
<p>在classic页面的classic.js中，小程序已经初始化了很多生命周期函数.</p>
<p>对于生命周期函数来说，原理和之前自己创建的监听点击事件类似，区别在于<strong>函数的触发由小程序内部的系统来调用</strong>，不用bind来监听。触发函数名由系统定义。</p>
<pre><code class="lang-js">// pages/classic/classic.js
Page({

  /** * 页面的初始数据*/
  data: {

  },

  /** * 生命周期函数--监听页面加载 */
  onLoad: function (options) {

  },

  /** * 生命周期函数--监听页面初次渲染完成 */
  onReady: function () {

  },

  /**  * 生命周期函数--监听页面显示 */
  onShow: function () {

  },

  /*** 生命周期函数--监听页面隐藏 */
  onHide: function () {

  },

  /*** 生命周期函数--监听页面卸载 */
  onUnload: function () {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {

  },

  /** * 页面上拉触底事件的处理函数 */
  onReachBottom: function () {

  },

  /*** 用户点击右上角分享 */
  onShareAppMessage: function () {

  }
})
</code></pre>
<p>onload是最先被触发，更快的从服务器获取数据</p>
<h6 id="发起-HTTPS-网络请求"><a href="#发起-HTTPS-网络请求" class="headerlink" title="发起 HTTPS 网络请求"></a>发起 HTTPS 网络请求</h6><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html" target="_blank" rel="noopener">wx.request(Object object)</a>函数，专门用于向服务器发起http请求,函数接收js对象，对象可以包含很多子参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">url</td>
<td style="text-align:left">string</td>
<td style="text-align:left"></td>
<td style="text-align:left">是</td>
<td style="text-align:left">开发者服务器接口地址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">data</td>
<td style="text-align:left">string/object/ArrayBuffer</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">请求的参数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">header</td>
<td style="text-align:left">Object</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">设置请求的 header，header 中不能设置 Referer。 <code>content-type</code> 默认为 <code>application/json</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">timeout</td>
<td style="text-align:left">number</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">超时时间，单位为毫秒</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.10.0</a></td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:left">string</td>
<td style="text-align:left">GET</td>
<td style="text-align:left">否</td>
<td style="text-align:left">HTTP 请求方法</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">dataType</td>
<td style="text-align:left">string</td>
<td style="text-align:left">json</td>
<td style="text-align:left">否</td>
<td style="text-align:left">返回的数据格式</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">responseType</td>
<td style="text-align:left">string</td>
<td style="text-align:left">text</td>
<td style="text-align:left">否</td>
<td style="text-align:left">响应的数据类型</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.7.0</a></td>
</tr>
<tr>
<td style="text-align:left">enableHttp2</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">开启 http2</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.10.4</a></td>
</tr>
<tr>
<td style="text-align:left">enableQuic</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">开启 quic</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.10.4</a></td>
</tr>
<tr>
<td style="text-align:left">enableCache</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">开启 cache</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.10.4</a></td>
</tr>
<tr>
<td style="text-align:left">success</td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>接口调用成功的回调函数</strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">fail</td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">接口调用失败的回调函数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">complete</td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">接口调用结束的回调函数（调用成功、失败都会执行）</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/073111.jpg" style="zoom:50%;"></p>
<p>不管服务器返回的http状态码的值是多少，都会执行success回调函数。只有如断网断电，走fail回调函数</p>
<pre><code class="lang-js">onLoad: function (options) {
    wx.request({
      url:&#39;http://bl.7yue.pro/v1/classic/latest&#39;,
      header:{
        appkey:&quot;GgRhTjUNUYn1fHke&quot;,
      }
    })
  },
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chat0614_004.jpg" style="zoom: 50%;"></p>
<p>出现不在合法域名列表的报错：设置—项目设置—不校验合法域名（只适用于开发阶段），最终上线发布还是需要后台账户添加访问的域名</p>
<p>出现401错误，点击调试器右上方方框按钮调试器弹出</p>
<p>以上是简单的访问示例，还需要<strong>对访问请求封装</strong>。避免到处写request。</p>
<h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><h5 id="同步、异步与回调函数"><a href="#同步、异步与回调函数" class="headerlink" title="*同步、异步与回调函数"></a>*同步、异步与回调函数</h5><p>目前服务器返回的数据显示在network调试窗口，<strong>如何在JS代码中获取服务器返回的数据</strong>？</p>
<p>wx.request是异步函数，let a =wx.request()不能使用。无法用a接收异步调用结果。</p>
<p>在小程序中，request只有异步没有同步（强制异步）。</p>
<p><strong>异步编程</strong>:性能好，维护代码成本高</p>
<p><strong>同步编程</strong>：等待某个调用结束后代码才会继续进行</p>
<p>那么如何接收异步函数的调用结果呢？回调函数</p>
<blockquote>
<p><strong>回调函数</strong>：在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。（一个函数被传入之后又被调用）如果没有名称(函数表达式)，就叫做匿名回调函数。</p>
</blockquote>
<p>//<strong>success是回调函数，在success函数中接收异步调用的结果。</strong></p>
<p>什么时候调用这个回调函数？</p>
<p><strong>服务器返回数据时，小程序触发success函数的执行，把服务器调用的结果当作参数(res)输出</strong></p>
<p>写法一：</p>
<pre><code class="lang-js"> onLoad: function (options) {
    wx.request({
      url: &#39;http://bl.7yue.pro/v1/classic/latest&#39;,
      header:{
        appkey:&quot;GgRhTjUNUYn1fHke&quot;,
      },
      success:function(res){
        console.log(res)
      }
    })
  },
</code></pre>
<p>输出的是一个json对象，我们主要关注的是data</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_chat0614_005.jpg" alt></p>
<p>当前回调函数的缺点：</p>
<p><strong>回调函数success外可以正确访问this,回调函数内无法正确访问this</strong></p>
<pre><code class="lang-js">  data: {
    test:1,
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log(this.data.test) //能够访问1
    wx.request({
      url:&#39;http://bl.7yue.pro/v1/classic/latest&#39;,
      header:{
        appkey:&quot;GgRhTjUNUYn1fHke&quot;,
      },
      success:function(res){
        console.log(this.data.test)//报错，无法正确访问1
      }
    })
  },
</code></pre>
<p>这是回调函数定义的最大缺陷。函数作用域发生了改变，this的指代不明确。</p>
<p><strong>解决方法</strong></p>
<p>​    先在回调函数的外面把this的指代保存</p>
<pre><code class="lang-js">onLoad: function (options) {
    console.log(this.data.test)
    let that = this.data.test
    wx.request({
      url:&#39;http://bl.7yue.pro/v1/classic/latest&#39;,
      header:{
        appkey:&quot;GgRhTjUNUYn1fHke&quot;,
      },
      success:function(res){
        console.log(that)  //1
      }
    })
  },
</code></pre>
<p>更好的方法:ES6中<strong>箭头函数</strong></p>
<p>箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code></p>
<pre><code class="lang-js">success:(res)=&gt;{ 
    console.log(this.data.test)//可以正确访问
}
</code></pre>
<p>Promise函数,要正确的使用</p>
<p>解决异步嵌套的问题（回调地狱）</p>
<h4 id="二次封装"><a href="#二次封装" class="headerlink" title="二次封装"></a>二次封装</h4><h5 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h5><p>对上述的wx.reques进行二次封装，封装原因：</p>
<p>​    处理返回的异常</p>
<p>​    不用每次使用都写链接</p>
<p>项目根目录下新建config.js文件</p>
<pre><code class="lang-js">#config.js
const config = {  //设置固定不变的常量，参数不可改变
  api_base_url:&#39;http://bl.7yue.pro/v1/&#39;,
  appkey: &quot;GgRhTjUNUYn1fHke&quot;
}
</code></pre>
<p>新建util文件夹，文件夹下新建http.js文件（对wx.request做封装），需要对request进行封装（API调用封装成一个类）</p>
<h5 id="Module-export-和import"><a href="#Module-export-和import" class="headerlink" title="Module export 和import"></a>Module export 和import</h5><p>在ES6里，<strong>一个js文件就是一个模块</strong>，模块内部定义的变量外部无法访问，需要模块主动输出（export）</p>
<p>export</p>
<pre><code class="lang-js">#config.js
export const config = {  //设置固定不变的常量，参数不可改变
  api_base_url:&#39;http://bl.7yue.pro/v1/&#39;,
  appkey: &quot;GgRhTjUNUYn1fHke&quot;
}

export let fun1 = function(){  //函数
}
</code></pre>
<pre><code class="lang-js">------------另一种写法--------
#config.js
const config = {  //设置固定不变的常量，参数不可改变
  api_base_url:&#39;http://bl.7yue.pro/v1/&#39;,
  appkey: &quot;GgRhTjUNUYn1fHke&quot;
}
let fun1 = function(){  //函数

}
export {config,fun1}
export {config as config1,fun1} //导出时改变名字
</code></pre>
<p>import</p>
<pre><code class="lang-js">#http.js
import {config，fun1} from &#39;/config.js&#39;
</code></pre>
<h5 id="封装HTTP类"><a href="#封装HTTP类" class="headerlink" title="封装HTTP类"></a>封装HTTP类</h5><p>对request进行封装（<strong>API调用封装成一个类</strong>）    </p>
<pre><code class="lang-js">#http.js
import {config} from &#39;/config.js&#39;//引用路径错，要使用相对路径

class HTTP{
    //params包含访问一个api时包含的全部参数
  request(params){//给类添加方法，直接写方法名
     if(!params.method){
       params.method=&quot;GET&quot;  //默认GET
     }
     //params(url,method,data)
    wx.request({
      url:config.api_base_url+params.url,
      method:params.method,
      data:params.data,
      header:{
        &#39;content-type&#39;:&#39;application/json&#39;,
        &#39;appkey&#39;:config.appkey
      },
      success: (res)=&gt;{
        let code = res.statusCode.toString()
        //显而易见，我们只有在HTTP状态码为2**才调用success，所以我们需要对响应结果的状态码进行判断，根据判断结果决定是否执行params.success
        if (code.startsWith(&#39;2&#39;)){  //状态码是2开头，成功，否则失败
        }
        else{

        }
      },
      fail:(err)=&gt;{

      }
    })
  }
}
export {HTTP}
</code></pre>
<h5 id="回调函数传递给调用方"><a href="#回调函数传递给调用方" class="headerlink" title="*回调函数传递给调用方"></a>*回调函数传递给调用方</h5><p>我们希望classic.js的success函数能打印服务器最终返回的信息。在http.js 的回调函数中把res返回给调用方。如何把res返回给调用方呢？</p>
<p>调用request方法时其实传了一个params,有一个已经设定好的success函数，在http.js中判断成功后调用params下的success函数把res传递进来就可以</p>
<pre><code class="lang-js">#classic.js
import {HTTP} from &#39;/util/http.js&#39;（会报错）
import {HTTP} from &#39;../../util/http.js&#39;
let http = new HTTP()//实例化一个类

onLoad: function (options) {    
    //request需要接收的参数
    http.request({
      url: &#39;classic/latest&#39;,
      success:(res)=&gt;{//res为http中的res.data
        console.log(res)
      }
    })
  },
</code></pre>
<p>上述代码运行报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200801.jpg" style="zoom: 67%;"></p>
<p>问题：为什么路径会解析错误？</p>
<p>小程序把绝对路径当做相对路径来解析</p>
<h4 id="通用错误处理"><a href="#通用错误处理" class="headerlink" title="通用错误处理"></a>通用错误处理</h4><p>HTTP状态码帮助大致判断成功还是失败</p>
<p>错误码表示具体的业务错误</p>
<pre><code class="lang-js">#http.js
import {config} from &#39;../config.js&#39;

const tips = { //json对象，记录每个错误码对应的错误提示
  1:&#39;出现了一个错误&#39;, //默认的错误码
  1005:&#39;appkey无效，请申请&#39;,
  3000:&#39;期刊不存在&#39;
}

class HTTP{
  request(params){
     //url,method,data,
    wx.request({
      url:config.api_base_url+params.url,
      method:params.method,
      data:params.data,
      header:{
        &#39;content-type&#39;:&#39;application/json&#39;,
        &#39;appkey&#39;:config.appkey
      },
      success: (res)=&gt;{//访问服务器得到的数据
        let code = res.statusCode.toString()
        if (code.startsWith(&#39;2&#39;)){  //状态码是2开头，成功，否则失败
          params.success(res.data)//结果返回回去
        }
        else{
           //服务器异常
          let error_code = res.data.error_code
         this._show_error(error_code)
        }
      },
      fail:(err)=&gt;{
        //API调用失败
        // wx.showToast({ //向用户提供错误信息，接收json对象
        //   title: &#39;错误&#39;, //向用户提示的文字
        //   icon:&#39;none&#39;,
        //   duration:&#39;2000&#39; //设置showToast的显示时间
        // })
        this._show_error(1)
      }
    })
  }


  _show_error(error_code){//标注表示私有方法
    if(!error_code){
      error_code = 1
    }
    wx.showToast({
      title: tips[error_code],
      icon:&#39;none&#39;,
      duration:2000
    })
  }
}

export{HTTP}
</code></pre>
<h3 id="流行页面编码与组件的细节"><a href="#流行页面编码与组件的细节" class="headerlink" title="流行页面编码与组件的细节"></a>流行页面编码与组件的细节</h3><h4 id="引入model概念"><a href="#引入model概念" class="headerlink" title="*引入model概念"></a>*引入model概念</h4><p>根目录下新建models文件夹，文件夹下新建classic.js文件</p>
<p>之前在pages的classic文件下onload函数里调用http的request方法，现在在models/classic的getlatest方法中发送http请求</p>
<pre><code class="lang-js">#models/classic.js
import {HTTP} from &#39;../util/http.js&#39;
class ClassicModel extends HTTP{类继承
    getLatest(){
        this.request({通过继承来引用方法的话不用实例化了
            url:&#39;classic/latest&#39;,
            success:(res)=&gt;{//res为http中得到的服务器数据res.data

     }
   })
    }
}
export {ClassModel}
</code></pre>
<p>回到主调方pages下的classic.js，想在onload中接收到API的请求结果，该何如调用？</p>
<p>既然有了model,通过model的调用来获取API的结果</p>
<p>怎么接受getlatest方法的调用结果呢？</p>
<p>let latest = classic.getlatest()   错误，getlatest是一个异步的方法。为什么getlatest是一个异步的方法呢？<a href="https://blog.csdn.net/samt007/article/details/54647361" target="_blank" rel="noopener">关于js的callback回调函数以及嵌套回调函数的执行过程理解</a></p>
<p>希望接受异步函数的调用结果只能用回调函数，<strong>我们把这个回调函数当做参数传到getLatest（）中，getLatest中接受这个参数，sCallback</strong></p>
<pre><code class="lang-js">#classic.js
import {HTTP} from &#39;../util/http.js&#39;
class ClassicModel extends HTTP{
    getLatest(sCallback){//去服务器加载最新的期刊,getLast中需要接收这个回调函数,用sCallback，
        this.request({通过继承来引用方法的话不用实例化了
            url:&#39;classic/latest&#39;,
            success:(res)=&gt;{
            //访问成功，success函数接收到api的调用结果后调用sCallback函数把结果回传回去
            sCallback(res)
     }
   })
    }
}
export {ClassModel}
</code></pre>
<pre><code class="lang-js">#pages下的classic.js
import {ClassicModel} from &#39;../../models/classic.js&#39;
 let classic = new classicModel()
 onLoad: function (options) {
     classic.getLatest((res)=&gt;{
        console.log(res)
    } )//异步的方法
  },
</code></pre>
<p>使用回调函数剥夺了函数return的能力</p>
<p>有什么办法能在执行getLatest方法后通过变量等于的方式接收到此次调用的结果？有，promise</p>
<h4 id="组件属性赋值与页面渲染流程"><a href="#组件属性赋值与页面渲染流程" class="headerlink" title="组件属性赋值与页面渲染流程"></a>组件属性赋值与页面渲染流程</h4><p>现在已经成功在getLates()回调函数中拿到服务器回传的数据，拿到数据后做什么？</p>
<p>把数据显示在页面上。页面由一个个组件构成，我们要把从服务器取到的数据传入组件内部让组件显示这个数据。</p>
<p>如like组件，<strong>把js中的数据传达页面上，调用setData函数</strong></p>
<pre><code class="lang-js">#classic.js 
 data: {
    classicData:null
  },

onLoad: function (options) {
    classic.getLatest((res)=&gt;{
      this.setData({//接受json对象
          classicData:res
      })
    })
  },
</code></pre>
<p>如何把like组件需要的数据传到like组件中？</p>
<p>从组件的外部设置组件的属性</p>
<pre><code class="lang-js">#classic.wxml
&lt;v-like like=&quot;{{classicData.like_status}}&quot; count = &quot;{{classicData.fav_nums}}&quot;
</code></pre>
<p>like_status是classicData(json)对象的一个属性</p>
<p>在小程序setData中所有的js对象可以在调试器中看到</p>
<p>调试器——AppData,快速查找设置属性的名字</p>
<p>流程：在页面的classic.js中加载服务器数据——数据绑定——wxml可以使用数据——-通过组属性传递到组件内部</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200802.jpg" alt></p>
<p>setData：做数据更新</p>
<h3 id="movie组件的实现"><a href="#movie组件的实现" class="headerlink" title="movie组件的实现"></a>movie组件的实现</h3><p>components目录下新建文件夹classic，classic文件夹下新建movie文件夹，新建index的component文件。</p>
<p>在index.wxml下编写骨架</p>
<pre><code class="lang-html">#index.wxml
&lt;view&gt;
    &lt;image&gt;&lt;/image&gt;
    &lt;image&gt;&lt;/image&gt;
    &lt;text&gt;&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<p>完成骨架后，有两个</p>
<p>问题需要解决1.骨架的样式2.骨架中需要填入数据</p>
<p>思考数据的思路：data内部数据（小图片电影）和properties属性数据(文本图片，大图片)</p>
<pre><code class="lang-js">#index.js
properties:{
    img:String
    content:String
},
</code></pre>
<p>movie下新建文件夹images,存放movie@tag.png</p>
<pre><code class="lang-html">#index.wxml
&lt;view&gt;
    &lt;image src=&quot;{{img}}&quot;&gt;&lt;/image&gt;
    &lt;image src=&quot;images/movie@tag.png&quot;&gt;&lt;/image&gt;
    &lt;text&gt;{{content}}&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<p>classic.json引用movie-cmp组件</p>
<pre><code class="lang-json">{
  &quot;usingComponents&quot;: {
    &quot;like-cmp&quot;:&quot;/components/like/index&quot;,
    &quot;movie-cmp&quot;:&quot;/components/classic/movie/index&quot;
  }
}
</code></pre>
<p>classsic.wxml中引用组件</p>
<pre><code class="lang-html">&lt;like-cmp like=&quot;{{classicData.like_status}}&quot; count=&quot;{{classicData.fav_nums}}&quot;/&gt;
&lt;movie-cmp img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
</code></pre>
<p>index.wxss编写样式</p>
<pre><code class="lang-html">#index.wxml
&lt;view class=&quot;classic-container&quot;&gt;
    &lt;image class=&quot;class-img&quot; src=&quot;{{img}}&quot;&gt;&lt;/image&gt;
    &lt;image clasa=&quot;tag&quot; src=&quot;images/movie@tag.png&quot;&gt;&lt;/image&gt;
    &lt;text class=&quot;ccontent&quot;&gt;{{content}}&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-css">.classic-container{
    display:flex;
    flex-direction:column,
    align-items:center //所有元素居中对齐
}

.classic-img{
    width:750rpx;
    height:500rpx,
}

.tag{
    width:46rpx;
    height:142rpx;
    position:relative;//是相对当前位置的偏移
    right:310rpx;
    bottom:58rpx;
}

.content{
    font-size:36rpx;
    max-width:550rpx;  //文本换行(不固定宽度，自适应)
}
</code></pre>
<p>max-width:550rpx;  //文本换行(不固定宽度，自适应)</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200807.jpg" style="zoom: 50%;"></p>
<h3 id="组件的通用性"><a href="#组件的通用性" class="headerlink" title="组件的通用性"></a>组件的通用性</h3><p>此时，点击like组件，数字加一，重新加载页面，会恢复初始状态。因为点击时只是在小程序的前端做了样式的改变，真实的数据并没有提交到服务器。</p>
<h4 id="向服务器提交数据"><a href="#向服务器提交数据" class="headerlink" title="向服务器提交数据"></a><strong>向服务器提交数据</strong></h4><p>like组件的index.js,定位到onLike。<strong>onlike函数是我们对于用户点击LIKE组件事件的监听函数</strong>。在onlike函数里调用服务器的API就可以把数据提交到服务器中。</p>
<pre><code class="lang-js">methods: {
    onlike:function(event){
      wx.request({
          url:使用Like组件的使用场景不同，点赞的服务器请求的API会变化
      })
      let count = this.properties.count;
      let like = this.properties.like;
      count = like?count-1:count+1;
      this.setData(
        {
          count: count,
          like:!like
        }
      )
    }
  }
</code></pre>
<p>上述写法的问题：使用Like组件的使用场景不同，点赞的服务器请求的API会变化（如对电影点赞和对书籍点赞），两个场景下面所访问的服务器API是不同的，直接把请求在onlike函数里写死没法复用。</p>
<p>对于并不通用的业务，比如请求API，不要把他写在组件里面，从而保持组件的通用性。</p>
<p>请求不写在组件里面，该写在哪里呢？</p>
<p>考虑Like组件数据初始化的时候在page中请求到数据后传到Like中，同样的逻辑，<strong>在提交数据的时候，我们应该把代码写在页面也就是classic.js中。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008072.jpg" style="zoom: 67%;"></p>
<p>三个页面都需要使用某一个组件，原则：组件只完成通用的业务逻辑，不完成特定的业务逻辑，特定的业务逻辑写在组件使用方page1,page2,page3… …</p>
<p>业务逻辑到底写在组件的使用方还是封装在组件里，体现了组件的<strong>粒度</strong></p>
<h3 id="自定义事件的激活与监听"><a href="#自定义事件的激活与监听" class="headerlink" title="*自定义事件的激活与监听"></a>*自定义事件的激活与监听</h3><p>对于点赞的操作写在组件的使用方classic.js。在页面上怎么知道用户什么时候点击了LIKE组件。</p>
<p>like组件的index.js的onlike知道当前的点赞状态</p>
<h4 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h4><p>自定义事件需要实现目标：</p>
<p>1事件需要通知我们的页面用户点击了这个组件 </p>
<p>2附加一个状态，用户点赞的状态</p>
<pre><code class="lang-js">#like/index.js
methods: {
    onlike:function(event){
      let count = this.properties.count;
      let like = this.properties.like;
      count = like?count-1:count+1;
      this.setData({
          count: count,
          like:!like
        })
        //标识用户点赞还是取消点赞
        //激活
        let behavior = this.properties.like?&#39;like&#39;:&#39;cancel&#39;
        this.triggerEvent(&#39;like&#39;,{
            behavior:behavior
        },{})
    }
  }
</code></pre>
<p>triggerEvent(‘自定义事件的名称’,{js对象，自己定义的属性}，{一般情况下不需要使用})。</p>
<h4 id="激活一个自定义事件"><a href="#激活一个自定义事件" class="headerlink" title="激活一个自定义事件"></a>激活一个自定义事件</h4><p>触发（trigger）了一个自定义事件，在页面中激活这个自定义事件</p>
<pre><code class="lang-js">#pages/class.js
&lt;like-cmp bind:like=&quot;onLike&quot; like=&quot;{{classicData.like_status}}&quot; count=&quot;{{classicData.fav_nums}}&quot;/&gt;
&lt;movie-cmp img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
</code></pre>
<p>运行显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200808.jpg" style="zoom: 50%;"></p>
<p>detail的状态此时是like</p>
<pre><code class="lang-js">#pages/classic.js
//自定义事件
  onLike:function(event){
    console.log(event)
      //拿到like组件当前的状态
    let behavior = event.detail.behavior
    //向服务器提交相应的状态数据(放到models下面编写)
  },
</code></pre>
<p>models下新建文件like.js</p>
<pre><code class="lang-js">import {HTTP} from &#39;../util/http.js&#39;
class  LikeModel extends HTTP{
    like(hehavior,artID,category){//点赞对象，点赞类型
        let url = hehavior==&quot;like&quot;?&#39;like&#39;:&#39;like/cancel&#39;
        //数据的提交
        this.request({
            url:url,
            method:&#39;POST,
            data:{
                art_id:artID,
                type:category
            }
        })
    }
}
export {LikeModel}
</code></pre>
<p>上面不用到回调函数succeess</p>
<p>在pages/classic.js中使用likeModel</p>
<pre><code class="lang-js">import {ClassicModel} from &#39;../../models/classic.js&#39;
import {LikeModel} from &#39;../../models/like.js&#39;
let classicModel = new ClassicModel()
let likeModel = new LikeModel()
... ...
 onLoad: function (options) {
    classic.getLatest((res)=&gt;{
      this.setData({
        classicData:res
      })
    })
  },
//自定义事件
  onLike:function(event){
    console.log(event)
      //拿到like组件当前的状态
    let behavior = event.detail.behavior
    //向服务器提交相应的状态数据，放到models下面编写
    likeModel.like(behavior,this.data.classicData.id,this.data.classicData.type)
  },
</code></pre>
<p>有报错：</p>
<pre><code class="lang-java">VM804:1 MiniProgramError
params.success is not a function
TypeError: params.success is not a function
    at success (http://127.0.0.1:19643/appservice/util/http.js:45:20)
    at Object.i.&lt;computed&gt; (http://127.0.0.1:19643/appservice/__dev__/WAService.js:2:1794394)
    at http://127.0.0.1:19643/appservice/__dev__/WAService.js:2:661168
</code></pre>
<p>调用request时没有request函数，但在http.js中有</p>
<p>改进http.js</p>
<pre><code class="lang-js"> success:(res)=&gt;{
        let code = res.statusCode.toString();
        if (code.startsWith(&#39;2&#39;)){
            //params.success为空时不执行后面的代码
          params.success &amp;&amp; params.success(res.data)
        }else{
          let error_code = res.data.error_code
          this._show_error(error_code)
        }
      },
</code></pre>
<h3 id="期刊组件"><a href="#期刊组件" class="headerlink" title="期刊组件"></a>期刊组件</h3><p>效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200816.jpg" style="zoom:80%;"></p>
<p> compenents文件夹下新建epsoide文件，新建组件index</p>
<pre><code class="lang-js">#eposide/index.js
  properties: {
    index:Number
  },

  data: {
    year:Number,//错
    month:String//错
  },
</code></pre>
<pre><code class="lang-js">#index.wxml
&lt;view&gt;
  &lt;text&gt;No.&lt;/text&gt;
  &lt;text&gt;{{index}}&lt;/text&gt;
  &lt;text&gt;|&lt;/text&gt;
  &lt;text&gt;{{month}}&lt;/text&gt;
  &lt;text&gt;{{year}}&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-json">#classic.json
{
  &quot;usingComponents&quot;: {
    ... ...
    &quot;epsoide-cmp&quot;:&quot;/components/epsoide/index&quot;
  }
}
</code></pre>
<pre><code class="lang-html">&lt;epsoide-cmp/&gt;
&lt;like-cmp bind:like=&quot;onLike&quot; like=&quot;{{classicData.like_status}}&quot; count=&quot;{{classicData.fav_nums}}&quot;/&gt;
&lt;movie-cmp img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
</code></pre>
<h4 id="组件的生命周期函数"><a href="#组件的生命周期函数" class="headerlink" title="组件的生命周期函数"></a>组件的生命周期函数</h4><p>​    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/20080811.jpg" style="zoom:50%;"></p>
<p>组件的生命周期直接写在外面（不写在method方法中）</p>
<p>当组件被页面加载时就会执行attached函数</p>
<pre><code class="lang-js">#epsoide/index.js
attached:function(){
    console.log(this.properties)
    console.log(this.data)
  },
</code></pre>
<p>执行打印出</p>
<pre><code class="lang-java">{year: ƒ, month: ƒ, index: 0}
index: 0
month: ƒ String()
year: ƒ Number()

__proto__: Object
{year: ƒ, month: ƒ, index: 0}
index: 0
month: ƒ String()
year: ƒ Number()
__proto__: Object
</code></pre>
<p>小程序后台会将data和properties合并，year和month都是内置的函数</p>
<p>对data:{}下面的变量做初始化，不能用number,string,会让其变成一个函数</p>
<pre><code class="lang-js">/**
   * 组件的初始数据
   */
  data: {
    year:0,
    month:&#39;&#39;
  },
</code></pre>
<pre><code class="lang-html">&lt;epsoide-cmp index=&quot;{{classicData.index}}&quot;/&gt;/&gt;
&lt;like-cmp bind:like=&quot;onLike&quot; like=&quot;{{classicData.like_status}}&quot; count=&quot;{{classicData.fav_nums}}&quot;/&gt;
&lt;movie-cmp img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
</code></pre>
<p><strong>业务逻辑写在组件里还是页面里？</strong></p>
<p>上述的期刊数据8要显示成08，这一业务逻辑放在epsoide组件中实现，因为只有这个组件有这个需求</p>
<pre><code class="lang-js">#eposide/index.js
properties:{
    index:{
        type:Number,
        //函数的意义在于当我们改变属性的时候微信小程序会主动调用observer，同时往函数内部传递几个值
        observer:function(newVal,oldVal,changedPath){
            let val = newVal &lt;10?&#39;0&#39;+newVal:newVal
            //更新属性
            this.setData({
              index:val
        })
        }
    }
}
</code></pre>
<p>结果还是8。因为index是number,08自动当成数据</p>
<p>index类型取数字不会出现无限递归调用的情况：最开始0，在外部把数字0改成8，触发observer监听函数的调用，8传进来后通过let处理变成08，setData虽然改变了，由于index是数字，08还是强制转型变成8，不会再次触发observer的调用。</p>
<p>把index的属性变成String——-&gt;出现无限递归调用造成内存泄漏（在一个监听函数内部更改observer属性有一次触发observer…. …）</p>
<p><strong>综上不要在observer中修改自身属性</strong></p>
<p>正确方法如下：</p>
<pre><code class="lang-js">#epsoide/index.js
properties:{
    index:{
        type:Number,
        //函数的意义在于当我们改变属性的时候微信小程序会主动调用observer，同时往函数内部传递几个值
        observer:function(newVal,oldVal,changedPath){
            let val = newVal &lt;10?&#39;0&#39;+newVal:newVal
            //更新属性
            this.setData({
              _index:val
        })
        }
    }
}
data:{
    year:0,
    month:&#39;&#39;,
    //不和properties中的index重名
    _index:&#39;&#39;
}
</code></pre>
<p>xml中： </p>
<pre><code class="lang-xml">&lt;text&gt;{{_index}}&lt;/text&gt;
</code></pre>
<h4 id="epsoide组件与样式"><a href="#epsoide组件与样式" class="headerlink" title="epsoide组件与样式"></a>epsoide组件与样式</h4><pre><code class="lang-js">#epsoide/index.js
data: {
    months:[
      &#39;一月&#39;,&#39;二月&#39;,&#39;三月&#39;,&#39;四月&#39;,&#39;五月&#39;,&#39;六月&#39;,&#39;七月&#39;,&#39;八月&#39;,&#39;九月&#39;,&#39;十月&#39;,&#39;十一月&#39;,&#39;十二月&#39;
    ],
    year:0,
    month:&#39;&#39;,
    _index:&#39;&#39;
  },

  attached:function(){
   let date = new Date()
   let year = date.getFullYear()
   let month = date.getMonth()//从0开始

   this.setData({
     year:year,
     month:this.data.months[month]
   })
  },
</code></pre>
<p>样式</p>
<pre><code class="lang-html">#index.wxml
&lt;view class=&quot;container&quot;&gt;

  &lt;view class=&quot;index-container&quot;&gt;
    &lt;text class=&quot;plain&quot;&gt;No.&lt;/text&gt;
    &lt;text class=&quot;index&quot;&gt;{{_index}}&lt;/text&gt;
    &lt;view class=&quot;line&quot;&gt;&lt;/view&gt;
  &lt;/view&gt;

  &lt;view class=&quot;date-container&quot;&gt;
    &lt;text class=&quot;month&quot;&gt;{{month}}&lt;/text&gt;
    &lt;text class=&quot;year&quot;&gt;{{year}}&lt;/text&gt;
  &lt;/view&gt;

&lt;/view&gt;
</code></pre>
<pre><code class="lang-css">#index.wxss
.container{
  height:60rpx;
  display:inline-flex;
  flex-direction: row;
}

.index-container{
  display: flex;
  flex-direction: row;
  align-items: baseline;  //底部对齐
}

.plain{
  font-size: 32rpx;
}

.index{
  font-size: 60rpx;
  line-height: 60rpx;
  font-weight: 800;//加粗
  margin-right: 14rpx;//调整和竖线的距离
}

.line{
  height: 44rpx;
  margin-right: 14rpx;
  border-left: 1px solid black;
}

.date-container{
  display: flex;
  flex-direction: column;
  margin-top: 5rpx;//上边距
}

.month{
  font-size: 24rpx;
  line-height: 24rpx;
}

.year{
  font-size: 20rpx;
}
</code></pre>
<pre><code class="lang-html">#classic.wxml
&lt;view class=&quot;header&quot;&gt;
 &lt;epsoide-cmp class=&quot;epsoide&quot; index=&quot;{{classicData.index}}&quot;/&gt;
 ......
</code></pre>
<pre><code class="lang-css">#classic.wxss
.header{
  display: flex;
  flex-direction: row;
  height: 100rpx;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid #f5f5f5;
  border-bottom: 1px solid #f5f5f5;
}

.epsoide{
  margin-left: 20rpx;
  margin-top:4rpx;
}

.like{
  margin-top:6rpx;
}
</code></pre>
<h3 id="Behavior行为与加入缓存系统优化流行页面"><a href="#Behavior行为与加入缓存系统优化流行页面" class="headerlink" title="Behavior行为与加入缓存系统优化流行页面"></a>Behavior行为与加入缓存系统优化流行页面</h3><p>即使服务器返回数据的速度再快，我们依然需要<strong>在页面中加入缓存系统来优化用户体验</strong>。</p>
<p>组件是一种复用的逻辑，但多个组件间的共同JS代码又改如何复用？使用Behaviors行为将解决这个问题。同时，我们也将谈谈Behavior和多继承的思想。</p>
<h4 id="navi组件"><a href="#navi组件" class="headerlink" title="navi组件"></a>navi组件</h4><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008161.jpg" style="zoom:67%;"></p>
<p>components文件夹下新建navi组件。navi下新建images存放相关图片。</p>
<p>1navi组件的骨架</p>
<p>背景（container容器），向左向右的img,title（文本）</p>
<pre><code class="lang-html">#navi/index.wxml
&lt;view&gt;
  &lt;image&gt;&lt;/image&gt;
  &lt;text&gt;&lt;/text&gt;
  &lt;image&gt;&lt;/image&gt;
&lt;/view&gt;
</code></pre>
<p>2确定属性和内部私有变量</p>
<pre><code class="lang-js">#navi/index.js
properties: {
    title:String,
    first:Boolean,//当前的期刊是否是最开始的一期
    latest:Boolean//当前的期刊是否是最新一期
  },

  data: {
     //四张图片的位置
    disLeftSrc:&#39;images/triangle.dis@left.png&#39;,
    lefSrc:&#39;images/triangle@left.png&#39;,
    disRightSrc:&#39;images/triangle.dis@right.png&#39;,
    rightSrc:&#39;images/triangle@right.png&#39;
  },
</code></pre>
<p>3.wxml中需要绑定哪些变量</p>
<pre><code class="lang-html">&lt;view&gt;
  &lt;image src=&quot;{{latest?disLeftSrc;leftSrc}}&quot;&gt;&lt;/image&gt;
  &lt;text&gt;{{title}}&lt;/text&gt;
  &lt;image src=&quot;{{first?disRightSrc;rightSrc}}&quot;&gt;&lt;/image&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-json">classic.json
{
  &quot;usingComponents&quot;: {
    ... ...
    &quot;navi-cmp&quot;:&quot;/components/navi/index&quot;
  }
}
</code></pre>
<pre><code class="lang-html">classic.wxml
&lt;view class=&quot;header&quot;&gt;
 &lt;epsoide-cmp class=&quot;epsoide&quot; index=&quot;{{classicData.index}}&quot;/&gt;
 &lt;like-cmp class=&quot;like&quot; bind:like=&quot;onLike&quot; like=&quot;{{classicData.like_status}}&quot; count=&quot;{{classicData.fav_nums}}&quot;/&gt;
&lt;/view&gt;

&lt;movie-cmp img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
&lt;navi-cmp/&gt;
</code></pre>
<p>样式：</p>
<pre><code class="lang-html">&lt;view class= &quot;container&quot;&gt;
  &lt;image class=&quot;icon&quot; src=&quot;{{latest?disLeftSrc:leftSrc}}&quot;&gt;&lt;/image&gt;
  &lt;text class=&quot;title&quot;&gt;{{title}}&lt;/text&gt;
  &lt;image class=&quot;icon&quot; src=&quot;{{first?disRightSrc:rightSrc}}&quot;&gt;&lt;/image&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-css">.container{
  width: 600rpx;
  height: 80rpx;
  background-color: #f7f7f7;
  border-radius: 2px;
  display: inline-flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center; 
}

.icon{
  height: 80rpx;
  width: 80rpx;
}

.title{
  font-size: 28rpx;
}
</code></pre>
<p>navi组件成行了</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200809.jpg" style="zoom:50%;"></p>
<p>因为还没有传入数据，所有组件行为还没展现。</p>
<p>前端编程小经验：移动端真实的触碰区比实际按钮要大。需要扩大触碰区域</p>
<p>调整组件在classic页面中的位置</p>
<p>碰到布局的问题查看调试器的Wxml,</p>
<pre><code class="lang-css">.container{
  width:100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.header{
  width: 100%; //避免居中
  display: flex;
  flex-direction: row;
  height: 100rpx;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid #f5f5f5;
  border-bottom: 1px solid #f5f5f5;
}

.epsoide{
  margin-left: 20rpx;
  margin-top:4rpx;
}

.like{
  margin-top:6rpx;
}

.navi{
  display: flex;
  position: absolute;
  bottom: 40rpx;
}
</code></pre>
<pre><code class="lang-xml">&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;header&quot;&gt;
  &lt;epsoide-cmp class=&quot;epsoide&quot; index=&quot;{{classicData.index}}&quot;/&gt;
  &lt;like-cmp class=&quot;like&quot; bind:like=&quot;onLike&quot; like=&quot;{{classicData.like_status}}&quot; count=&quot;{{classicData.fav_nums}}&quot;/&gt;
  &lt;/view&gt;
  &lt;movie-cmp img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
  &lt;navi-cmp class=&quot;navi&quot;/&gt;
&lt;/view&gt;
</code></pre>
<p>传入属性</p>
<p>服务器没有直接返回first,latest，也就不能直接用classicData.来引用</p>
<pre><code class="lang-js">classic.js
data: {
    classicData:null,
    latest:true,
    first:false
  },
</code></pre>
<pre><code class="lang-html"> classic.wxml
 &lt;navi-cmp class=&quot;navi&quot; title=&quot;{{classicData.title}}&quot; first=&quot;{{first}}&quot; latest=&quot;{{latest}}&quot;/&gt;
</code></pre>
<p>预览小程序</p>
<p><strong>真机预览小程序</strong></p>
<p>预览—扫描二维码，如果想访问API，打开小程序调试模式</p>
<p>navi组件操作movie组件，需要知道用户什么时候点击和点击方向</p>
<p>在navi组件的内部监听用户点击letft,right的事件，监听到内部事件后在navi组件内部用triggerEvent激活自定义事件</p>
<pre><code class="lang-html">&lt;view class= &quot;container&quot;&gt;
  &lt;image bind:tap=&quot;onLeft&quot; class=&quot;icon&quot; src=&quot;{{latest?disLeftSrc:leftSrc}}&quot;&gt;&lt;/image&gt;
  &lt;text class=&quot;title&quot;&gt;{{title}}&lt;/text&gt;
  &lt;image bind:tap=&quot;onRight&quot; class=&quot;icon&quot; src=&quot;{{first?disRightSrc:rightSrc}}&quot;&gt;&lt;/image&gt;
&lt;/view&gt;
</code></pre>
<p>定义好监听函数后在index.js中method里实现：</p>
<pre><code class="lang-js">index.js
methods: {
    onLeft:function(event){
      // 觸發一個自定義事件
      this.triggerEvent(&#39;left&#39;,{},{})
    },

    onRight:function(event){
      this.triggerEvent(&#39;right&#39;,{},{})
    }
  }
</code></pre>
<p>到classic页面中监听navi组件触发的事件</p>
<pre><code class="lang-html">#classic.wxml
&lt;view class=&quot;container&quot;&gt;
  ... ...
  &lt;navi-cmp bind:left=&quot;onNext&quot; bind:right=&quot;onPrevious&quot; class=&quot;navi&quot; title=&quot;{{classicData.title}}&quot; first=&quot;{{first}}&quot; latest=&quot;{{latest}}&quot;/&gt;
&lt;/view&gt;
</code></pre>
<p>在classic.js自定义onNext,onProvious监听函数</p>
<p>关于自定义事件以及事件的传递：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008092.jpg" style="zoom: 50%;"></p>
<p>多级的事件传递,component1中自定触发义激活event事件,通过一层层的监听捕获传到页面中</p>
<h5 id="禁用事件的技巧"><a href="#禁用事件的技巧" class="headerlink" title="禁用事件的技巧"></a>禁用事件的技巧</h5><p>组件自身处理</p>
<p>index.js</p>
<pre><code class="lang-js">  methods: {
    onLeft:function(event){
      if(!this.properties.latest){
          // 觸發一個自定義事件
        this.triggerEvent(&#39;left&#39;,{},{})
      }

    },
    onRight:function(event){
      if(!this.properties.first){
        this.triggerEvent(&#39;right&#39;,{},{})
      }   
    }
  }
})
</code></pre>
<p>classic.js中先增加自定义函数</p>
<pre><code class="lang-js">  onNext:function(event){

  },
  onPrevious:function(event){

  }
</code></pre>
<h3 id="music组件"><a href="#music组件" class="headerlink" title="music组件"></a>music组件</h3><p>新建文件方法不再累述，components/classic/music</p>
<p>数据</p>
<pre><code class="lang-js">Component({
  properties: {
    img:String,
    content:String
  },

  data: {
    pauseSrc:&#39;images/player@waitting.png&#39;,
    playSrc:&#39;images/player@playing.png&#39;
  },
</code></pre>
<p>骨架</p>
<pre><code class="lang-html">&lt;view&gt;
  &lt;image src=&quot;{{img}}&quot;&gt;&lt;/image&gt;
  &lt;image src=&quot;{{playSrc}}&quot;&gt;&lt;/image&gt;
  &lt;image src=&quot;images/music@tag.png&quot;&gt;&lt;/image&gt;
  &lt;text&gt;{{content}}&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<h3 id="句子组件"><a href="#句子组件" class="headerlink" title="句子组件"></a>句子组件</h3><p>components/classic/essay</p>
<h4 id="初识组件的behavior行为"><a href="#初识组件的behavior行为" class="headerlink" title="初识组件的behavior行为"></a>初识组件的behavior行为</h4><p>数据</p>
<pre><code class="lang-js">Component({

  properties: {
  //与movie相同
    img:String,
    content:String
  },
  data: {

  },
</code></pre>
<p><strong>小程序中对于组件的代码复用通过behavior实现</strong>。定义behavior是给多个组件定义共同的行为。把behavior定义在单独的文件中。我们在components的classic文件夹下新建classic-beh.js</p>
<p>编写Behavior的方式和Component类似</p>
<pre><code class="lang-js"> properties: {
  //与movie相同
    img:String,
    content:String
  }
</code></pre>
<p>上述属性是music,essay,moive共有的</p>
<p>behavior是一个构造器，构造一个行为，用一个变量来接受它</p>
<pre><code class="lang-js">#classic-beh.js
let classicBeh = Behavior({
  properties:{
    img:String,
    content:String
  },
  data:{

  },
  methods:{

  }

})

export {classicBeh}
</code></pre>
<p>其他组件中引用behavior</p>
<p>如essay,同理更新别的代码</p>
<pre><code class="lang-js">index.js
// components/classic/essay/index.js
import {classicBeh} from &#39;../classic-beh.js&#39;
Component({
  /**
   * 组件的属性列表
   */
  //通過屬性顯示指定essay組件繼承classicbehavior
  behaviors:[classicBeh],
  //多继承
  properties: {

  },
</code></pre>
<h4 id="behavior继承与多继承的覆盖规则"><a href="#behavior继承与多继承的覆盖规则" class="headerlink" title="behavior继承与多继承的覆盖规则"></a>behavior继承与多继承的覆盖规则</h4><p>子类覆盖父类中的相关属性</p>
<p>behaviors:[A,B,C]</p>
<p>多继承中有同名属性，最后 的Behavior如C得到继承</p>
<p>对behavior的继承有特例，生命周期函数继承。如在子函数中attached:function,在behavior也有，不会有覆盖发生，小程序依次调用每个behavior中的生命周期函数，最后调用子函数的生命周期函数。不会有覆盖。</p>
<h4 id="期刊切换"><a href="#期刊切换" class="headerlink" title="期刊切换"></a>期刊切换</h4><p>是否是最新期刊的判断逻辑初步实现期刊切换</p>
<p>essay的骨架：</p>
<pre><code class="lang-html">&lt;view class=&quot;classic-container&quot;&gt;
  &lt;image class=&quot;classic-img&quot; src=&quot;{{img}}&quot;&gt;&lt;/image&gt;
  &lt;image class=&quot;tag&quot; src=&quot;images/eaasy@tag.png&quot;&gt;&lt;/image&gt;
  &lt;text class=&quot;content&quot;&gt;{{content}}&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<p>实现切换效果：</p>
<p>当我们点击向右时，应该获取前一期期刊的信息。</p>
<p>获取前一期信息的接口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008094.jpg" style="zoom: 50%;"></p>
<p>pages/classic.js的onPrevious。不把调用的直接方法写在当中，定义在models中</p>
<p>models/classic.js中新增方法getPrevious</p>
<pre><code class="lang-js">#models/classic.js
... ...
getPrevious(index,sCallback){
  this.request({
    url:&#39;classic/&#39;+ index +&#39;/previous&#39;,
    success:(res)=&gt;{
      sCallback(res)
    }
  })
 }
</code></pre>
<pre><code class="lang-js">#pages/classic.js
......
onPrevious:function(event){
    let index = this.data.classicData.index//当前期刊的序号
    classicModel.getPrevious(index,(res)=&gt;{
      console.log(res)
    })
  },
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/08095.jpg" style="zoom:50%;"></p>
<p><strong>获取到最新的classic数据后需要替换原页面信息，更新数据</strong></p>
<pre><code class="lang-js">#classic.js
......
onPrevious:function(event){
    let index = this.data.classicData.index//当前期刊的序号
    classicModel.getPrevious(index,(res)=&gt;{
      this.setData({
          classicData:res
      })
    })
  },
</code></pre>
<p>问题：1无法回退 2到了最后还能继续翻3左边的永远不可点击</p>
<h5 id="是否是最新期刊的逻辑判断"><a href="#是否是最新期刊的逻辑判断" class="headerlink" title="是否是最新期刊的逻辑判断"></a><strong>是否是最新期刊的逻辑判断</strong></h5><p>classic.js中的data没有更改</p>
<pre><code class="lang-js"> data: {
    classicData:null,
    latest:true,
    first:false
  },
</code></pre>
<p>如何动态决定latest和first的取值呢？关键变量是index</p>
<p>models/classic.js</p>
<pre><code class="lang-js">isFirst(index){
    return index == 1 ? true:false
  }

isLatest(index){
    //需要拿到的是最新的期刊號
    ???
  }
</code></pre>
<p>pages/classic.js的<strong>onload()中加载到的是最新的期刊号</strong></p>
<pre><code class="lang-js">  onLoad: function (options) {
    classicModel.getLatest((res)=&gt;{
      this.setData({
        classicData:res
      })
      console.log(res)
      //latestClassicData
    })
  },
</code></pre>
<p>我们现在定义两个classicData。onload中获取到的classicData称作latestClassicData。 latestIndex，我们点击onPrevious加载的classicData称为currentClassicData currentIndex。</p>
<p><strong>比较两个index就能知道是否是最新的一起期刊</strong></p>
<p>从latestClassicData和currentClassicData取出index进行对比，页面目前只有一个位置保存了classicData:</p>
<pre><code class="lang-js"> data: {
    classicData:null,
    latest:true,
    first:false
  },
</code></pre>
<p>classicData初始时保存最新一期的信息，期刊切换后数据变化，不会一直保存最新信息。为了防止latestClassdata被覆盖，我们借助Storage缓存。</p>
<pre><code class="lang-js">#modules/classic.js
//同步写入缓存
_setLatestIndex(index){
    wx.setStorageSyc(&#39;latest&#39;,index)
}

//读缓存
_getLatestIndex(){
    let index = wx.getStorageSyc(&#39;latest&#39;)
    return index
}


getLatest(sCallback){
   this.request({
    url:&#39;classic/latest&#39;,
    success:(res)=&gt;{
      sCallback(res)
      //缓存
      this._setLatestIndex(res.index)
    }
   }
     )
 }

isLatest(index){
    //需要拿到的是最新的期刊號
    let latestIndex = this._getLatestIndex()
    return latestIndex==index?true:false
  }
</code></pre>
<p> wx.setStorageSyc(key,value),key缓存名，value缓存值</p>
<p>回到pages页面的classic.js</p>
<pre><code class="lang-js">onPrevious:function(event){
    let index = this.data.classicData.index
    classicModel.getPrevious(index,(res)=&gt;{
      this.setData({
        classicData:res,
        latest:classicModel.isLatest(res.index),
        first:classicModel.isFirst(res.index)
      })
    })
  },
</code></pre>
<p>引用了缓存后，出现疑难问题，可以选择清除缓存。—清除数据缓存</p>
<p>查看缓存 调试台—-storage</p>
<h5 id="onNext-函数与重构技巧"><a href="#onNext-函数与重构技巧" class="headerlink" title="onNext()函数与重构技巧"></a>onNext()函数与重构技巧</h5><p>models/classic.js</p>
<pre><code class="lang-js">getNext(){

}
</code></pre>
<p>pages/classic.js</p>
<pre><code>

</code></pre><p>和onPrevious高度相似，进行重构，getPrevious改成getClassic</p>
<pre><code class="lang-js">models/classic.js
getClassic(index,nextOrPrevious,sCallback){
    this.request({
    url:&#39;classic/&#39;+ index +&#39;/&#39;+nextOrprevious，
    success:(res)=&gt;{
      sCallback(res)
    }
  })
}
</code></pre>
<p>回到pages/classic.js</p>
<pre><code class="lang-js">
onNext:function(event){
    this._updataClassic(&#39;next&#39;)
},

onPrevious:function(event){
    this._updataClassic(&#39;previous&#39;)
}

_updateClassic:function(nextOrPrevious){
    let index = this.data.classicData.index
    classicModel.getClassic(index,nextOrPrevious,(res)=&gt;{
      this.setData({
        classicData:res,
        latest:classicModel.isLatest(res.index),
        first:classicModel.isFirst(res.index)
      })
    })
}
</code></pre>
<p>一般私有的方法写在最下面</p>
<p>细节：</p>
<p>切换页面每次都从服务端获取数据。<strong>加入缓存的机制</strong>，需要的数据缓存中是否存在，存在的话不再向服务器发送请求。带不带缓存技术难度存在差异。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="缓存对于改善用户体验的作用"><a href="#缓存对于改善用户体验的作用" class="headerlink" title="缓存对于改善用户体验的作用"></a>缓存对于改善用户体验的作用</h4><p>思路：</p>
<p>1获取期刊时，首先在缓存中寻找，找不到的话向服务器发送数据，从服务器获取的数据再次写到缓存中。</p>
<p>2所有的期刊在缓存中有key。对期刊数据需要确定key。设计key,代表期刊并识别。</p>
<p>models中classic.js</p>
<pre><code class="lang-js"> getLatest(sCallback){
   this.request({
    url:&#39;classic/latest&#39;,
    success:(res)=&gt;{
      sCallback(res)
      this._setLatestIndex(res.index)
      let key = this._getKey(res.index)
      wx.setStorageSync(key,res)
    }
   }
     )
 }

getClassic(index,nextOrPrevious,sCallback){//寻找期刊上一期或下一期
      //缓存中寻找or API 写入到缓存中
    //key 确定key
    let key = nextOrPrevious==&#39;next&#39;?this._getKey(index+1):this._getKey(index-1)
    let classicData = wx.getStorageSync(key)
    if (!classicData){
      this.request({
         url:&#39;classic/&#39;+index+&#39;/&#39;+nextOrPrevious,
         success:(res)=&gt;{
       wx.setStorageSyn(this._getkey(res.index),res)//写入缓存
      sCallback(res)
    }
  })
    }
    else{
        sCallbaack(classicData)
    }
}

_getKey(index){
    let key = &#39;classic-&#39;+index
    return key
}
</code></pre>
<h4 id="解决缓存带来的问题"><a href="#解决缓存带来的问题" class="headerlink" title="解决缓存带来的问题"></a>解决缓存带来的问题</h4><p>点赞状态更新问题：点击like组件后取消，切换页面后切回，like组件仍是点击后的状态，并且再次点击报错</p>
<p>原因：点击后取消，服务器的状态更新了，但是切回后的页面数据读取的是缓存，并没有从服务器加载</p>
<p><strong>单纯获取点赞信息的接口</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200817.jpg" style="zoom:50%;"></p>
<p><strong>独立更新like组件状态</strong></p>
<p>models/like.js</p>
<pre><code class="lang-js"> getClassicLikeStatus(artID,category,sCallback){
    this.request({
        url:&#39;classic/&#39;+category+&#39;/&#39;+artID+&#39;/favor&#39;,
        success:sCallback
    })
}
</code></pre>
<p>pages/classic.js</p>
<pre><code class="lang-js"> data: {
    classicData:null,
    latest:true,
    first:false,
    likeCount:0, //添加
    likeStatus:false //添加
  }, 

 _updateClassic:function(nextOrPrevious){
    let index = this.data.classicData.index
    classicModel.getClassic(index,nextOrPrevious,(res)=&gt;{
      this._getLikeStatus(res.id,res.type) //使用
      this.setData({
        classicData:res,
        latest:classicModel.isLatest(res.index),
        first:classicModel.isFirst(res.index)
      })
    })
  },

_getLikeStatus:function(artID,category){
    likeModel.getClassicLikeStatus(artID,category,(res)=&gt;{
     this.setData({
        likeCount:res.fav_nums,
        likeStatus:res.like_status
      })
    })
  },
</code></pre>
<p>classic/wxml</p>
<pre><code class="lang-html">更新
 &lt;like-cmp class=&quot;like&quot; bind:like=&quot;onLike&quot; like=&quot;{{likeStatus}}&quot; count=&quot;{{likeCount}}&quot;/&gt;
</code></pre>
<p>此时由于LIKE初始化时数据都是默认的，因此like组件显示的数据为0</p>
<p>改进：</p>
<pre><code class="lang-js">onLoad: function (options) {
    //數據更新，Storage保存最新期刊號
    classicModel.getLatest((res)=&gt;{
      this.setData({
        classicData:res,
        likeCount:res.fav_nums,
        likeStatus:res.like_status
      })

    })
  },
</code></pre>
<h3 id="ES6使用技巧"><a href="#ES6使用技巧" class="headerlink" title="ES6使用技巧"></a>ES6使用技巧</h3><h4 id="ES6模板字符串"><a href="#ES6模板字符串" class="headerlink" title="ES6模板字符串"></a>ES6模板字符串</h4><pre><code class="lang-js">let  a=123
console.log(`${a}123`)  //123456

test:function(){
    return 123
}
console.log(`${this.test()}456`)

改写：
 url:&#39;classic/&#39;+index+&#39;/&#39;+nextOrPrevious,
 改成
  url:`classic/${index}/${nextOrPrevious}`,
</code></pre>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><pre><code class="lang-js">classicData:res---&gt;...res
index=&quot;{{classicData.index}}&quot;---&gt;index=&quot;{{index}}&quot;？
</code></pre>
<h3 id="动态显示组件"><a href="#动态显示组件" class="headerlink" title="动态显示组件"></a>动态显示组件</h3><p>当前问题：</p>
<p>每个页面固定显示moive的tag，没有动态显示music、essay组件。</p>
<p>条件渲染有选择性的显示组件，条件渲染只能用在wxml中。</p>
<p><strong>wx:if</strong></p>
<pre><code class="lang-html"> &lt;movie-cmp wx:if=&quot;{{true}}&quot; img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
</code></pre>
<p><strong>hidden</strong></p>
<p>hidden也能控制标签的显示和隐藏，适用于wxml的默认标签。hidden用于自定义标签时需要设计。</p>
<p>moive/index.js中增加hidden属性</p>
<pre><code class="lang-js">properties: {
    hidden:Boolean
  },
</code></pre>
<p>moive/index.wxml</p>
<p>绑定</p>
<pre><code class="lang-html">&lt;view hidden=&quot;{{hidden}}&quot; class=&quot;classic-container&quot;&gt;
</code></pre>
<p>pages/classic.js</p>
<pre><code class="lang-html"> &lt;movie-cmp hidden=&quot;{{true}}&quot;
</code></pre>
<p>两者比较：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200818.jpg" style="zoom:50%;"></p>
<p>实现：</p>
<p>pages/classic.wxml</p>
<pre><code class="lang-html">&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;header&quot;&gt;
  &lt;epsoide-cmp class=&quot;epsoide&quot; index=&quot;{{classicData.index}}&quot;/&gt;
  &lt;like-cmp class=&quot;like&quot; bind:like=&quot;onLike&quot; like=&quot;{{likeStatus}}&quot; count=&quot;{{likeCount}}&quot;/&gt;
  &lt;/view&gt;
  &lt;movie-cmp hidden=&quot;{{classicData.type!=100}}&quot; img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
  &lt;music-cmp hidden=&quot;{{classicData.type!=200}}&quot; img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
  &lt;essay-cmp hidden=&quot;{{classicData.type!=300}}&quot; img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot; src=&quot;{{classicData.url}}&quot;/&gt;
  &lt;navi-cmp bind:left=&quot;onNext&quot; bind:right=&quot;onPrevious&quot;  class=&quot;navi&quot; title=&quot;{{classicData.title}}&quot; first=&quot;{{first}}&quot; latest=&quot;{{latest}}&quot;/&gt;  
&lt;/view&gt;
</code></pre>
<p>moive/index.js</p>
<pre><code class="lang-js">import {classicBeh} from &#39;../classic-beh.js&#39;
Component({
  /**
   * 组件的属性列表
   */
  behaviors:[classicBeh],
  properties: {
    hidden:Boolean
  },
</code></pre>
<p>改进：在共同的行为里加上hidden,不用再music,essay的index.js分别加hidden属性</p>
<p>music/index.wxml</p>
<pre><code class="lang-html">&lt;view class=&quot;container&quot; hidden=&quot;{{hidden}}&quot;&gt;
  ... ... 
&lt;/view&gt;
</code></pre>
<p>essay同理</p>
<p>classic-beh.js</p>
<pre><code class="lang-js">let classicBeh = Behavior({
  properties: {
    img:String,
    content:String,
    hidden:Boolean
  },
  data:{

  },
  methods:{

  }
})

export {classicBeh}
</code></pre>
<h3 id="essay、music样式"><a href="#essay、music样式" class="headerlink" title="essay、music样式"></a>essay、music样式</h3><h4 id="import在组件间复用样式"><a href="#import在组件间复用样式" class="headerlink" title="@import在组件间复用样式"></a>@import在组件间复用样式</h4><p>essay和moive的样式相同，实现复用共同使用wxss代码</p>
<p>组件的behavior行为解决组件js文件相关代码的复用，模板template实现复用wxss。</p>
<p>在components/classic文件夹下新建common.wxss,存放movie和essay共同的代码</p>
<pre><code class="lang-css">.classic-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.calssic-img {
  width: 800rpx;
  height: 500rpx;
}

.tag {
  width: 46rpx;
  height: 142rpx;
  position: relative;
  right: 310rpx;
  bottom: 58rpx;
}

.content{
  font-size:36rpx;
  max-width:550rpx;
}
</code></pre>
<p>moive/index.wxss</p>
<pre><code class="lang-css">@import &quot;../common.wxss&quot;;
</code></pre>
<p>essay/index.wxss</p>
<pre><code class="lang-css">@import &quot;../common.wxss&quot;
</code></pre>
<h4 id="music组件样式"><a href="#music组件样式" class="headerlink" title="music组件样式"></a>music组件样式</h4><p>index.js</p>
<pre><code class="lang-js">properties: {
   src:String//音乐播放地址
  },
</code></pre>
<p>index.wxml</p>
<pre><code class="lang-html">&lt;view class=&quot;container&quot; hidden=&quot;{{hidden}}&quot;&gt;
  &lt;image class=&quot;classic-img&quot; src=&quot;{{img}}&quot;&gt;&lt;/image&gt;
  &lt;image class=&quot;player-img&quot; src=&quot;{{playSrc}}&quot;&gt;&lt;/image&gt;
  &lt;image class=&quot;tag&quot; src=&quot;images/music@tag.png&quot;&gt;&lt;/image&gt;
  &lt;text class=&quot;content&quot;&gt;{{content}}&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<p>index.wxss</p>
<pre><code class="lang-css">.container{
  display: flex;
  flex-direction: column;
  align-items: center;
}

.classic-img{
  width: 422rpx;
  height: 422rpx;
  margin-top: 60rpx;
  border-radius: 50%;
}

.player-img{
  width: 120rpx;
  height: 120rpx;
  position: relative; 
  bottom: 270rpx;
}

.tag{
  width: 44rpx;
  height: 128rpx;
  position: relative;
  bottom: 160rpx;
  right: 310rpx;
}
</code></pre>
<h4 id="新版音乐播放对象"><a href="#新版音乐播放对象" class="headerlink" title="*新版音乐播放对象"></a>*新版音乐播放对象</h4><p>音乐播放API</p>
<p>在小程序中实现音乐播放有两种方式，第一种音乐播放控制API,由一组API控制。第二种背景音频播放管理，调用对象的相关属性和方法来完成。</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html" target="_blank" rel="noopener">getBackgroundAudioManager</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008181.jpg" style="zoom: 50%;"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008182.jpg" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008181.jpg" style="zoom: 50%;"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008182.jpg" alt></p>
<p>实现功能：</p>
<p>点击播放按钮，图片由播放变暂停，音乐播放</p>
<h5 id="图片切换"><a href="#图片切换" class="headerlink" title="图片切换"></a>图片切换</h5><p>设置一个变量控制playing</p>
<p>wxml.js</p>
<pre><code class="lang-html">&lt;image class=&quot;player-img&quot; bind:tap=&quot;onPlay&quot; src=&quot;{{!playing?playSrc:pauseSrc}}&quot;&gt;&lt;/image&gt;
</code></pre>
<p>index.js</p>
<pre><code class="lang-js">import {classicBeh} from &#39;../classic-beh.js&#39;
Component({
  /**
   * 组件的属性列表
   */
  behaviors:[classicBeh],
  properties: {
   src:String
  },

  /**
   * 组件的初始数据
   */
  data: {
    // 控制变量
    playing:false,
    pauseSrc:&#39;images/player@pause.png&#39;,
    playSrc:&#39;images/player@play.png&#39;

  },

  /**
   * 组件的方法列表
   */
  methods: {
    onPlay:function(event){
      //图片要切换
      this.setData({
        playing:true//后改
      })
    }
  }
})
</code></pre>
<h5 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h5><p>先拿到背景音乐管理对象</p>
<pre><code class="lang-js">//返回音乐管理对象
import {classicBeh} from &#39;../classic-beh.js&#39;

//返回音乐管理对象
const mMgr = wx.getBackgroundAudioManager() 

Component({
  /**
   * 组件的属性列表
   */
  behaviors:[classicBeh],
  properties: {
   src:String,
   title:String
  },

  /**
   * 组件的初始数据
   */
  data: {
    // 控制变量
    playing:false,
    pauseSrc:&#39;images/player@pause.png&#39;,
    playSrc:&#39;images/player@play.png&#39;

  },

  /**
   * 组件的方法列表
   */
  methods: {
    onPlay:function(event){
      //图片要切换
    if(!this.data.playing){
      this.setData({
        playing:true
      })
      mMgr.src = this.properties.src //src自动赋值就会播放音乐
      mMgr.title = this.properties.title
    }else{
      this.setData({
        playing:false
      })
      mMgr.pause()
    }
    }

  }
})
</code></pre>
<p>遇到的坑:小程序没添加title时没有声音，添加代码</p>
<pre><code class="lang-js">mMgr.title = this.properties.title
</code></pre>
<p>基本完成了音乐播放的功能。细节：后面所有的音乐页面图片都是播放状态</p>
<p>初步改进：</p>
<p>1.切换期刊时停止当前正在播放的音乐</p>
<p>思路：监听切换事件停止音乐，需要在music组件中监听navi组件</p>
<h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008191.jpg" alt></p>
<p>组件间通信一般情况下是父子关系，平行关系的组件要想直接交换数据怎么解决？</p>
<p>1.间接传递数据，利用页面做数据的转发</p>
<p>思路：切换页面时like组件会变成另外一个组件，当like组件消失时监听到组件消失的事件停止音乐</p>
<p>detached：组件声明周期函数，在组件实例被从页面结点树移除时执行</p>
<p>当组件触发detached时暂停音乐</p>
<p>music/index.js</p>
<pre><code class="lang-js">detached:function(event){
  mMgr.stop()
},
</code></pre>
<p>并没有效果</p>
<p>因为detached函数不会执行，原因：classic.wxml中有hidden属性，<strong>hidden不会触发组件的detached,但wx:if会</strong></p>
<p>解决：用wx:if</p>
<pre><code class="lang-html"> &lt;movie-cmp hidden=&quot;{{classicData.type!=100}}&quot; img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
&lt;--!hidden改为wx:if--&gt;
  &lt;music-cmp wx:if=&quot;{{classicData.type==200}}&quot; img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot; title=&quot;{{classicData.title}}&quot;src=&quot;{{classicData.url}}&quot;/&gt;
  &lt;essay-cmp hidden=&quot;{{classicData.type!=300}}&quot; img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot;/&gt;
</code></pre>
<p>效果：切换页面后音乐会停止，且后面音乐的图片状态正常，是待播放状态。原因：每一次改变wx:if的值的时候，所控制的组件都会执行一次完成的声明周期。从一个组件切换到另一个组件，这个组件又重新进行了一次初始化，playing默认恢复false</p>
<h3 id="完成音乐播放"><a href="#完成音乐播放" class="headerlink" title="完成音乐播放"></a>完成音乐播放</h3><p>除非用户主动取消音乐播放，否则音乐一直会播放。同时切换期刊时时每个音乐播放状态显示正常</p>
<p>每次切换到music组件时做一个检测，当前正在播放的音乐是否是当前musci组件显示的音乐。相等，小图标显示为暂停，否则显示播放状态</p>
<p>在哪个地方编写检测代码：</p>
<p>用组件的声明周期函数（attached）写检测代码</p>
<pre><code class="lang-js">attached:function(event){
    this._recoverStatus()//直接使用methods下的方法
},

  methods: {
    onPlay:function(event){
     .......
    },
    _recoverStatus:function(){
      if(mMgr.paused){//当前没有音乐在播放
        this.setData({
          playing:false
        })
        return
      }
      if(mMgr.src==this.properties.src){
        this.setData({
          playing:true
        })
      }
    }
  },
</code></pre>
<p>我们在生命周期函数中尽量不写具体的业务逻辑，把业务逻辑用私有方法封装起来，直接调用</p>
<h4 id="优化音乐播放"><a href="#优化音乐播放" class="headerlink" title="优化音乐播放"></a>优化音乐播放</h4><p>考虑到总控开关对音乐播放控制，没有产生联动</p>
<p>如何用总控开关控制自己的图片状态</p>
<p>监听总控开关的事件，onPlay,onPause,onStop,onEnded。这四个事件都接受回调函数作为参数</p>
<pre><code class="lang-js">
attached:function(event){
    this._recoverStatus()//直接使用methods下的方法
    this._monitorSwitch()
},

  methods: {
    onPlay:function(event){
     .......
    },
    _recoverStatus:function(){
    .......
  },
  _monitorSwitch:function(){
      mMgr.onPlay(()=&gt;{//音乐播放时执行这个回调函数
        this._recoverStatus()
      })
      mMgr.onPause(()=&gt;{//音乐播放时执行这个回调函数
        this._recoverStatus()
      })
      //关闭音乐播放器
      mMgr.onStop(()=&gt;{//音乐播放时执行这个回调函数
        this._recoverStatus()
      })
      //让音乐自动播放完成
      mMgr.onEnded(()=&gt;{//音乐播放时执行这个回调函数
        this._recoverStatus()
      })
    }
</code></pre>
<h4 id="旋转效果"><a href="#旋转效果" class="headerlink" title="旋转效果"></a>旋转效果</h4><p>实现动画 css3  动画API</p>
<p>music/index.wxss</p>
<pre><code class="lang-css">.rotation {
  -webkit-transform: rotate(360deg);
  animation: rotation 12s linear infinite;
  -moz-animation: rotation 12s linear infinite;
  -webkit-animation: rotation 12s linear infinite;
  -o-animation: rotation 12s linear infinite;
}

@-webkit-keyframes rotation {
  from {
    -webkit-transform: rotate(0deg);
  }

  to {
    -webkit-transform: rotate(360deg);
  }
}
</code></pre>
<pre><code class="lang-html"> &lt;image class=&quot;classic-img {{playing?'rotation':''}}&quot; src=&quot;{{img}}&quot;&gt;&lt;/image&gt;
</code></pre>
<p> Component与Model的好处</p>
<p>组件的复用性提高</p>
<p>简化了pages页面</p>
<p>提升了团队协作</p>
<p>model主要用来处理业务逻辑，pages完成数据绑定，简化页面的代码量，因此功能的实现细节方便阅读</p>
<h3 id="Promise正确用法与函数签名设计技巧"><a href="#Promise正确用法与函数签名设计技巧" class="headerlink" title="*Promise正确用法与函数签名设计技巧"></a>*Promise正确用法与函数签名设计技巧</h3><p>本章我们将讲解Promise的正确使用方式，重构http.js，同时还将使用ES6对象解构、默认值等.</p>
<h4 id="tabBar配置"><a href="#tabBar配置" class="headerlink" title="tabBar配置"></a>tabBar配置</h4><p>开始实现图书的相关功能，为小程序增加一个tabBar栏。</p>
<p>APP.json中配置即可</p>
<pre><code class="lang-js">#app.json
{
    ......
    &quot;tabBar&quot;:{
        &quot;selectedColor&quot;:&quot;#000000&quot;,//选中时颜色
        &quot;backgroundColor&quot;:&quot;#ffffff&quot;,
        &quot;color&quot;:&quot;#c7c7c7&quot;,//未选中时颜色
        &quot;list&quot;:[
          { 
            &quot;pagePath&quot;:&quot;pages/classic/classic&quot;,
            &quot;text&quot;:&quot;流行&quot;,
            &quot;iconPath&quot;:&quot;/images/tab/classic.png&quot;,
            &quot;selectedIconPath&quot;:&quot;/images/tab/classic@highlight.png&quot;
          },
          { 
            &quot;pagePath&quot;:&quot;pages/book/book&quot;,
            &quot;text&quot;:&quot;书籍&quot;,
            &quot;iconPath&quot;:&quot;/images/tab/book.png&quot;,
            &quot;selectedIconPath&quot;:&quot;/images/tab/book@highlight.png&quot;
          },
          { 
            &quot;pagePath&quot;:&quot;pages/my/my&quot;,
            &quot;text&quot;:&quot;喜欢&quot;,
            &quot;iconPath&quot;:&quot;/images/tab/my.png&quot;,
            &quot;selectedIconPath&quot;:&quot;/images/tab/my@highlight.png&quot;
          }
        ]
      }
}
</code></pre>
<p>导航栏下有多个按钮，用list配置多个按钮（json对象）</p>
<p>项目的目录下新建一个文件夹images,存放页面和全局的图片。images下新建tab文件夹，存在tab相关的图片。</p>
<p> 灰色未选中，黑色选中</p>
<p>一个tab栏至少需要两个按钮。</p>
<p>pages下新建book,my页面</p>
<h4 id="airbnb编码规范"><a href="#airbnb编码规范" class="headerlink" title="airbnb编码规范"></a>airbnb编码规范</h4><p>编写书籍相关的功能。书籍里使用规范的代码风格编写（js），eslint插件检测风格</p>
<p>github上可以查看</p>
<p>几个实用的代码编写风格：</p>
<pre><code class="lang-js">属性简写：year:year--&gt;year
方法简写：attached:function(enent)---&gt;attached(event)
import{
    classic
}from 
定义的变量不做改变时尽量用const
</code></pre>
<h4 id="纯粹回调、Promise与async、await"><a href="#纯粹回调、Promise与async、await" class="headerlink" title="纯粹回调、Promise与async、await"></a>纯粹回调、Promise与async、await</h4><p>js中处理异步的几种方式：</p>
<p><strong>纯粹callback回调</strong> </p>
<p>定义：一旦使用了纯粹的回调函数的写法，那么一层层的封装中都要传入回调函数</p>
<p>问题：容易陷入回调地狱，剥夺了函数return的能力</p>
<p><strong>promise</strong> 解决回调地狱，return 多个异步等待合并，不需要每一层传递回调函数（因为没有剥夺return的能力）</p>
<p><strong>async await</strong> ES2017 小程序不支持，promise的语法糖</p>
<h4 id="Promise的本质与用法"><a href="#Promise的本质与用法" class="headerlink" title="*Promise的本质与用法"></a>*Promise的本质与用法</h4><p>promise 是对象，不是函数</p>
<p>对象可以保存状态，函数无法保存状态（闭包函数除外）</p>
<p>promise可以传入一个函数，作为参数的函数又可以接受两个参数resolve,reject</p>
<p>new了promise,promise就处于进行中的状态，对于进行中的promise,结果只有已成功或已失败，通过resolve和reject修改状态,进行中的状态变为已成功或已失败后整个promise状态就凝固了，不能再改变。</p>
<p><strong>可以通过new出来的promise变量拿到异步调用的结果</strong>(精髓)</p>
<pre><code class="lang-js">//Promise第一步，框架
//Promise第二步，把要处理的异步代码写在promise函数中
//Promise第三步，通过then方法获取结果
const promise = new Promise((resolve,reject)=&gt;{
    //pending fulfilled rejected  promise的三种状态，分别为异步操作进行中，已成功，已失败
    wx.getSystemInfo({//例：获取系统信息的异步函数
        success:(res)=&gt;{res就是返回回来的系统信息
            resolve(res) //进行中的变为已成功
        }，
        fail:(error)=&gt;{
            reject(error)//进行中的变为已失败
        }
    })
})

//调用then方法，方法接收两个回调函数,1需要传入一个当promise调用成功的回调函数（接受调用的结果），当promise失败的回调函数，
promise.then((res)=&gt;{
    console.log(res)
},(error)=&gt;{
    console.log(error)
})


代码简化：
const promise = new Promise((resolve,reject)=&gt;{
    wx.getSystemInfo({
        success:res=&gt;resolve(res) ，
        fail:error=&gt;reject(error)
        }
    })
})

promise.then(
    res=&gt;console.log(res),
    error=&gt;console.log(error)
)
</code></pre>
<p>promise的精髓在于用对象的方式保存了异步调用的结果。<strong>promise本身作为对象可以复制给一个变量，变量在代码中可以到处传递，不需要附带任何的回调函数</strong>，一直到想去promise中取异步调用的结果时才需要加回调函数。</p>
<p>纯粹callback的问题在于封装很多层的话每一层都要写回调函数传递，每一层的函数都多了一个参数需要接收回调函数，promise作为变量不管有多少层每一层只要把promise返回回去,一直到最外面要用promise时才会用回调函数。</p>
<h4 id="Promise重构"><a href="#Promise重构" class="headerlink" title="Promise重构"></a>Promise重构</h4><p>http.js重构为http-p.js</p>
<p>让request方法return返回一个promise</p>
<p>把原来的request变成一个私有方法，另外写一个request</p>
<pre><code class="lang-js">.......
class HTTP{
    request({url,data={},method=&#39;GET&#39;}){//箭头函数中写异步代码，调用_request。
        return new Promise((resolve,reject)=&gt;{
            this._request(url,resolve,reject,data,method)
        })
    }

  //_request作为独立的方法没法直接拿到resolve,把resolve作为参数传到_request 
  _request(url,resolve,reject,data={},method=&#39;GET&#39;){//之前的parmas是js对象，由于动态语言的特性parmas可以被添加任意多个属性，现在改为明确的写法。可以默认赋值。必填参数在默认函数之前  
    wx.request({
      url: config.api_base_url+url,
      method:method,
      data:data,
      header:{
        &#39;content-type&#39;:&#39;application/json&#39;,
        &#39;appkey&#39;:config.appkey
      },
      success:(res)=&gt;{
        const code = res.statusCode.toString();
        if (code.startsWith(&#39;2&#39;)){
          resolve(res.data)
        }else{
          reject()
          const error_code = res.data.error_code
          this._show_error(error_code)
        }
      },
      fail:(res)=&gt;{
        reject()
        this._show_error(1)
      }
    })
  }

  _show_error(error_code){
    if (!error_code){
      error_code = 1;
    }
    const tip = tips[error_code]
    wx.showToast({
      title: tip?tip:tips[1],
      icon:&#39;none&#39;,
      duration:2000
    })
  }
}
export {HTTP}
</code></pre>
<p>models文件夹中新建book.js文件</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200821141607633.png" alt="image-20200821141607633" style="zoom:50%;"></p>
<pre><code class="lang-js">import{
    HTTP
}
from &#39;../util/http-p.js&#39;

class BookModel extends HTTP{
    getHotList(){
        return this.request(&#39;book/hot_list&#39;)
    }
}
export {bookModel}
</code></pre>
<p>pages/book.js调用model</p>
<pre><code class="lang-js">import{
    BookModel
}from &#39;../../models/book.js&#39;
const bookModel = new BookModel()

onload:function(){
    const hotList = bookModel.getHostList()
    hotList.then(
        res=&gt;console.log(res)
    )
}
</code></pre>
<h4 id="Promise的正确用法"><a href="#Promise的正确用法" class="headerlink" title="*Promise的正确用法"></a>*Promise的正确用法</h4><p>多次调用服务器的API，若存在链式调用，如调用服务器 的3个API, api1,api2,api3。每个回调函数内部需在写一个异步请求……</p>
<pre><code class="lang-js">//promise的错误用法
const hotList = bookModel.getHostList()
 hotList.then(
        res=&gt;console.log(res)
        bookModel.getMyBookCount()
        .then(res=&gt;{
            console.log(res)
            bookModel.getMybookCount()
            .then(res=&gt;res{
            console.log(res)
            })
        })
    )

 //正确。平行调用的关系。关键在于每次的异步调用都要返回promise
bookModel.getHostList()
 .then(res=&gt;{
    return bookModel.getMyBookCount()
})
.then(res=&gt;{
    console.log(res)
    return bookMoel.getMyBookCount()
})
.then(res=&gt;){
      console.log(res)
      }
</code></pre>
<h3 id="组件高级应用"><a href="#组件高级应用" class="headerlink" title="组件高级应用"></a>组件高级应用</h3><h4 id="图书组件"><a href="#图书组件" class="headerlink" title="图书组件"></a>图书组件</h4><p>components/book下面新建个组件文件。<strong>一个组件对应一本图书</strong></p>
<p>index.js</p>
<pre><code class="lang-js">Component({ 
  properties: {
    book:Object//子属性封装起来
  },

  data: {

  },
  methods: {

  }
})
</code></pre>
<p>index.wxml</p>
<pre><code class="lang-html">&lt;view class=&quot;container&quot;&gt;
  &lt;image src=&quot;{{book.image}}&quot;&gt;&lt;/image&gt;
  &lt;view class=&quot;description&quot;&gt;
    &lt;text class=&quot;title&quot;&gt;{{book.title}}&lt;/text&gt;
    &lt;text class=&quot;author&quot;&gt;{{book.author}}&lt;/text&gt;
    &lt;view class=&quot;foot&quot;&gt;
      &lt;text class=&quot;footer&quot;&gt;{{book.fav_nums}}喜欢&lt;/text&gt;
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<p>pages/book.json引入组件</p>
<pre><code class="lang-json">{
  &quot;usingComponents&quot;: {
    &quot;book-cmp&quot;:&quot;/components/book/index&quot;
  }
}
</code></pre>
<p>服务器返回的是一组图书的数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008211.jpg" style="zoom: 67%;"></p>
<p>如何处理一组图书的数据？</p>
<p>数据的绑定：</p>
<p>pages/book.js</p>
<pre><code class="lang-js">data:{//做数据的初始化
    books:[]
},
 onLoad: function (options) {
   bookModel.getHostList()
   .then(
     this.setData({
          books:res
     })

   )
  },
</code></pre>
<p>pages/book.wxml使用组件</p>
<pre><code class="lang-html">&lt;book-cmp book=&quot;{{books[0]}}/&gt;
</code></pre>
<p>book组件的样式</p>
<p>book/index.wxss</p>
<pre><code class="lang-css">.container{
    margin-top: 30rpx;
    display: flex;
    /* 让description参照container定位 */
    position: relative;
    /* 阴影效果 */
    box-shadow: 2px 2px 3px #e3e3e3;
    flex-direction: column;
    width: 240rpx;
    height: 360rpx;
}

.container image{
  width: 100%;
  height: 100%;
  border-radius: 2px;
}

.description{
  240-10-15
  width: 216rpx;
  /* 白色区域覆盖图片上方，位于容器最底部 */
  /* 生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位 */
  position: absolute;
  bottom: 0;
  background-color: #fff;
  padding: 5rpx 10rpx 8rpx 15rpx;
  font-size: 24rpx;
  display: flex;
  flex-direction: column;
  border-bottom-right-radius: 2px;
  border-bottom-left-radius: 2px;
}

.title{
  margin-top: 10rpx;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

.author{
  font-size: 20rpx;
  color: #999999;
  margin-bottom: 10rpx;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

.foot{
  font-size: 20rpx;
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
}

.footer{
  color: #666666;
}
</code></pre>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>在页面中把一组数据统统用组件展示出来</p>
<p>pages/book.html</p>
<p>wxml如何使用循环<strong>wx:for</strong>（列表渲染），在需要重复的组件外层加block。{{}}内加需要循环遍历的数据</p>
<pre><code class="lang-html">&lt;book-cmp book=&quot;{{books[0]}}&quot;/&gt;

修改
&lt;block wx:for=&quot;{{books}}&quot;&gt;
    &lt;book-cmp  book=&quot;{{item}}&quot;/&gt;
&lt;/block&gt;
</code></pre>
<p>说明：item指一组数据中的其中一个，规定在for内部指定item代表。可以用wx:for-item=“itemName”指定别名</p>
<p>block没有实际的意义</p>
<h4 id="书籍首页布局"><a href="#书籍首页布局" class="headerlink" title="书籍首页布局"></a>书籍首页布局</h4><p>pages/book.wxml</p>
<pre><code class="lang-html">&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;header&quot;&gt;
    &lt;view class=&quot;box&quot;&gt;
      &lt;image src=&quot;/images/icon/search.png&quot;&gt;&lt;/image&gt;
      &lt;text&gt;搜索书籍&lt;/text&gt;
    &lt;/view&gt;  
  &lt;/view&gt;
  &lt;view class=&quot;sub-container&quot;&gt;
    &lt;image class=&quot;head-img&quot; src=&quot;/images/book/quality.png&quot;&gt;&lt;/image&gt;
    &lt;view class=&quot;books-container&quot;&gt;
       &lt;block wx:for=&quot;{{books}}&quot;&gt;
         &lt;book-cmp book=&quot;{{item}}&quot;/&gt;
      &lt;/block&gt; 
    &lt;/view&gt;  
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<p>pages/book.wxss</p>
<pre><code class="lang-css">.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.sub-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: #f5f5f5;
  margin-top: 100rpx;
}

.box {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  border-radius: 50px;
  background-color: #f5f5f5;
  height: 68rpx;
  width: 700rpx;
  color: #999999;
}

.header {
 /* 让header始终保持固定的位置*/
  position: fixed;
  background-color: #ffffff;
  height: 100rpx;
  width: 100%;
  border-top: 1px solid #f5f5f5;
  border-bottom: 1px solid #f5f5f5;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 3px 0 #e3e3e3;
  z-index: 99;
}

.head-img {
  width: 106rpx;
  height: 34rpx;
  margin-top: 40rpx;
}

.box image {
  margin-right: 10px;
  width: 14px;
  height: 14px;
  margin-bottom: -2px;
}


.books-container {
  margin-top: 10rpx;
  display: flex;
  flex-direction: row;
  /* 自动换行 */
  flex-wrap: wrap;
  justify-content: space-between;
  /* 设置宽度让一行只显示两本图书 */
  padding: 0 90rpx;
}

/* 控制每本书（组件）的上下间距 */
.books-container book-cmp{
  margin-bottom: 10rpx;
}
</code></pre>
<h4 id="wx：key的用法与意义"><a href="#wx：key的用法与意义" class="headerlink" title="wx：key的用法与意义"></a>wx：key的用法与意义</h4><p>wx：key为列表中的每个元素指定一个唯一的标识</p>
<p>wx:key———列表元素是object对象类型 。object下的某个属性不重复且数字或字符串，此处是book.id。wx:key=”id” </p>
<p>wx:key———列表元素 是数字或字符串，wx:key=”*this” </p>
<pre><code class="lang-html"> &lt;block wx:key=&quot;&quot; wx:for=&quot;{{books}}&quot;&gt;
         &lt;book-cmp book=&quot;{{item}}&quot;/&gt;
      &lt;/block&gt;
</code></pre>
<h4 id="项目型组件与通用性组件"><a href="#项目型组件与通用性组件" class="headerlink" title="项目型组件与通用性组件"></a>项目型组件与通用性组件</h4><p>实现效果：点击图书页面后页面跳转到图书详情</p>
<p>wx.naviagteTo()跳转页面</p>
<p>pages下新建book-detail。点击图书的时候把book id传到book-detail。</p>
<p>一个页面接收外部传递的参数（组件接收参数通过properties）：向页面传参的话所有参数都包含在onload的options中。</p>
<pre><code class="lang-js">#pages/book-detail.js
onload:function(options){
    const bid = options.bid //接收一个外部传递过来的bid参数
    console.log(bid)
}
</code></pre>
<p>跳转的代码写在book页面中还是组件中？</p>
<p>如果写在页面中：navigateto要包含当前点击图书的id号，当用户点击图书后，图书组件要把id号传到页面中。组件内部把id传到页面：组价自身监听用户tap点击事件，监听到事件后，会产生组件的自定义事件triggerevent，在triggerevent中把自身的id号包含在事件的参数中，同时在页面中监听triggerevent事件从而拿到id</p>
<p>所以把navigateto写在组件内部就不要一个传递过程。</p>
<p>components/index.wxml中监听事件</p>
<pre><code class="lang-html">&lt;view bind:tap=&quot;onTap&quot; class=&quot;container&quot;&gt;
</code></pre>
<p>index.js</p>
<pre><code class="lang-js">method:{
    onTap(event){
    const bid = this.properties.book.id
    wx.navigateTo({
        url:`/pages/book-detail/book-detail?bid=${bid}`
    })
    }
}
</code></pre>
<p>从组件内部直接跳转：</p>
<p>方便，缺陷：写死了跳转，降低了组件的通用性</p>
<p>适用于如果组件仅服务于当前项目（项目组件），通用性组件内部不要写业务逻辑</p>
<h4 id="书籍详情页面三组数据加载"><a href="#书籍详情页面三组数据加载" class="headerlink" title="书籍详情页面三组数据加载"></a>书籍详情页面三组数据加载</h4><p>图书的内容简介，短评，点赞的数量和状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008221.jpg" style="zoom:50%;"></p>
<p>通过获取书籍点赞情况，获取书籍详细信息，获取书籍短评这三个API</p>
<p>model/book.js中编写</p>
<pre><code class="lang-js">  getDetail(bid) {
    return this.request({
        url: `book/${bid}/detail`
    })
}

getLikeStatus(bid) {
    return this.request({
        url: `book/${bid}/favor`
    })
}
  getComments(bid){
      return this.request({
        url: `book/${bid}/short_comment`
      }

      )
  }
</code></pre>
<p>book-detail.js</p>
<pre><code class="lang-js">import{
    BookModel
}from &#39;../../models/book.js&#39;
const bookModel = new BookModel()

data:{//要用的数据初始化定义下
    comments:[],
    detail:null,
    likeStatus:false,
    likeCount:0
}

onload:function(options){
    const bid = options.bid
    const detail = bookModel.getDetail(bid)
    const comments = bookModel.getCommetns(bid)
    const likeStatus = bookModel.getLikeStatus(bid)

    detail.then(res=&gt;{
        this.setData({
            book:res
        })
    })

    comments.then(res=&gt;{
        this.setData({
            comments:res
        })
    })

    likestatus.then(res=&gt;{
        this.setData({
            likeStatus:res.like_status,
            likeCount:res.fav_nums     
        })
    })
}
</code></pre>
<h4 id="三种小程序编译模式"><a href="#三种小程序编译模式" class="headerlink" title="三种小程序编译模式"></a>三种小程序编译模式</h4><p>默认:普通编译（每次重新编译都从首页开始）</p>
<p>​        二维码编译</p>
<p>​        添加编译模式：指定一个启动的页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200822.jpg" style="zoom:50%;"></p>
<h4 id="标签组件难点提示"><a href="#标签组件难点提示" class="headerlink" title="标签组件难点提示"></a>标签组件难点提示</h4><p>pages/book-detail.wxml页面</p>
<pre><code class="lang-html">&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;head&quot;&gt;
        &lt;image src=&quot;{{book.image}}&quot;&gt;&lt;/image&gt;
        &lt;text class=&#39;title&#39;&gt;{{book.title}}&lt;/text&gt;
        &lt;text class=&#39;author&#39;&gt;{{book.author}}&lt;/text&gt;
    &lt;/view&gt;
  &lt;view class=&quot;sub-container&quot;&gt;
        &lt;text class=&quot;headline&quot;&gt;短评&lt;/text&gt;
    &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<p>wxss</p>
<pre><code class="lang-css">/* pages/book-detail/book-detail.wxss */
.container {
  background-color: #f5f5f5;
  width: 100%;
}

.head {
  background-color: #fff;
  padding-top: 40rpx;
  padding-bottom: 40rpx;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.title {
  color: #2f2f2f;
  margin-top: 20rpx;
  font-size: 38rpx;
  font-weight: 600;
}

.author {
  font-size: 28rpx;
  color: #999;
  /* margin-bottom: 30rpx; */
}

.head image {
  width: 200rpx;
  height: 300rpx;
  box-shadow: 2px 2px 3px #e3e3e3;
}

.sub-container {
  width: 690rpx;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 30rpx;
  background-color: #fff;
  padding: 30rpx;
}

.headline {
  font-size: 30rpx;
  font-weight: 600;
  color: #2f2f2f;
  margin-bottom: 20rpx;
}
</code></pre>
<h4 id="标签布局"><a href="#标签布局" class="headerlink" title="标签布局"></a>标签布局</h4><p>components/tag组件</p>
<pre><code class="lang-js">#index.js
properties:{
    text:String
}
</code></pre>
<pre><code class="lang-html">#wxml
&lt;view class=&quot;container&quot;&gt;
    &lt;text&gt;{{text}}&lt;/text&gt;
&lt;view&gt;
</code></pre>
<pre><code class="lang-css">#wxss
.container {
    padding: 4rpx 12rpx;
    background-color: #f5f5f5;
    color: #666666;
    border-radius: 2px;
    display: inline-flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    font-size: 28rpx;
}
</code></pre>
<pre><code class="lang-json">pages/book-detail.json
{
    &quot;usingComponents&quot;:{
        &quot;tag-cmp&quot;:&quot;/components/tag/index&quot;
    }
}
</code></pre>
<p>在book-detail的骨架中使用tag组件用来展示所有的评论数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200823.jpg" style="zoom:50%;"></p>
<pre><code class="lang-wxml">pages/book-detail.wxml
&lt;view&gt;
    ...
    &lt;block wx:for=&quot;{{comments}}&quot; wx:key=&quot;content&quot;&gt;//错
        &lt;tag-cmp text=&quot;{{item.content}}&quot;/&gt;
    &lt;/block&gt;
&lt;view&gt;
</code></pre>
<p>排查：appdata:comments下的comments</p>
<pre><code>&lt;block wx:for=&quot;{{comments.comments}}&quot;&gt;
或者
comments：res.comments
</code></pre><p>标签样式：</p>
<pre><code class="lang-html">&lt;view class=&quot;comment-container&quot;&gt;
    &lt;block wx:for=&quot;{{comments.comments}}&quot; wx:key=&quot;content&quot;&gt;//错
     &lt;tag-cmp&gt;
&lt;/view&gt;
</code></pre>
<p>让每个标签之间有间距</p>
<p>book-detail.wxss</p>
<pre><code class="lang-css">.comment-container{
    display:flex;
    flex-direction:row;
    flex-wrap：wrap//让felx自动换行 
}

.comment-container tag-cmp{
    margin-right:15rpx;水平间距
    margin-bottom:10rpx;上下间距（发现没有效果，让本身的容器采用flex布局）
}
</code></pre>
<h4 id="组件设计思想：slot插槽的使用"><a href="#组件设计思想：slot插槽的使用" class="headerlink" title="组件设计思想：slot插槽的使用"></a>组件设计思想：slot插槽的使用</h4><p>短评后面的number看情况添加。使用小程序slot（插槽）特性</p>
<pre><code class="lang-html">#tag/index.wxml
&lt;view class=&quot;container&quot;&gt;
  &lt;text&gt;{{text}}&lt;/text&gt;
  &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;//name区分不同的插槽
&lt;/view&gt;
</code></pre>
<p>slot视外部传进来内容的有无来进行实际的改变。和属性行为相近，从外部向组件的内部传递标签。</p>
<pre><code class="lang-html">#pages/detail-wxml
......
&lt;block wx:for=&quot;{{comments}}&quot; wx:key=&quot;content&quot;&gt;
        &lt;tag-cmp text=&quot;{{item.content}}&quot;/&gt;
        //&lt;text&gt;{{'+'+item.nums}}&lt;/text&gt;//问题：如何把text当做tag组件的插槽传进去呢？    
&lt;/block&gt;
</code></pre>
<p>修改：tag-cmp不能是单行标签的形式</p>
<pre><code class="lang-html">#pages/detail-wxml
......
&lt;block wx:for=&quot;{{comments}}&quot; wx:key=&quot;content&quot;&gt;
    &lt;tag-cmp text=&quot;{{item.content}}&quot;&gt;
           &lt;text class=&quot;num&quot; slot=&quot;after&quot;&gt;{{'+'+item.nums}}&lt;/text&gt;
    &lt;/tag-cmp&gt;
&lt;/block&gt;
</code></pre>
<p>插槽的样式book-detail.wxss</p>
<pre><code class="lang-css">.num {
  margin-left: 10rpx;
  font-size: 22rpx;
  color: #aaa;
}
</code></pre>
<p>数字没有显示出来：slot默认不启用</p>
<p>在tag/index.js中Componentz中加上</p>
<pre><code>options:{

​    multipleSlots:true

}
</code></pre><h4 id="自定义组件样式探讨"><a href="#自定义组件样式探讨" class="headerlink" title="自定义组件样式探讨"></a>自定义组件样式探讨</h4><p>实现tag组件的着色</p>
<p>如让第一个和第二个tag着色</p>
<h5 id="hack方式"><a href="#hack方式" class="headerlink" title="hack方式"></a>hack方式</h5><p>css选择器定位到标签中的第一个和第二个，强制修改组件内部的背景颜色</p>
<pre><code class="lang-css">#book-detail.wxss
.comment-container tag-cmp:nth-child(1){
    background-color:#fffbdd
}
</code></pre>
<p>选择器选择的tag-cmp是自定义组件，我们之前应用的通常是view.text.image小程序内置的组件。对自定义使用css样式：</p>
<p>技巧：选择tag组件内部的子元素view,设置view的bkcolor.</p>
<pre><code class="lang-css">#book-detail.wxss
.comment-container tag-cmp:nth-child(1) view{
    background-color:#fffbdd
}

.comment-container&gt;tag-cmp:nth-child(2)&gt;view{
    background-color:#fffbdd
}
</code></pre>
<p>可以生效，但写法存放安全隐患。</p>
<p><strong>子元素选择器和后代选择器的区别：</strong></p>
<p>子元素选择&gt;更精准，不会影响到其他元素样式</p>
<p>我们使用子元素选择器</p>
<pre><code class="lang-css">.comment-container&gt;tag-cmp:nth-child(1)&gt;view{
    background-color:#fffbdd
}
.comment-container&gt;tag-cmp:nth-child(2)&gt;view{
    background-color:#fffbdd
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008232.jpg" style="zoom:50%;"></p>
<p>此方法灵活，对组件内部细节理解要求高。称为hack方式、</p>
<h5 id="外部样式的概念"><a href="#外部样式的概念" class="headerlink" title="外部样式的概念"></a>外部样式的概念</h5><p>设计开源组件时，存在默认样式和自定义样式 的需求</p>
<p>开发者应提供不违反组件封装原则的修改默认样式的机制</p>
<p>组件属性 slot没有违反封装原则。（组件允许才能做修改，组件属性对js相关数据的传递 slot是html,wxml）。共性：参数传递</p>
<p>上例是强行修改组件的css样式。</p>
<p>遵守参数传递的原则修改CSS样式</p>
<p><strong>样式css的传递机制：外部样式 externalClass</strong>,不违反组件封装原则</p>
<h5 id="外部样式的问题"><a href="#外部样式的问题" class="headerlink" title="外部样式的问题"></a>外部样式的问题</h5><p>tag/index.js中定义一个参数接收组件外部传递进来的样式</p>
<pre><code class="lang-js">externalClasses:[&#39;tag-class&#39;],//允许定义多个外部样式类
</code></pre>
<p>tag/index.wxml</p>
<p>外部样式覆盖普通样式（小程序中覆盖不一定成功）</p>
<pre><code class="lang-html">&lt;view class=&quot;container tag-class&quot;&gt;//tag-class可以覆盖修改container
......
&lt;/view&gt;
</code></pre>
<p><strong>外部样式传递到组件内部中</strong></p>
<p>pages/book-detail.wxss</p>
<pre><code class="lang-css">ex-tag{
    background-color:#fffbdd;
}
</code></pre>
<p>detail.wxml</p>
<pre><code class="lang-html">&lt;tag-cmp tag-class=&quot;ex-tag&quot;&gt;
</code></pre>
<p>没效果，因为小程序没有覆盖<code>container tag-class</code>,先后顺序小程序不确定</p>
<h5 id="外部样式如何强制覆盖普通样式"><a href="#外部样式如何强制覆盖普通样式" class="headerlink" title="外部样式如何强制覆盖普通样式"></a>外部样式如何强制覆盖普通样式</h5><p>确定先后顺序。</p>
<pre><code class="lang-css">#detail
.ex-tag{
    background-color:#fffbdd !important;
}
</code></pre>
<h5 id="外部样式类的使用技巧"><a href="#外部样式类的使用技巧" class="headerlink" title="外部样式类的使用技巧"></a>外部样式类的使用技巧</h5><pre><code class="lang-css">#detail
.ex-tag1{
    background-color:#fffbdd !important;
}

.ex-tag2{
    background-color:#eefbff !important;
}
</code></pre>
<pre><code class="lang-html">#detail.wxml index可以用来指代序号

 &lt;tag-cmp tag-class=&quot;{{index==0?'ex-tag1':''||index==1?'ex-tag2':''}}&quot; text=&quot;{{item.content}}&quot;&gt;
            &lt;text class=&quot;num&quot; slot=&quot;after&quot;&gt;{{'+'+item.nums}}&lt;/text&gt;
 &lt;/tag-cmp&gt;
</code></pre>
<p>方式可行，但不推荐，进行优化</p>
<h3 id="小程序wxs的应用"><a href="#小程序wxs的应用" class="headerlink" title="小程序wxs的应用"></a>小程序wxs的应用</h3><p>完成内容简介</p>
<pre><code class="lang-html">#pages/book-detail.wxml
......
&lt;view class=&quot;sub-container&quot;&gt;
    &lt;text class=&quot;headline&quot;&gt;短评&lt;/text&gt;  
     ....
&lt;/view&gt; 

&lt;view class=&quot;sub-container&quot;&gt;
    &lt;text class=&quot;headline&quot;&gt;内筒简介&lt;/text&gt;  
    &lt;text class=&quot;content&quot;&gt;{{book.summary}}&lt;/text&gt;
&lt;/view&gt;
</code></pre>
<p>会发现内容中有多个/n，/n其实都是换行的效果。且需要首行缩进2字符</p>
<h4 id="分析换行符-不解析换行的原因"><a href="#分析换行符-不解析换行的原因" class="headerlink" title="分析换行符 不解析换行的原因"></a>分析换行符 不解析换行的原因</h4><p><code>&lt;text&gt;</code>组件会自动解析换行\n。为什么从服务器加载的内容简介不会出现换行效果呢？</p>
<p>在network中查看字符串。点击response查看原始数据。</p>
<p>会发现<code>\n</code>在源码中是<code>\\n</code>,所以输出的是<code>\n</code>。</p>
<p>问题解决：通过正则表达式</p>
<p>我们可以在book-detail.js中对summary先做一次处理在绑定到wxml</p>
<h4 id="wxs的概念与应用"><a href="#wxs的概念与应用" class="headerlink" title="wxs的概念与应用"></a>wxs的概念与应用</h4><p>思路：能否编写一个函数，在wxml的{{}}内部调用这个函数并把summary当做参数传递进去，类似<code>{{func(book.summary)}}</code></p>
<p>老版本中，wxml编写js或者调用js是不可能的，新版中提供<strong>wxs</strong>,让wxml具备写或调用js的能力。</p>
<p>wxs可以在wxml中写，也可以新建文件中写</p>
<p>我们在util中新建一个文件，文件名filter.wxs。</p>
<pre><code class="lang-js">var format = function(text){

  return &#39;123123&#39;//测试
}
//不能用const,因為const是ES6的語法.wxs语法更接近ES5
//wxs!=javascript,wxs是小程序的一種腳本語言，語法不能完全通用
module.exports = {
  format:format
}
</code></pre>
<pre><code class="lang-html">#book-detail/wxml调用format
&lt;wxs src=&quot;../../util/filter.wxs&quot; module=&quot;util&quot; /&gt;引用
... ...
    &lt;view class=&quot;sub-container&quot;&gt;
    &lt;text class=&quot;headline&quot;&gt;内筒简介&lt;/text&gt;  
    &lt;text class=&quot;content&quot;&gt;{{util.format(book.summary)}}&lt;/text&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008233.jpg" style="zoom:50%;"></p>
<p>使用wxs中的正则表达式</p>
<pre><code class="lang-js">var format = function(text){
  var reg = getRegExp(&#39;\\\\n&#39;,&#39;g&#39;)//返回雙//
  return text.replace(reg,&#39;\n&#39;)
}

module.exports = {
  format:format
}
</code></pre>
<p>会报错。因为setData()中book.summary初始化了一次，初始化时book为空，后更新了一次。一共执行的两次。</p>
<p>改正：</p>
<pre><code class="lang-js">var format = function(text){
  if(!text){
    return
  }
  var reg = getRegExp(&#39;\\\\n&#39;,&#39;g&#39;)//返回雙//
  return text.replace(reg,&#39;\n&#39;)
}

module.exports = {
  format:format
}
</code></pre>
<p><strong>实现每段段落首行缩进两个字符</strong>：</p>
<p>text-indent属性</p>
<pre><code class="lang-css">#book-detail.wxss
.content{
    text-indent:58rpx;
    font-weight:500
}
</code></pre>
<pre><code class="lang-html"> &lt;text class=&quot;content&quot;&gt;{{util.format(book.summary)}}&lt;/text&gt;
</code></pre>
<p>只对整个text文本的开头有效<code>&lt;text&gt;</code>标签相当于<code>&lt;p&gt;</code></p>
<p>所以不能用css的方式解决</p>
<pre><code>var format = function(text){
  if(!text){
    return
  }
  var reg = getRegExp(&#39;\\\\n&#39;,&#39;g&#39;)//返回雙//
  return text.replace(reg,&#39;\n&amp;nbsp;&amp;nbsp;&#39;)
}
......
</code></pre><p>没效果，要让<code>text</code>解析nbsp,需要开启decode属性</p>
<pre><code class="lang-html">&lt;text class=&quot;content&quot; decode=&quot;{{true}}&quot;&gt;{{util.format(book.summary)}}&lt;/text&gt;
</code></pre>
<h4 id="在小程序中编写limit过滤器"><a href="#在小程序中编写limit过滤器" class="headerlink" title="在小程序中编写limit过滤器"></a>在小程序中编写limit过滤器</h4><p>限制短评的数量展现：</p>
<p>编写过滤器在bolck标签的<code>{{}}</code>里面做截取操作</p>
<pre><code class="lang-js">#filter.wxs
...
var limit = function(array,length){
    return array.slice(0,length)//截取
}

module.exports = {
    format:format,
    limit:limit
}
</code></pre>
<pre><code class="lang-html">&lt;block wx:for=&quot;{{util.limit(comments,10)}}&quot; wx:key=&quot;content&quot;&gt;
</code></pre>
<p>过滤器可以复用</p>
<h4 id="书本信息"><a href="#书本信息" class="headerlink" title="书本信息"></a>书本信息</h4><pre><code class="lang-html">#book-detail.wxml
......
&lt;view class=&quot;sub-container&quot;&gt;
        &lt;text class=&quot;headline&quot;&gt;书本信息&lt;/text&gt;
        &lt;view class=&quot;detail-container&quot;&gt;
            &lt;view class=&quot;vertical description&quot;&gt;
                &lt;text&gt;出版社&lt;/text&gt;
                &lt;text&gt;出版年&lt;/text&gt;
                &lt;text&gt;页数&lt;/text&gt;
                &lt;text&gt;定价&lt;/text&gt;
                &lt;text&gt;装帧&lt;/text&gt;
            &lt;/view&gt;
            &lt;view class=&quot;vertical&quot;&gt;
                &lt;text&gt;{{book.publisher}}&lt;/text&gt;
                &lt;text&gt;{{book.pubdate}}&lt;/text&gt;
                &lt;text&gt;{{book.pages}}&lt;/text&gt;
                &lt;text&gt;{{book.price}}&lt;/text&gt;
                &lt;text&gt;{{book.binding}}&lt;/text&gt;
            &lt;/view&gt;
        &lt;/view&gt;
    &lt;/view
</code></pre>
<pre><code class="lang-css">#book-detail.wxss
.detail-container {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  margin-bottom: 100rpx;
  font-size: 28rpx;
  color: #666;
}

.vertical {
  display: flex;
  flex-direction: column;
}

.description {
  color: #999;
  margin-right: 30rpx;
}
</code></pre>
<h4 id="短评功能"><a href="#短评功能" class="headerlink" title="短评功能"></a>短评功能</h4><p>功能描述：</p>
<p>固定在页面的最底部，不随页面滑动。</p>
<p>点击输入短评时，弹出新的覆盖层，上部灰色遮罩。下部描述性文本，附加热门标签。新添加的标签排在第一个位置显示。点击了哪个标签，标签的数字+1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008234.jpg" style="zoom: 50%;"></p>
<h5 id="短评实现一"><a href="#短评实现一" class="headerlink" title="短评实现一"></a>短评实现一</h5><pre><code class="lang-html">#book-detail.wxml
&lt;view class=&quot;post-container&quot; &gt;
    &lt;view  class=&quot;post-fake&quot;&gt;//不是真正输入短评，而是点击后弹出真正输入短评的页面
        &lt;text&gt;输入短评&lt;/text&gt;
    &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-css">#book-detail.wxss
.post-container {
    height: 100rpx;
    box-shadow: 1px -1px 1px #e3e3e3;
    position: fixed;
    width: 690rpx;
    background-color: #fff;
    bottom: 0;
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 0 30rpx;
    justify-content: space-between;
}

.post-fake {
    display: flex;
    flex-direction: row;
    align-items: center;
    height: 60rpx;
    width: 460rpx;
    border: 1px solid #999;
    border-radius: 15px;
    font-size: 22rpx;
    padding-left: 20rpx;
}
</code></pre>
<p>输入短评旁点赞按钮，引入like组件(like组件没有实现具体的业务) </p>
<pre><code class="lang-json">#book-detail.json
{
  &quot;usingComponents&quot;: {
    &quot;tag-cmp&quot;:&quot;/components/tag/index&quot;,
    &quot;like-cmp&quot;:&quot;/components/like/index&quot;
  }
}
</code></pre>
<pre><code class="lang-html">#book-detail.wxml
&lt;view class=&quot;post-container&quot; &gt;
    &lt;view  class=&quot;post-fake&quot;&gt;//不是真正输入短评，而是点击后弹出真正输入短评的页面
        &lt;text&gt;输入短评&lt;/text&gt;
    &lt;/view&gt;
    &lt;view class=&quot;like-container&quot;&gt;
        &lt;like-cmp bind:like=&quot;onLike&quot; class=&quot;like&quot; like=&quot;{{likeStatus}}&quot; count=&quot;{{likeCount}}&quot; /&gt;
    &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-css">#book-detail.wxss
.like {
    margin-right: 30rpx;
    margin-top: 10rpx;
}

.like-container {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
}
</code></pre>
<p>完成了like前端演示的效果，还需要编写onLike的业务逻辑</p>
<pre><code class="lang-js">#book-detail.js
...
import {
  LikeModel
} from &#39;../../models/like.js&#39;

const likeModel = new LikeModel()

onLike(event) {
    const like_or_cancel = event.detail.behavior
    likeModel.like(like_or_cancel, this.data.book.id, 400)
  },
</code></pre>
<h5 id="短评实现二"><a href="#短评实现二" class="headerlink" title="短评实现二"></a>短评实现二</h5><p>点击短评，出现短评真正的输入框。点击取消，恢复到初始状态。</p>
<p>第一步：在输入短评的按钮上绑定一个事件。</p>
<pre><code class="lang-js">&lt;view class=&quot;post-container&quot; &gt;
    &lt;view bind:tap=&quot;onFakePost&quot; class=&quot;post-fake&quot;&gt;
        &lt;text&gt;输入短评&lt;/text&gt;
    &lt;/view&gt;
    ......
&lt;/view&gt;
</code></pre>
<pre><code class="lang-js">book-detail.js
data:{
    ...
    posting:false
}
onFakePost(event){
    this.setData({
        posting:true
    })
}
</code></pre>
<p>编写真正的评论输入框：</p>
<pre><code class="lang-html">&lt;view class=&quot;posting-container&quot;&gt;
    &lt;view class=&quot;post-header&quot;&gt;
        &lt;text &gt;仅可点击标签+1&lt;/text&gt;
        &lt;text  class=&quot;cancel&quot;&gt;取消&lt;/text&gt;
    &lt;/view&gt;
    &lt;view class=&quot;comment-container&quot;&gt;//取前三个热评
    &lt;/view&gt;
    &lt;input class=&quot;post&quot; placeholder=&#39;短评最多12个字&#39;&gt;&lt;/input&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-css">.posting-container {
    bottom: 0;
    position: fixed;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #fff;
    width: 100%;
    z-index: 999;
}

.post-header {
    width: 100%;
    border-bottom: 1px solid #f5f5f5;
    border-top: 1px solid #f5f5f5;
    height: 100rpx;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
}

.cancel {
    color: #666;
}

.post-header text {
    padding: 25rpx;
}

.post-header&gt;text:first-child {
    font-size: 28rpx;
    color: #bbb;
}

.posting-container .comment-container {//因为之前有同名
    width: 690rpx;
    padding: 40rpx 30rpx 0 30rpx;
}
.post {
    width: 690rpx;
    margin: 30rpx auto;
    height: 56rpx;
    background-color: #f5f5f5;
    border-radius: 15px;
    padding-left: 25rpx;
}

.shadow {
    color: #999;
}
</code></pre>
<p>效果：真实的面板把假的覆盖了。两者之间应有一个显示和隐藏的切换。posting作为切换变量</p>
<pre><code class="lang-html">&lt;view class=&quot;post-container&quot; hidden=&quot;{{posting}}&quot;&gt;
    &lt;view bind:tap=&quot;onFakePost&quot; class=&quot;post-fake&quot;&gt;
        &lt;text&gt;输入短评&lt;/text&gt;
    &lt;/view&gt;
    &lt;view class=&quot;like-container&quot;&gt;
        &lt;v-like bind:like=&quot;onLike&quot; class=&quot;like&quot; like=&quot;{{likeStatus}}&quot; count=&quot;{{likeCount}}&quot; /&gt;
    &lt;/view&gt;
&lt;/view&gt;

&lt;view class=&quot;posting-container&quot; wx:if=&quot;{{posting}}&quot;&gt;
    &lt;view class=&quot;post-header&quot;&gt;
        &lt;text wx:if=&quot;{{comments==true}}&quot;&gt;仅可点击标签+1&lt;/text&gt;
        &lt;text wx:else&gt;暂无短评&lt;/text&gt;
        &lt;text bind:tap=&quot;onCancel&quot; class=&quot;cancel&quot;&gt;取消&lt;/text&gt;
    &lt;/view&gt;
    &lt;view class=&quot;comment-container&quot;&gt;//显示三条热评
        &lt;block wx:for=&quot;{{util.limit(comments, 3)}}&quot; wx:key=&quot;content&quot;&gt;
            &lt;tag-cmp bind:tapping=&quot;onPost&quot; tag-class=&quot;{{tool.highlight(index)}}&quot; text=&quot;{{item.content}}&quot;&gt;
                &lt;text class=&quot;num&quot; slot=&quot;after&quot;&gt;{{'+'+item.nums}}&lt;/text&gt;
            &lt;/tag-cmp&gt;
        &lt;/block&gt;
    &lt;/view&gt;
    &lt;input bindconfirm=&quot;onPost&quot; class=&quot;post&quot; placeholder=&#39;短评最多12个字&#39;&gt;&lt;/input&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-js">js
...
onCancel(event) {
    this.setData({
      posting: false
    })
  },
</code></pre>
<h5 id="在wxml中编写wxs代码"><a href="#在wxml中编写wxs代码" class="headerlink" title="在wxml中编写wxs代码"></a>在wxml中编写wxs代码</h5><pre><code class="lang-html">detail-wxml
...
&lt;tag-cmp bind:tapping=&quot;onPost&quot; tag-class=&quot;{{tool.highlight(index)}}&quot; text=&quot;{{item.content}}&quot;&gt;
...
&lt;wxs module=&quot;tool&quot;&gt;
    var highlight = function(index){
        if(index==0){
            return &#39;ex-tag1&#39;
        }
        if(index==1){
            return &#39;ex-tag2&#39;
        }
        return &#39;&#39;
    }

    module.exports = {
        highlight:highlight
    }
&lt;/wxs&gt;
</code></pre>
<h5 id="mask组件"><a href="#mask组件" class="headerlink" title="mask组件"></a>mask组件</h5><p>黑色透明背景（遮罩效果） 封装为一个组件</p>
<p>components/mask</p>
<p>js中不用谢任何代码</p>
<pre><code class="lang-html">#wxml
&lt;view class=&quot;container&quot;&gt;&lt;/view&gt;
</code></pre>
<pre><code class="lang-css">#wxss
.container{
    background-color:#000000;
    position:fixed;
    top:0;
    opacity:0.6;//透明度
    width:100%;
    height:100%;
    z-index:99;//
}
</code></pre>
<pre><code class="lang-json">#book-detail.json
&quot;mask-cmp&quot;:&quot;/components/mask/index&quot;
</code></pre>
<pre><code class="lang-html">#pages/detail.wxml
&lt;mask-cmp wx:if=&quot;{{posting}}&quot;/&gt;
</code></pre>
<h5 id="提交短评数据"><a href="#提交短评数据" class="headerlink" title="提交短评数据"></a>提交短评数据</h5><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/2008241.jpg" style="zoom:33%;"></p>
<p>book-id可以在book-detail.js中拿到</p>
<p>content:如何确认？如果是用户自身输入，content容易拿到。点击标签时标签里的content如何拿到？</p>
<p>book-detail页面不知道标签内部的内容，标签本身知道自己内部的内容，<strong>标签组件的内部做一个事件</strong>，当用户点击标签时标签在事件的参数中携带文本的内容。页面通过监听点击事件接收到标签内部content内容，流程同like</p>
<pre><code class="lang-html">#tag/index.wxml
//小程序内置的tap事件
&lt;view bind:tap=&quot;onTap&quot; class=&quot;container tag-class&quot;&gt;
  &lt;text&gt;{{text}}&lt;/text&gt;
  &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-js">#tag/index.js
methods: {
    onTap(event){
        //自定义事件
        this.triggerEvent(&#39;tapping&#39;,{//触发一个自定义事件，把文本text传递出去
            text:this.properties.text
        })
    }
  }
</code></pre>
<p>页面监听tap的自定义事件tapping,监听函数onPost。输入方式两种：点击标签或文本输入</p>
<pre><code class="lang-html">#pages/book-detail.wxml
&lt;view class=&quot;posting-container&quot; wx:if=&quot;{{posting}}&quot;&gt;
    ......
    &lt;view class=&quot;comment-container&quot;&gt;
      &lt;block wx:for=&quot;{{util.limit(comments,3)}}&quot; wx:key=&quot;content&quot;&gt;
          //监听组件的tapping,处理函数onpost
        &lt;tag-cmp bind:tapping=&quot;onPost&quot; tag-class=&quot;{{tool.highlight(index)}}&quot; text=&quot;{{item.content}}&quot;&gt;&lt;/tag-cmp&gt;
        &lt;text class=&quot;num&quot; slot=&quot;after&quot;&gt;{{'+'+item.nums}}&lt;/text&gt;
      &lt;/block&gt;
    &lt;/view&gt;
    &lt;input class=&quot;post&quot; placeholder=&#39;短评最多12个字&#39;&gt;&lt;/input&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="lang-js">#book-detail.js
onPost(event){//event有可能是tapping或input发送的事件
   const comment = event.detail.text

   //内容长度jiance
   if(comment.length&gt;12){通过长度检测
       wx.showToast({
           title:&#39;短评最多12个字&#39;，
           icon:&#39;none&#39;
       })
       return
   }

   bookModel.postComment(this.data.book.id,comment) //返回一个promise
   .then(res=&gt;{
      wx.showToast({//客户端提示处理
          title:&quot;+1&quot;,
          icon:&quot;none&quot;
      }) 
       把新增加的短评添加到comments数组中去，然后this.setdata更新整个comments数组
       this.data.comments.unshift({//把新的元素添加到数组首尾
           content：comment,
           nums:1//还有一个数量
       }) 

      this.setData({
          comments:this.data.comments
      })

},
</code></pre>
<pre><code class="lang-js">model/book.js 向服务器提交数据的API
postComment(bid,comment){
    return this.request({
        url:&#39;book/add/short_comment&#39;,
        method:&#39;POST&#39;,
        data:{
            book_id:bid,
            content:comment
        }
    })
}
</code></pre>
<p>用户点击标签后把遮罩层关闭掉：</p>
<pre><code class="lang-js">this.setData({
        comments:this.data.comments,
        posting:false
      })
</code></pre>
<p>至此点击标签发表评论的功能实现</p>
<h5 id="支持input输入短评"><a href="#支持input输入短评" class="headerlink" title="支持input输入短评"></a>支持input输入短评</h5><p>使用input特有的事件bindconfirm,监听的是当用户输入完成点击确认按钮后，触发自定义函数</p>
<pre><code class="lang-html">&lt;input bindconfirm=&quot;onPost&quot; class=&quot;post&quot; placeholder=&#39;短评最多12个字&#39;&gt;&lt;/input&gt;
</code></pre>
<pre><code class="lang-js">#book-detail.js
 onPost(event){
    const comment = event.detail.text || event.detail.value
    //const commentInput = event.detail.value(因为comment和commentInput是一个有值时一个无值的)
    if(!comment){
        return
    }

    if(comment.length&gt;12){
      wx.showToast({
        title: &#39;短評最多12個字&#39;,
        icon:&quot;none&quot;
      })
      return
    }
</code></pre>
<h5 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h5><p>图书没有短评时，给出暂无短评的提示</p>
<pre><code class="lang-html">book-deatil.wxml
&lt;view class=&quot;sub-container&quot;&gt;
    &lt;text class=&quot;headline&quot;&gt;短评&lt;/text&gt;  
    &lt;text class=&quot;shadow&quot; wx:if=&quot;{{comments==false}}&quot;&gt;还没有短评&lt;/text&gt;
     &lt;view class=&quot;comment-container&quot;&gt;
        ......
&lt;view class=&quot;posting-container&quot; wx:if=&quot;{{posting}}&quot;&gt;
    &lt;view class=&quot;post-header&quot;&gt;
        &lt;text wx:if=&quot;{{comments==true}}&quot;&gt;仅可点击标签+1&lt;/text&gt;
        &lt;text wx:else&gt;暂无短评&lt;/text&gt;
</code></pre>
<h3 id="搜索与高阶组件"><a href="#搜索与高阶组件" class="headerlink" title="搜索与高阶组件"></a>搜索与高阶组件</h3><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200825.jpg" style="zoom:50%;"></p>
<h4 id="并行请求与串行请求"><a href="#并行请求与串行请求" class="headerlink" title="并行请求与串行请求"></a>并行请求与串行请求</h4><p>点击书籍详情，需要向服务器发送三个请求。加载数据需要时间，取决于当前用户的网路状况，取决于服务器的性能。<strong>加载数据时显示loading的提示，加载完数据后提示结束</strong>。小程序中内置了两种方式，页面中间小圈圈，页面导航栏上小圈圈。</p>
<p>book-detail.js</p>
<p>执行onload函数时显示loading，所有数据加载完成后loading提示取消。</p>
<p>什么时候取消Loading？</p>
<p>数据加载完成。如何确定三个并行的异步请求完成的时机？</p>
<pre><code class="lang-js">onLoad: function (options) {
    wx.showLoading()
    const bid = options.bid
    ......
    detail.then(res=&gt;{
      console.log(res)
      this.setData({
        book:res
      })
    })

    comments.then(res=&gt;{
      console.log(res)
      this.setData({
        comments:res.comments
      })
    })

    likeStatus.then(res=&gt;{
      console.log(res)
      this.setData({
          likeStatus:res.like_status,
          likeCount:res.fav_nums     
      })
  })
  },
</code></pre>
<h4 id="Promise-all与Promise-race"><a href="#Promise-all与Promise-race" class="headerlink" title="Promise.all与Promise.race"></a>Promise.all与Promise.race</h4><p>Promise.all()把多个promise实例合并成一个，返回一个新的实例，可以看做合体。只有当三个子promise都完成后才会触发新promise的then</p>
<p>.all是等待所有子promise完成后才触发回调函数，.race有一个完成后就马上执行回调函数，res携带竞争成功的回调结果。</p>
<pre><code class="lang-js">onLoad: function (options) {
    wx.showLoading()
    const bid = options.bid
    const detail = bookModel.getDetail(bid)
    const comments = bookModel.getComments(bid)
    const likeStatus = bookModel.getLikeStatus(bid)

    Promise.all([detail,comments,likeStatus])
    .then(res=&gt;{ 接收新的返回结果
        this.setData({
            book:res[0],
            comments:res[1].comments,
            likeStatus:res[2].like_status,
            likeCount:res[2].fav_nums
        })
        wx.hideLoading()
    })

  },
</code></pre>
<h4 id="高阶组件示例1：搜索组件"><a href="#高阶组件示例1：搜索组件" class="headerlink" title="高阶组件示例1：搜索组件"></a>高阶组件示例1：搜索组件</h4><p>包含了大量的业务逻辑编写。components下新建search组件</p>
<pre><code class="lang-css">wxss
.container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

.header {
    background-color: #ffffff;
    position: fixed;
    height: 100rpx;
    border-top: 1px solid #f5f5f5;
    border-bottom: 1px solid #f5f5f5;
    display: flex;
    flex-direction: row;
    width: 750rpx;
    align-items: center;
    z-index: 99;
}

.search-container {
    display: inline-flex;
    flex-direction: row;
    align-items: center;
    background-color: #f5f5f5;
    border-radius: 50px;
    margin-left: 20rpx;
}

.in-bar {
    color: #999;
}

.bar {
    border-top-right-radius: 15px;
    border-bottom-right-radius: 15px;
    display: inline-block;
    height: 68rpx;
    width: 1000rpx;
    font-size: 28rpx;
}

.icon {
    width: 28rpx;
    height: 28rpx;
    margin-left: 24rpx;
    margin-right: 16rpx;
}

.cancel {
    line-height: 68rpx;
    width: 120rpx;
    text-align: center;
    display: inline-block;
    border: none;
}

.cancel-img {
    width: 28rpx;
    height: 28rpx;
    margin-right: 20rpx;
}

.history {
    width: 690rpx;
    margin: 40rpx 0 20rpx 0;
    display: flex;
    font-size: 28rpx;
    margin-top: 160rpx;
    flex-direction: column;
}

.hot-search {
    margin-top: 70rpx;
}

.title {
    line-height: 30rpx;
    display: flex;
    flex-direction: row;
    align-items: center;
}

.books-container v-book {
    margin-bottom: 25rpx;
}

.books-container {
    width: 570rpx;
    margin-top: 100rpx;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    padding: 0 90rpx 0 90rpx;
    justify-content: space-between;
}

.loading {
    margin: 50rpx 0 50rpx 0;
}

.loading-center {
    position: absolute;
    top: 50%;
    left: 50%;
}

.empty-tip {
    display: inline-block;
    width: 100%;
    text-align: center;
    position: absolute;
    top: 50%;
}

.chunk {
    height: 30rpx;
    width: 10rpx;
    background-color: #000;
    display: inline-block;
    margin-right: 20rpx;
}

.tags {
    /* padding-left:15px; */
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    margin-top: 24rpx;
    padding-left: 30rpx;
    width: 630rpx;
}

.tags v-tag {
    margin-right: 20rpx;
    margin-bottom: 20rpx;
}

.bar {
    border-top-right-radius: 15px;
    border-bottom-right-radius: 15px;
    display: inline-block;
    height: 68rpx;
    width: 500rpx;
    font-size: 28rpx;
}
</code></pre>
<p>search.png和cancel.png图片放入文件夹images</p>
<pre><code class="lang-html">&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;header&quot;&gt;
    &lt;view class=&quot;search-container&quot;&gt;
      &lt;image class=&quot;icon&quot; src=&quot;images/search.png&quot;/&gt;
      &lt;input placeholder-class=&quot;in-bar&quot; placeholder=&quot;书籍名&quot; class=&quot;bar&quot; auto-auto-focus=&quot;true&quot;/&gt;//自动聚焦的功能
      &lt;image class=&quot;cancel-img&quot; src=&quot;images/..&quot;/&gt;
    &lt;/view&gt; 
    &lt;view class=&quot;cancel&quot;&gt;取消&lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<p>页面使用</p>
<pre><code class="lang-json">book.json
{
  &quot;usingComponents&quot;: {
    &quot;book-cmp&quot;:&quot;/components/book/index&quot;,
    &quot;search-cmp&quot;:&quot;/components/search/index&quot;
  }
}
</code></pre>
<p>serarch组件和container同一时间只显示一个，searching变量控制。点击搜索书籍时切换</p>
<pre><code class="lang-html">book.wxml
&lt;view wx:if=&quot;{{!searching}}&quot; class=&quot;container&quot;&gt;//显示控制
    &lt;view class=&quot;header&quot;&gt;
    &lt;view bind:tap=&quot;onSearch&quot; class=&quot;box&quot;&gt;//自定义监听函数
      &lt;image src=&quot;/images/icon/search.png&quot;&gt;&lt;/image&gt;
      &lt;text&gt;搜索书籍&lt;/text&gt;
    &lt;/view&gt;  
  &lt;/view&gt;
  &lt;view class=&quot;sub-container&quot;&gt;
    &lt;image class=&quot;head-img&quot; src=&quot;/images/book/quality.png&quot;&gt;&lt;/image&gt;
    &lt;view class=&quot;books-container&quot;&gt;
       &lt;block wx:key=&quot;id&quot; wx:for=&quot;{{books}}&quot;&gt;
         &lt;book-cmp book=&quot;{{item}}&quot;/&gt;
      &lt;/block&gt; 
    &lt;/view&gt;  
  &lt;/view&gt;
&lt;/view&gt;
&lt;search-cmp wx:if=&quot;{{searching}}&quot;/&gt;//显示控制
</code></pre>
<pre><code class="lang-js">pages/book.js
 data: {
    books:[],
    searching:false
  },

  onSearching(event){
      this.setData({
          searching:true
      })
  }
</code></pre>
<p>取消</p>
<pre><code class="lang-html">search/index.wxml
 &lt;view bind:tap=&quot;onCancel&quot; class=&quot;cancel&quot;&gt;取消&lt;/view&gt;
</code></pre>
<pre><code class="lang-js">search/index.js
methods:{
    onCancel(event){//组件不能操作页面中的变量searching
        this.triggerEvent(&#39;cancel&#39;,{},{})
    }
}
</code></pre>
<p>onCancel中自己触发一个triggerevent，事件抛到外部让页面监听onCancel，由页面处理组件的显示和隐藏</p>
<pre><code class="lang-html">book.wxml
&lt;search-cmp bind:cancel=&quot;onCancel&quot; wx:if=&quot;{{searching}}&quot;/&gt;
</code></pre>
<pre><code class="lang-js">book.js
onCancel(event){
    this.setData({
        searching:false
    })
}
</code></pre>
<h4 id="自定义组件的models目录探讨"><a href="#自定义组件的models目录探讨" class="headerlink" title="自定义组件的models目录探讨"></a>自定义组件的models目录探讨</h4><p>历史搜索和热门搜索用tag组件。需要填充标签内容</p>
<pre><code class="lang-html">&lt;!--components/search/index.wxml--&gt;
&lt;view class=&quot;container&quot;&gt;
  &lt;view class=&quot;header&quot;&gt;
       ......
  &lt;/view&gt;

   &lt;view&gt;
    &lt;view class=&quot;history&quot;&gt;
      &lt;view class=&quot;title&quot;&gt;
        &lt;view class=&quot;chunk&quot;&gt;&lt;/view&gt;
        &lt;text&gt;历史搜索&lt;/text&gt;
      &lt;/view&gt;
    &lt;/view&gt;

    &lt;view class=&quot;history hot-search&quot;&gt;
      &lt;view class=&quot;title&quot;&gt; 
        &lt;view class=&quot;chunk&quot;&gt;&lt;/view&gt;
        &lt;text&gt;热门搜索&lt;/text&gt;
      &lt;/view&gt;
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<p>历史搜索（个人）和热门搜索标签（服务器提供）</p>
<p><strong>历史搜索实现方法</strong>：搜索内容存放在storage，展示时从缓存中读取所有历史搜索标签。逻辑写在model目录下的keyword.js中。model可以在search组件目录下，此时js业务只能被search组件应用，在components目录下，被所有的组件复用，在根目录下，被整个项目使用。</p>
<p>建议：若只是一个项目，放在根目录下。把components发布出去提供给别的开发者使用，存放在components文件下。</p>
<p>此处放在/models/keyword.js下。</p>
<h4 id="数据结构队列的应用"><a href="#数据结构队列的应用" class="headerlink" title="数据结构队列的应用"></a>数据结构队列的应用</h4><pre><code class="lang-js">/models/keyword.js
class KeywordModel{

  key = &#39;q&#39;
  maxLength = 10
  // 获取历史搜索的关键字
  getHistory(){

    const words = wx.getStorageSync(this.key)
    if(!words){
      return []
    }
    return words
  }

  //获取热门搜索的关键字
  getHot(){

  }

  //关键字(数组)写入到缓存中
  addToHistory(keyword){
    //判断新添加的key是否已存在数组中
    let words = this.getHistory()//拿到历史数组
    const has = words.includes(keyword)
    if(!has){
      //数组末尾删除，keyword添加到数组第一位
      const length = words.length
      if (length&gt;= this.maxLength){
        words.pop()
      }
      words.unshift(keyword)
      wx.setStorageSync(this.key, words)
    }
  }
}

export{KeywordModel}
</code></pre>
<pre><code class="lang-html">search/index.wxml
&lt;input bind:confirm=&quot;onConfirm&quot; placeholder-class=&quot;in-bar&quot; placeholder=&quot;书籍名&quot;
</code></pre>
<pre><code class="lang-js">search/index.js
import {KeywordModel} from &#39;../../models/keyword.js&#39;
const keywordModel = new KeywordModel()
......

methods: {
    onCancel(event){
      this.triggerEvent(&#39;cancel&#39;,{},{})
    },
    onConfirm(event){
      const word = event.detail.value
      keywordModel.addToHistory(word)
    }
  }
</code></pre>
<h4 id="实现历史搜索"><a href="#实现历史搜索" class="headerlink" title="实现历史搜索"></a>实现历史搜索</h4><p>运行程序，缓存中可以读到数据。那么如何展示这些历史搜索数据？js中调用models中的相关方法获取历史搜索的所有关键字数据，然后做steData数据绑定</p>
<pre><code class="lang-js">search/index.js
data: {
    historyWords:[]
  },

  //初始化组件时小程序默认调用的初始化函数
  attached(event){
    const historyWords = keywordModel.getHistory()
    this.setData({
      historyWords:historyWords
    })
  },
</code></pre>
<p>做完数据绑定后考虑把historyword呈现在search组件页面上，通过tag的形式呈现。所以search组件要引用tag组件。</p>
<pre><code class="lang-json">search/index.json
{
  &quot;component&quot;: true,
  &quot;usingComponents&quot;: {
    &quot;tag-cmp&quot;:&quot;/components/tag/index&quot;
  }
}
</code></pre>
<p>遍历historywords,把所有标签呈现出来</p>
<pre><code class="lang-html">search/index.wxml
&lt;view class=&quot;history&quot;&gt;
      &lt;view class=&quot;title&quot;&gt;
        &lt;view class=&quot;chunk&quot;&gt;&lt;/view&gt;
        &lt;text&gt;历史搜索&lt;/text&gt;
      &lt;/view&gt;
    &lt;view class=&quot;tags&quot;&gt;//
          &lt;block wx:for=&quot;{{historyWords}}&quot;&gt;
            &lt;tag-cmp text=&quot;{{item}}&quot;/&gt;
          &lt;/block&gt;
        &lt;/view&gt;
    &lt;/view&gt;
</code></pre>
<h4 id="实现热门搜索"><a href="#实现热门搜索" class="headerlink" title="实现热门搜索"></a>实现热门搜索</h4><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/200826.jpg" style="zoom:50%;"></p>
<p>获取接口：get /book/hot_keyword</p>
<pre><code class="lang-js">model/keyword.js
import {HTTP} from &#39;../util/http-p.js&#39;
class KeywordModel extends HTTP{
    ......
     getHot(){
    return this.request({
      urll:&quot;book/hot_keyword&quot;
    })
  }
}
</code></pre>
<pre><code class="lang-js">search/index.js
  data: {
    historyWords:[],
    hotWords:[]
  },

  //初始化组件时小程序默认调用的初始化函数
  attached(event){
    const historyWords = keywordModel.getHistory()//返回的是数组
    const hotWords = keywordModel.getHot()//返回的是promise
    this.setData({
      historyWords:historyWords,

    })

    hotWords.then(res=&gt;{
      this.setData({
        hotWords:res.hot
      })
    })
  },
</code></pre>
<pre><code class="lang-html">wxml
&lt;view class=&quot;history hot-search&quot;&gt;
      &lt;view class=&quot;title&quot;&gt; 
        &lt;view class=&quot;chunk&quot;&gt;&lt;/view&gt;
        &lt;text&gt;热门搜索&lt;/text&gt;
      &lt;/view&gt;
      &lt;view class=&quot;tags&quot;&gt;
        &lt;block wx:for=&quot;{{hotWords}}&quot;&gt;
          &lt;tag-cmp text=&quot;{{item}}&quot;/&gt;
        &lt;/block&gt;
      &lt;/view&gt;
    &lt;/view&gt;
  &lt;/view&gt;
</code></pre>
<p>搜索实现3</p>
<h3 id="代码重构与行为抽象"><a href="#代码重构与行为抽象" class="headerlink" title="代码重构与行为抽象"></a>代码重构与行为抽象</h3><p> 用随机字符串触发Oberver函数</p>
<p> 加载更多数据的判断技巧</p>
<p>使用锁的概念解决重复加载数据的问题</p>
<p>组件行为逻辑抽象——分页行为</p>
<p>是否还有更多数据的判断逻辑</p>
<p>搜索代码重构——增强代码可阅读性</p>
<p>注意避免死锁</p>
<p>特别注意setData与直接赋值的区别</p>
<p>空搜索结果的处理</p>
<h3 id="高级知识与应用"><a href="#高级知识与应用" class="headerlink" title="高级知识与应用"></a>高级知识与应用</h3><p>将锁提取到分页行为中</p>
<p>open-data显示用户信息</p>
<p> 新版微信授权机制</p>
<p>wx.getUserInfo需要用户先授权</p>
<p>通过opensetting判断用户是否授权</p>
<p>自定义button实现获取用户信息</p>
<p>为什么有open-data还需要getUserInfo？</p>
<p> 自定义分享button</p>
<p>小程序之间的跳转</p>
<p>preview组件</p>
<p>小程序云开发的场景和意义</p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/donate/alipay.jpg"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/donate/wechatqr.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
        
          
            <div class="post-nepre full next">
          
            <a href="/2020/07/22/SQL教程/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/SQL.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/SQL.png">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                SQL教程</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "4NBvruApUCpLtmlsyQLevDfx-gzGzoHsz",
        appKey: "eTSHbT3jvLQPcVYMC7QFXQFd",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="www.yulinblog.com" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg" itemprop="image" alt="YUYU" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="www.yulinblog.com" itemprop="url" rel="author">YUYU</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>一个好奇的人</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 YU YU<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>

       <!-- 不蒜子统计 -->
       <div><i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i>
        <span id="busuanzi_container_site_pv" >
             <i class="fa fa-eye" aria-hidden="true"></i><span id="busuanzi_value_site_pv"></span>
        </span>
        <span class="post-meta-divider">|</span>

        <span id="busuanzi_container_site_uv" style='display:none'>
            <i class="fa fa-user-o" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
        </span>
        <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i>
        </div>


      <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>
  var now = new Date();
  function createtime() {
    var grt= new Date("05/19/2020 22:00:00");//此处修改你的建站时间或者网站上线时间
    now.setTime(now.getTime()+250);
    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
    document.getElementById("timeDate").innerHTML = "博客已悄悄运行 "+dnum+" 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
  }
  setInterval("createtime()",250);</script>
  
      
      
</div>

    <div class="footer-device" style="font-family: 'Ubuntu', sans-serif;">
   
        <span style="color: #b9b9b9;"></i>&copy 2020 <i class="fa fa-heart" aria-hidden="true" style="color: pink;"></i> YUYU 

        </span>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b4b3bde9daad1e9f0023976853b7793";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>

<script type="text/javascript" src="/js/funnytitle.js"></script>
<script type="text/javascript" src="/js/loveclick.js"></script>



<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>


 
<div class="skin-menu no-select" id="mainskin"  style="position: fixed">
    <div class="theme-controls row-container">
        <ul class="menu-list">
            <li id="white-bg"> <i class="fa fa-television" aria-hidden="true"></i></li>
            <li id="sakura-bg"> <i class="iconfont icon-sakura"></i></li>
            <li id="gribs-bg"> <i class="fa fa-slack" aria-hidden="true"></i></li>
            <li id="KAdots-bg"> <i class="iconfont icon-dots"></i></li>
            <li id="totem-bg"> <i class="fa fa-optin-monster" aria-hidden="true"></i></li>
            <li id="pixiv-bg"> <i class="iconfont icon-pixiv"></i></li>
            <li id="bing-bg"> <i class="iconfont icon-bing"></i></li>
            <li id="dark-bg"> <i class="fa fa-moon-o" aria-hidden="true"></i></li>
        </ul>
    </div>
</div>   
<canvas id="night-mode-cover"></canvas>
 
  

<div class="changeSkin-gear no-select">
    <div class="keys" id="setbtn"> <span id="open-skinMenu"> 切换主题 | SCHEME TOOL &nbsp;<i
                class="iconfont icon-gear inline-block rotating"></i> </span></div>
</div>

  
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">ひみつきちYUYU</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/sunshine98yy" class="fa fa-github" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
        <a href="mailto:sunshine98yy@163.com" class="fa fa-envelope" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fas fa-home" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/笔记/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  笔记
                </a>
              </li>
            
              <li>
                <a href="/categories/项目/">
                  <i class="fa fa-git" aria-hidden="true"></i>
                  项目
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-share" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/光影艺术/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  摄影
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/tags/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-tag" aria-hidden="true"></i>
            标签
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/categories/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-bookmark" aria-hidden="true"></i>
            分类
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            赞赏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="980618283"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
  <script type="text/javascript" src="source/js/loveclick.js"></script>
  
</body>
</html>