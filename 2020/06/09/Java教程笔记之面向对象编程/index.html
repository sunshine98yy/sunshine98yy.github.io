<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">Java教程笔记之面向对象编程 | 风中的鱼</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "ひみつきちYUYU";
  mashiro_option.author_name = "YUYU";
  mashiro_option.site_url = "www.yulinblog.com";
  mashiro_option.v_appId = "4NBvruApUCpLtmlsyQLevDfx-gzGzoHsz";
  mashiro_option.v_appKey = "eTSHbT3jvLQPcVYMC7QFXQFd";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/5.jpg,https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/3.jpg,https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/4.jpg,https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/cover/6.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop ">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="www.yulinblog.com">
          <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>在海边捡贝壳的孩子</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://github.com/sunshine98yy" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/social/github1.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="mailto:sunshine98yy@163.com" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/whchat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">ひみつきち</span>
            <span class="shironeko">YUYU</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fas fa-home" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/笔记/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          笔记
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/项目/">
                          <i class="fa fa-git" aria-hidden="true"></i>
                          项目
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-share" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/光影艺术/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          摄影
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/tags/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-tag" aria-hidden="true"></i>
                    标签
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/categories/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-bookmark" aria-hidden="true"></i>
                    分类
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    赞赏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/20200610123509.jpg);" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/20200610123509.jpg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      Java教程笔记之面向对象编程</h1>
      <p class="entry-census">
        <span>
          <a href="www.yulinblog.com">
            <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="www.yulinblog.com">YUYU</a>
        </span>
        <span class="bull">
        ·</span>
        2020-6-9<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <p>重新学一遍Java,结合以前的笔记，内容主要摘自<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943520012800" target="_blank" rel="noopener">廖雪峰的官方网站</a>,感谢分享。</p>
<p>Java是一种<strong>面向对象</strong>的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p>
<p>和面向对象编程不同的，是<strong>面向过程编程</strong>。面向过程编程，是把模型分解成一步一步的过程。而面向对象编程，顾名思义，你得首先有个对象,有了对象后，就可以和对象进行互动：</p>
<pre><code class="java">GirlFriend gf = new GirlFriend();
gf.name = &quot;Alice&quot;;
gf.send(&quot;flowers&quot;);
</code></pre>
<p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p>
<h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><h4 id="class和instance"><a href="#class和instance" class="headerlink" title="class和instance"></a>class和instance</h4><p>class是一种对象模版，它定义了如何创建实例。class本身就是一种数据类型</p>
<p>instance是对象实例，instance是根据class创建的实例。可以创建多个instance，每个instance类型相同，但各自属性可能不相同</p>
<h5 id="定义class"><a href="#定义class" class="headerlink" title="定义class"></a>定义class</h5><p>在Java中，创建一个类，例如，给这个类命名为<code>Person</code>，就是定义一个<code>class</code>：</p>
<pre><code class="java">class Person {
    public String name;
    public int age;
}
</code></pre>
<p>一个<code>class</code>可以包含多个字段（<code>field</code>），字段用来描述一个类的特征。上面的<code>Person</code>类，我们定义了两个字段，一个是<code>String</code>类型的字段，命名为<code>name</code>，一个是<code>int</code>类型的字段，命名为<code>age</code>。因此，通过<code>class</code>，把一组数据汇集到一个对象上，实现了<strong>数据封装</strong>。</p>
<h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用<strong>new操作符</strong>。</p>
<p>new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：</p>
<pre><code class="java">Person ming = new Person();
</code></pre>
<p>注意区分<code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例。我们可以通过这个指向实例的变量来操作实例。访问实例变量可以用<code>变量.字段</code>，例如：</p>
<pre><code class="java">Person ming = new Person();
ming.name = &quot;Xiao Ming&quot;; // 对字段name赋值
ming.age = 12; // 对字段age赋值
System.out.println(ming.name); // 访问字段name

Person hong = new Person();
hong.name = &quot;Xiao Hong&quot;;
hong.age = 15;
</code></pre>
<p>上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：</p>
<pre><code class="ascii">            ┌──────────────────┐
ming ──────&gt;│Person instance   │
            ├──────────────────┤
            │name = &quot;Xiao Ming&quot;│
            │age = 12          │
            └──────────────────┘
            ┌──────────────────┐
hong ──────&gt;│Person instance   │
            ├──────────────────┤
            │name = &quot;Xiao Hong&quot;│
            │age = 15          │
            └──────────────────┘
</code></pre>
<p>两个<code>instance</code>拥有<code>class</code>定义的<code>name</code>和<code>age</code>字段，且各自都有一份独立的数据，互不干扰。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p>
<p>定义<code>class</code>就是定义了一种数据类型，对应的<code>instance</code>是这种数据类型的实例；</p>
<p><code>class</code>定义的<code>field</code>，在每个<code>instance</code>都会拥有各自的<code>field</code>，且互不干扰；</p>
<p>通过<code>new</code>操作符创建新的<code>instance</code>，然后用变量指向它，即可通过变量来引用这个<code>instance</code>；</p>
<p>访问实例字段的方法是<code>变量名.字段名</code>；指向<code>instance</code>的变量都是引用变量。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>一个<code>class</code>可以包含多个<code>field</code>，为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问。外部代码不能访问这些<code>field</code>，那我们定义这些<code>field</code>有什么用？怎么才能给它赋值？怎么才能读取它的值？</p>
<p>我们需要使用方法（<code>method</code>）来让外部代码可以间接修改<code>field</code></p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person ming =new Person();
        ming.setName(&quot;zhang san&quot;);
        ming.setAge(12);
        System.out.print(ming.getName()+&quot;: &quot;+ming.getAge());
    }
}

class Person{
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isBlank()){//不允许传入null和空字符串
            throw new IllegalArgumentException(&quot;invalid name&quot;);
        }
        this.name = name.strip();//去掉首尾空格
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age &lt; 0 || age &gt; 100) {
            throw new IllegalArgumentException(&quot;invalid age value&quot;);
        }
        this.age = age;
    }
}
</code></pre>
<p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。</p>
<p>所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。</p>
<p>调用方法的语法是<code>实例变量.方法名(参数);</code>。一个方法调用就是一个语句，所以不要忘了在末尾加<code>;</code></p>
<h5 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h5><p>定义方法的语法是：</p>
<pre><code class="java">修饰符 方法返回类型 方法名(方法参数列表) {
    若干方法语句;
    return 方法返回值;
}
</code></pre>
<p>方法返回值通过<code>return</code>语句实现，如果没有返回值，返回类型设置为<code>void</code>，可以省略<code>return</code>。</p>
<h5 id="private方法"><a href="#private方法" class="headerlink" title="private方法"></a>private方法</h5><p><code>private</code>方法不允许外部调用，内部方法可以调用。</p>
<h5 id="this变量"><a href="#this变量" class="headerlink" title="this变量"></a>this变量</h5><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。通过<code>this.field</code>就可以访问当前实例的字段。</p>
<p>如果没有命名冲突，可以省略<code>this</code>。</p>
<pre><code class="java">class Person {
    private String name;
    public String getName() {
        return name; // 相当于this.name
    }
}
</code></pre>
<p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p>
<pre><code class="java">class Person {
    private String name;
    public void setName(String name) {
        this.name = name; // 前面的this不可少，少了就变成局部变量name了
    }
}
</code></pre>
<h5 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h5><p>方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如：</p>
<pre><code class="java">class Person {
    ...
    public void setNameAndAge(String name, int age) {
        ...
    }
}
</code></pre>
<p>用这个<code>setNameAndAge()</code>方法时，必须有两个参数，且第一个参数必须为<code>String</code>，第二个参数必须为<code>int</code>：</p>
<pre><code class="java">Person ming = new Person();
ming.setNameAndAge(&quot;Xiao Ming&quot;); // 编译错误：参数个数不对
ming.setNameAndAge(12, &quot;Xiao Ming&quot;); // 编译错误：参数类型不对
</code></pre>
<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>可变参数用<code>类型...</code>定义，可变参数相当于<strong>数组类型</strong>：</p>
<pre><code class="java">class Group {
    private String[] names;
    public void setNames(String... names) {
        this.names = names;
    }
}
</code></pre>
<p>调用时，可以这么写：</p>
<pre><code class="java">Group g = new Group();
g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个String
g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个String
g.setNames(&quot;Xiao Ming&quot;); // 传入1个String
g.setNames(); // 传入0个String
</code></pre>
<p>完全可以把可变参数改写为<code>String[]</code>类型：</p>
<pre><code class="java">class Group {
    private String[] names;
    public void setNames(String[] names) {
        this.names = names;
    }
}
</code></pre>
<p>但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。例如：</p>
<pre><code class="java">Group g = new Group();
g.setNames(new String[] {&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;}); // 传入1个String[]
</code></pre>
<p>另一个问题是，调用方可以传入<code>null</code>,而可变参数可以保证无法传入<code>null</code>，因为传入0个参数时，接收到的实际值是一个空数组而不是<code>null</code>。</p>
<h5 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h5><p><strong>基本类型参数</strong>的传递，是调用方值的复制。双方各自的后续修改，互不影响。</p>
<pre><code class="java">// 基本类型参数绑定
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        int n = 15; // n的值为15
        p.setAge(n); // 传入n的值
        System.out.println(p.getAge()); // 15
        n = 20; // n的值改为20
        System.out.println(p.getAge()); // 15还是20?15
    }
}

class Person {
    private int age;

    public int getAge() {
        return this.age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}

</code></pre>
<p><strong>引用类型参数</strong>的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</p>
<pre><code class="java">// 引用类型参数绑定
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        String[] fullname = new String[] { &quot;Homer&quot;, &quot;Simpson&quot; };
        p.setName(fullname); // 传入fullname数组
        System.out.println(p.getName()); // &quot;Homer Simpson&quot;
        fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot;
        System.out.println(p.getName()); // &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;?
    }
}

class Person {
    private String[] name;
    public String getName() {
        return this.name[0] + &quot; &quot; + this.name[1];
    }

    public void setName(String[] name) {
        this.name = name;
    }
}
</code></pre>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建<code>Person</code>实例的时候，一次性传入<code>name</code>和<code>age</code>，完成初始化：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person p = new Person(&quot;Xiao Ming&quot;, 15);
        System.out.println(p.getName());
        System.out.println(p.getAge());
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }   
    public String getName() {
        return this.name;
    }
    public int getAge() {
        return this.age;
    }
}

</code></pre>
<p>构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有<code>void</code>），<strong>调用构造方法，必须用<code>new</code>操作符</strong>。</p>
<h5 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h5><p>如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：</p>
<pre><code class="java">class Person {
    public Person() {
    }
}
</code></pre>
<p>如果我们自定义了一个构造方法，那么，编译器就<em>不再</em>自动创建默认构造方法：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person p = new Person(); // 编译错误:找不到这个构造方法
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }   
    public String getName() {
        return this.name;
    }
    public int getAge() {
        return this.age;
    }
}

</code></pre>
<p>如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：</p>
<pre><code class="java">public Person() {
    }
public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
</code></pre>
<p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>：</p>
<pre><code class="java">class Person {
    private String name; // 默认初始化为null
    private int age; // 默认初始化为0

    public Person() {
    }
}
</code></pre>
<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<ol>
<li>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为<code>10</code>，<code>double salary;</code>表示字段默认初始化为<code>0</code>，<code>String name;</code>表示引用类型字段默认初始化为<code>null</code>；</li>
<li>执行构造方法的代码进行初始化。</li>
</ol>
<p>因此，构造方法的代码由于后运行，所以，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>的字段值最终由构造方法的代码确定。</p>
<h5 id="多构造方法"><a href="#多构造方法" class="headerlink" title="多构造方法"></a>多构造方法</h5><p>可以定义多个构造方法，在通过<code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：</p>
<pre><code class="java">class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name) {
        this.name = name;
        this.age = 12;
    }

    public Person() {
    }
}
</code></pre>
<p>如果调用<code>new Person(&quot;Xiao Ming&quot;, 20);</code>，会自动匹配到构造方法<code>public Person(String, int)</code>。</p>
<p>如果调用<code>new Person(&quot;Xiao Ming&quot;);</code>，会自动匹配到构造方法<code>public Person(String)</code>。</p>
<p>如果调用<code>new Person();</code>，会自动匹配到构造方法<code>public Person()</code>。</p>
<p><strong>一个构造方法可以调用其他构造方法</strong>，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>：</p>
<pre><code class="java">class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name) {
        this(name, 18); // 调用另一个构造方法Person(String, int)
    }

    public Person() {
        this(&quot;Unnamed&quot;); // 调用另一个构造方法Person(String)
    }
}
</code></pre>
<h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><p>方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）。</p>
<p>注意：方法重载的返回值类型通常都是相同的。</p>
<p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<p>举个例子，<code>String</code>类提供了多个重载方法<code>indexOf()</code>，可以查找子串：</p>
<ul>
<li><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</li>
<li><code>int indexOf(String str)</code>：根据字符串查找；</li>
<li><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</li>
<li><code>int indexOf(String str, int fromIndex)</code>根据字符串查找，但指定起始位置。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在前面的章节中，我们已经定义了<code>Person</code>类：</p>
<pre><code class="java">class Person {
    private String name;
    private int age;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
}
</code></pre>
<p>现在，假设需要定义一个<code>Student</code>类，字段如下：</p>
<pre><code class="java">class Student {
    private String name;
    private int age;
    private int score;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
    public int getScore() { … }
    public void setScore(int score) { … }
}
</code></pre>
<p>仔细观察，发现<code>Student</code>类包含了<code>Person</code>类已有的字段和方法，只是多出了一个<code>score</code>字段和相应的<code>getScore()</code>、<code>setScore()</code>方法。</p>
<p>能不能在<code>Student</code>中不要写重复的代码？</p>
<p>这个时候，继承就派上用场了。</p>
<p>继承是面向对象编程中非常强大的一种机制，它首先可以<strong>复用代码</strong>。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>
<p>Java使用<code>extends</code>关键字来实现继承：</p>
<pre><code class="java">class Person {
    private String name;
    private int age;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
}

class Student extends Person {
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() { … }
    public void setScore(int score) { … }
}
</code></pre>
<p>通过继承，<code>Student</code>只需要编写额外的功能，不再需要重复代码。</p>
<p> 注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p>
<p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）。</p>
<h5 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h5><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p>
<pre><code class="ascii">┌───────────┐
│  Object   │
└───────────┘
      ▲
      │
┌───────────┐
│  Person   │
└───────────┘
      ▲
      │
┌───────────┐
│  Student  │
└───────────┘
</code></pre>
<p>Java只允许<strong>一个class继承自一个类</strong>，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p>
<p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p>
<pre><code class="ascii">       ┌───────────┐
       │  Object   │
       └───────────┘
             ▲
             │
       ┌───────────┐
       │  Person   │
       └───────────┘
          ▲     ▲
          │     │
          │     │
┌───────────┐ ┌───────────┐
│  Student  │ │  Teacher  │
└───────────┘ └───────────┘
</code></pre>
<h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p>
<pre><code class="java">class Person {
    private String name;
    private int age;
}

class Student extends Person {
    public String hello() {
        return &quot;Hello, &quot; + name; // 编译错误：无法访问name字段
    }
}
</code></pre>
<p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问。</p>
<p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。</p>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p>
<pre><code class="java">class Student extends Person {
    public String hello() {
        return &quot;Hello, &quot; + super.name;
    }
}
</code></pre>
<p>在Java中，任何<code>class</code>的<strong>构造方法</strong>，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，<strong>编译器会帮我们自动加一句<code>super();</code></strong></p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Student s = new Student(&quot;Xiao Ming&quot;, 12, 89);
    }
}

class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        this.score = score;
    }
}
</code></pre>
<p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p>
<p><code>Student</code>类的构造方法实际上是这样：</p>
<pre><code class="java">class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        super(); // 自动调用父类的构造方法
        this.score = score;
    }
}
</code></pre>
<p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p>
<p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p>
<pre><code class="java">class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        super(name, age); // 调用父类的构造方法Person(String, int)
        this.score = score;
    }
}
</code></pre>
<p>这样就可以正常编译了！</p>
<p><strong>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</strong></p>
<p>这里还顺带引出了另一个问题：即子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p>
<h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><p>如果一个引用变量的类型是<code>Student</code>，那么它可以指向一个<code>Student</code>类型的实例：</p>
<pre><code class="java">Student s = new Student();
</code></pre>
<p>如果一个引用类型的变量是<code>Person</code>，那么它可以指向一个<code>Person</code>类型的实例：</p>
<pre><code class="java">Person p = new Person();
</code></pre>
<p>现在问题来了：如果<code>Student</code>是从<code>Person</code>继承下来的，那么，一个引用类型为<code>Person</code>的变量，能否指向<code>Student</code>类型的实例？</p>
<pre><code class="java">Person p = new Student(); // ???
</code></pre>
<p>测试一下就可以发现，这种指向是允许的！</p>
<p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p>
<p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p>
<pre><code class="java">Student s = new Student();
Person p = s; // upcasting, ok
Object o1 = p; // upcasting, ok
Object o2 = s; // upcasting, ok
</code></pre>
<p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p>
<h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p>
<pre><code class="java">Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!
</code></pre>
<p>不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p>
<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型。</p>
<p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p>
<p>利用<code>instanceof</code>，在向下转型前可以先判断：</p>
<pre><code class="java">Person p = new Student();
if (p instanceof Student) {
    // 只有判断成功才会向下转型:
    Student s = (Student) p; // 一定会成功
}
</code></pre>
<h5 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h5><p>在使用继承时，我们要注意逻辑一致性。继承是is关系，组合是has关系。</p>
<p>具有has关系不应该使用继承，而是使用组合，即<code>Student</code>可以持有一个<code>Book</code>实例：</p>
<pre><code class="java">class Student extends Person {
    protected Book book;
    protected int score;
}
</code></pre>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p>
<p>例如，在<code>Person</code>类中，我们定义了<code>run()</code>方法：</p>
<pre><code class="java">class Person {
    public void run() {
        System.out.println(&quot;Person.run&quot;);
    }
}
</code></pre>
<p>在子类<code>Student</code>中，覆写这个<code>run()</code>方法：</p>
<pre><code class="java">class Student extends Person {
    @Override
    public void run() {
        System.out.println(&quot;Student.run&quot;);
    }
}
</code></pre>
<p>Override和Overload不同的是，方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p>
<p> 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>
<pre><code class="java">class Person {
    public void run() { … }
}

class Student extends Person {
    // 不是Override，因为参数不同:
    public void run(String s) { … }
    // 不是Override，因为返回值不同:
    public int run() { … }
}
</code></pre>
<p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错，但是<code>@Override</code>不是必需的。</p>
<p>已经知道，引用变量的声明类型可能与其实际类型不符，例如：</p>
<pre><code class="java">Person p = new Student();
</code></pre>
<p>如果子类覆写了父类的方法,例如student复写了person的方法，那么，一个实际类型为<code>Student</code>，引用类型为<code>Person</code>的变量，调用其<code>run()</code>方法，调用的是<code>Person</code>还是<code>Student</code>的<code>run()</code>方法？：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person p = new Student();
        p.run(); // 应该打印Person.run还是Student.run?
    }
}

class Person {
    public void run() {
        System.out.println(&quot;Person.run&quot;);
    }
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println(&quot;Student.run&quot;);
    }
}
</code></pre>
<p>运行一下上面的代码就可以知道，实际上调用的方法是<code>Student</code>的<code>run()</code>方法。因此可得出结论：</p>
<p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>
<p>这个非常重要的特性在面向对象编程中称之为<strong>多态</strong>。它的英文拼写非常复杂：Polymorphic。</p>
<h5 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h5><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p>
<pre><code class="java">public void runTwice(Person p) {
    p.run();
    p.run();
}
</code></pre>
<p>它传入的参数类型是<code>Person</code>，我们是<strong>无法知道传入的参数实际类型</strong>究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p>
<p>多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。</p>
<p>这种不确定性的方法调用，究竟有什么作用？</p>
<p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p>
<pre><code class="java">class Income {
    protected double income;
    public double getTax() {
        return income * 0.1; // 税率10%
    }
}
</code></pre>
<p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p>
<pre><code class="java">class Salary extends Income {
    @Override
    public double getTax() {
        if (income &lt;= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}
</code></pre>
<p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p>
<pre><code class="java">class StateCouncilSpecialAllowance extends Income {
    @Override
    public double getTax() {
        return 0;
    }
}
</code></pre>
<p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p>
<pre><code class="java">public double totalTax(Income... incomes) {
    double total = 0;
    for (Income income: incomes) {
        total = total + income.getTax();
    }
    return total;
}
</code></pre>
<p>来试一下（给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税）：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:
        Income[] incomes = new Income[] {
            new Income(3000),
            new Salary(7500),
            new StateCouncilSpecialAllowance(15000)
        };
        System.out.println(totalTax(incomes));
    }

    public static double totalTax(Income... incomes) {
        double total = 0;
        for (Income income: incomes) {
            total = total + income.getTax();
        }
        return total;
    }
}

class Income {
    protected double income;

    public Income(double income) {
        this.income = income;
    }

    public double getTax() {
        return income * 0.1; // 税率10%
    }
}

class Salary extends Income {
    public Salary(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        if (income &lt;= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}

class StateCouncilSpecialAllowance extends Income {
    public StateCouncilSpecialAllowance(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        return 0;
    }
}
</code></pre>
<p>利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p>
<p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>
<h5 id="覆写Object方法"><a href="#覆写Object方法" class="headerlink" title="覆写Object方法"></a>覆写Object方法</h5><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为<code>String</code>；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。</li>
</ul>
<p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。例如：</p>
<pre><code class="java">class Person {
    ...
    // 显示更有意义的字符串:
    @Override
    public String toString() {
        return &quot;Person:name=&quot; + name;
    }

    // 比较是否相等:
    @Override
    public boolean equals(Object o) {
        // 当且仅当o为Person类型:
        if (o instanceof Person) {
            Person p = (Person) o;
            // 并且name字段相同时，返回true:
            return this.name.equals(p.name);
        }
        return false;
    }

    // 计算hash:
    @Override
    public int hashCode() {
        return this.name.hashCode();
    }
}
</code></pre>
<h5 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h5><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p>
<pre><code class="java">class Person {
    protected String name;
    public String hello() {
        return &quot;Hello, &quot; + name;
    }
}

Student extends Person {
    @Override
    public String hello() {
        // 调用父类的hello()方法:
        return super.hello() + &quot;!&quot;;
    }
}
</code></pre>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。<strong>用<code>final</code>修饰的方法不能被<code>Override</code></strong>：</p>
<pre><code class="java">class Person {
    protected String name;
    public final String hello() {
        return &quot;Hello, &quot; + name;
    }
}
</code></pre>
<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p>
<pre><code class="java">final class Person {
    protected String name;
}

// compile error: 不允许继承自Person
Student extends Person {
}
</code></pre>
<p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如：</p>
<pre><code class="java">class Person {
    public final String name = &quot;Unamed&quot;; //对final字段重新赋值会报错
}
</code></pre>
<p>可以在构造方法中初始化final字段：</p>
<pre><code class="java">class Person {
    public final String name;
    public Person(String name) {
        this.name = name;
    }
}
</code></pre>
<p>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改。</p>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><ul>
<li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li>
<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
<li><code>final</code>修饰符有多种作用：<ul>
<li><code>final</code>修饰的方法可以阻止被覆写；</li>
<li><code>final</code>修饰的class可以阻止被继承；</li>
<li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li>
</ul>
</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>由于多态的存在，每个子类都可以覆写父类的方法，如果父类的方法没有实际意义，能否去掉方法的执行语句？答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。能不能去掉父类的方法？答案还是不行，因为去掉父类的方法，就失去了多态的特性。</p>
<p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为<strong>抽象方法</strong>：</p>
<pre><code class="java">class Person {//无法编译
    public abstract void run();
}
</code></pre>
<p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p>
<p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p>
<pre><code class="java">abstract class Person {
    public abstract void run();
}
</code></pre>
<h5 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h5><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p>
<p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p>
<p>使用<code>abstract</code>修饰的类就是抽象类。我们<strong>无法实例化一个抽象类</strong>：</p>
<pre><code class="java">Person p = new Person(); // 编译错误
</code></pre>
<p>无法实例化的抽象类有什么用？</p>
<p>因为抽象类本身被设计成只能用于被继承，因此，<strong>抽象类可以强迫子类实现其定义的抽象方法</strong>，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p>
<p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person p = new Student();
        p.run();
    }
}

abstract class Person {
    public abstract void run();
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println(&quot;Student.run&quot;);
    }
}
</code></pre>
<h5 id="抽象类的使用要点"><a href="#抽象类的使用要点" class="headerlink" title="抽象类的使用要点:"></a>抽象类的使用要点:</h5><ol>
<li><p>有抽象方法的类只能定义成抽象类</p>
</li>
<li><p>抽象类不能实例化，即不能用new来实例化抽象类。</p>
</li>
<li><p>抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。</p>
</li>
<li><p>抽象类只能用来被继承， 抽象方法必须被子类实现。</p>
</li>
</ol>
<h5 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h5><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>
<pre><code class="java">Person s = new Student();
Person t = new Teacher();
</code></pre>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<pre><code class="java">// 不关心Person变量的具体子类型:
s.run();
t.run();
</code></pre>
<p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p>
<pre><code class="java">// 同样不关心新的子类是如何实现run()方法的：
Person e = new Employee();
e.run();
</code></pre>
<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向<strong>抽象编程</strong>。</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li>
</ul>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><ul>
<li>通过<code>abstract</code>定义的方法是抽象方法，它<strong>只有定义，没有实现</strong>。抽象方法定义了子类必须实现的接口规范；</li>
<li>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</li>
<li>如果不实现抽象方法，则该子类仍是一个抽象类；</li>
<li>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，<strong>所有方法全部都是抽象方法</strong>：</p>
<pre><code class="java">abstract class Person {
    public abstract void run();
    public abstract String getName();
}
</code></pre>
<p>就可以把该抽象类改写为接口：<code>interface</code>。在Java中，使用<code>interface</code>可以声明一个接口：</p>
<pre><code class="java">interface Person {
    void run();
    String getName();
}
</code></pre>
<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p>
<pre><code class="java">class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + &quot; run&quot;);
    }

    @Override
    public String getName() {
        return this.name;
    }
}
</code></pre>
<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，<strong>一个类可以实现多个<code>interface</code></strong>，例如：</p>
<pre><code class="java">class Student implements Person, Hello { // 实现了两个interface
    ...
}
</code></pre>
<h5 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h5><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
<p>抽象类和接口的对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">abstract class</th>
<th style="text-align:center">interface</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">继承</td>
<td style="text-align:center">只能extends一个class</td>
<td style="text-align:center">可以implements多个interface</td>
</tr>
<tr>
<td style="text-align:center">字段</td>
<td style="text-align:center">可以定义实例字段</td>
<td style="text-align:center">不能定义实例字段</td>
</tr>
<tr>
<td style="text-align:center">抽象方法</td>
<td style="text-align:center">可以定义抽象方法</td>
<td style="text-align:center">可以定义抽象方法</td>
</tr>
<tr>
<td style="text-align:center">非抽象方法</td>
<td style="text-align:center">可以定义非抽象方法</td>
<td style="text-align:center">可以定义default方法</td>
</tr>
</tbody>
</table>
<h5 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h5><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p>
<pre><code class="java">interface Hello {
    void hello();
}

interface Person extends Hello {
    void run();
    String getName();
}
</code></pre>
<p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p>
<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。</p>
<p>可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/20200608200558.jpg" style="zoom:50%;"></p>
<p>在使用的时候，<strong>实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它</strong>，因为接口比抽象类更抽象：</p>
<pre><code class="java">List list = new ArrayList(); // 用List接口引用具体子类的实例
Collection coll = list; // 向上转型为Collection接口
Iterable it = coll; // 向上转型为Iterable接口
</code></pre>
<h5 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h5><p>实现类可以不必覆写<code>default</code>方法。<strong><code>default</code>方法的目的是</strong>，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person p = new Student(&quot;Xiao Ming&quot;);
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + &quot; run&quot;);
    }
}

class Student implements Person {
    private String name;
    public Student(String name) {
        this.name = name;
    }
    public String getName() {
        return this.name;
    }
}
</code></pre>
<h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><p>在一个<code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p>
<p>还有一种字段，是用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p>
<p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p>
<pre><code class="java">class Person {
    public String name;
    public int age;
    // 定义静态字段number:
    public static int number;
}
</code></pre>
<p>我们来看看下面的代码：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person ming = new Person(&quot;Xiao Ming&quot;, 12);
        Person hong = new Person(&quot;Xiao Hong&quot;, 15);
        ming.number = 88;
        System.out.println(hong.number); //88
        hong.number = 99;
        System.out.println(ming.number); //99
    }
}

class Person {
    public String name;
    public int age;

    public static int number;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

</code></pre>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/20200608204406.jpg" style="zoom: 67%;"></p>
<p>虽然实例可以访问静态字段，但是它们指向的其实都是<code>Person class</code>的静态字段。所以，<strong>所有实例共享一个静态字段</strong>。</p>
<p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。</p>
<p><strong>推荐用类名来访问静态字段。</strong>可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）。对于上面的代码，更好的写法是：</p>
<pre><code class="java">Person.number = 99;
System.out.println(Person.number);
</code></pre>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>有静态字段，就有静态方法。用<code>static</code>修饰的方法称为静态方法。</p>
<p><strong>调用实例方法必须通过一个实例变量</strong>，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Person.setNumber(99);
        System.out.println(Person.number);
    }
}

class Person {
    public static int number;

    public static void setNumber(int value) {
        number = value;
    }
}
</code></pre>
<p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p>
<p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p>
<p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</p>
<p>静态方法经常用于工具类。例如：</p>
<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
<p>静态方法也经常用于辅助方法。注意到Java程序的入口<code>main()</code>也是静态方法。</p>
<h5 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h5><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p>
<pre><code class="java">public interface Person {
    public static final int MALE = 1;
    public static final int FEMALE = 2;
}
</code></pre>
<p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<pre><code class="java">public interface Person {
    // 编译器会自动加上public statc final:
    int MALE = 1;
    int FEMALE = 2;
}
</code></pre>
<p>编译器会自动把该字段变为<code>public static final</code>类型。</p>
<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><ul>
<li>静态字段属于所有实例“共享”的字段，实际上是属于<code>class</code>的字段；</li>
<li>调用静态方法不需要实例，无法访问<code>this</code>，但可以访问静态字段和其他静态方法；</li>
<li>静态方法常用于工具类和辅助方法。</li>
</ul>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>在Java中，我们使用<code>package</code>来解决名字冲突。</p>
<p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>
<p>例如：</p>
<p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p>
<p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p>
<p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p>
<p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p>
<p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p>
<p>小明的<code>Person.java</code>文件：</p>
<pre><code class="java">package ming; // 申明包名ming

public class Person {
}
</code></pre>
<p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p>
<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>
<p> <strong>要特别注意</strong>：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>
<p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是:</p>
<pre><code class="ascii">package_sample
└─ src
    ├─ hong
    │  └─ Person.java
    │  ming
    │  └─ Person.java
    └─ mr
       └─ jun
          └─ Arrays.java
</code></pre>
<p>即所有Java文件对应的目录层次要和包的层次一致。</p>
<h4 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h4><p><strong>位于同一个包的类，可以访问包作用域的字段和方法</strong>。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>
<pre><code class="java">package hello;

public class Person {
    // 包作用域:
    void hello() {
        System.out.println(&quot;Hello!&quot;);
    }
}
</code></pre>
<p><code>Main</code>类也定义在<code>hello</code>包下面：</p>
<pre><code class="java">package hello;

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.hello(); // 可以调用，因为Main和Person在同一个包
    }
}
</code></pre>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p>
<p>第一种，直接写出完整类名<code>mr.jun.Arrays arrays = new mr.jun.Arrays();</code></p>
<p>第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p>
<pre><code class="java">package ming;
// 导入完整类名:
import mr.jun.Arrays;
public class Person {
    public void run() {
        Arrays arrays = new Arrays();
    }
}
</code></pre>
<p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：<code>import mr.jun.*;</code>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p>
<p>还有一种<code>import static</code>的语法，它可以导入一个类的静态字段和静态方法：</p>
<pre><code class="java">ackage main;

// 导入System类的所有静态字段和静态方法:
import static java.lang.System.*;

public class Main {
    public static void main(String[] args) {
        // 相当于调用System.out.println(…)
        out.println(&quot;Hello, world!&quot;);
    }
}
</code></pre>
<p><code>import static</code>很少使用。</p>
<p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
<pre><code class="java">// Main.java
package test;

import java.text.Format;

public class Main {
    public static void main(String[] args) {
        java.util.List list; // ok，使用完整类名 -&gt; java.util.List
        Format format = null; // ok，使用import的类 -&gt; java.text.Format
        String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String
        System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System
        MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type
    }
}
</code></pre>
<p>编写class的时候，编译器会<strong>自动帮我们做两个import动作</strong>：</p>
<ul>
<li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li>
<li><p>默认自动<code>import java.lang.*</code>。</p>
<p>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>
</li>
</ul>
<p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p>
<h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h5><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。</p>
<p>子包可以根据功能自行命名，如org.apache. commons.log</p>
<p>要注意不要和<code>java.lang</code>包的类重名,注意也不要和JDK常用类重名</p>
<h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><p>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p>
<p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</p>
<p>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p>
<p>包名推荐使用倒置的域名，例如<code>org.apache</code>。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/20200608221123.png" alt></p>
<p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</p>
<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限</p>
<p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问,确切地说，<code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法.由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限。</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Inner i = new Inner();
        i.hi();
    }

    // private方法:
    private static void hello() {
        System.out.println(&quot;private hello!&quot;);
    }

    // 静态内部类:
    static class Inner {
        public void hi() {
            Main.hello();
        }
    }
}
</code></pre>
<p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p>
<p><code>default</code>只要在同一个包，就可以访问<code>package(default)</code>权限的<code>class</code>、<code>field</code>和<code>method</code></p>
<h5 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h5><p>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package(default)</code>权限；</p>
<p>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</p>
<p><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；</p>
<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</p>
<h4 id="面向对象的内存分析"><a href="#面向对象的内存分析" class="headerlink" title="面向对象的内存分析"></a>面向对象的内存分析</h4><p>Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。</p>
<p><strong>栈的特点如下：</strong></p>
<ol>
<li><p>栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)</p>
</li>
<li><p>JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)</p>
</li>
<li><p>栈属于线程私有，不能实现线程间的共享!</p>
</li>
<li><p>栈的存储特性是“先进后出，后进先出”</p>
</li>
<li><p>栈是由系统自动分配，速度快!栈是一个连续的内存空间!</p>
</li>
</ol>
<p><strong>堆的特点如下：</strong></p>
<ol>
<li><p>堆用于存储创建好的对象和数组(数组也是对象)</p>
</li>
<li><p>JVM只有一个堆，被所有线程共享</p>
</li>
<li><p>堆是一个不连续的内存空间，分配灵活，速度慢!</p>
</li>
</ol>
<p><strong>方法区(又叫静态区)特点如下：</strong></p>
<ol>
<li><p>JVM只有一个方法区，被所有线程共享!</p>
</li>
<li><p>方法区实际也是堆，只是用于存储类、常量相关的信息!</p>
</li>
<li><p>用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)</p>
</li>
</ol>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p>垃圾回收机制（Garbage Collection） 针对内存管理问题，Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。</p>
<p>对象空间的分配：使用new关键字创建对象即可</p>
<p>对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。</p>
<h5 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a><strong>垃圾回收过程</strong></h5><p>任何一种垃圾回收算法一般要做两件基本事情：</p>
<ol>
<li><p>发现无用的对象  无用的对象指的就是没有任何变量引用该对象</p>
</li>
<li><p>回收无用对象占用的内存空间  Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理</p>
</li>
</ol>
<h5 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a><strong>垃圾回收相关算法</strong></h5><p><strong>引用计数法</strong></p>
<p>堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。</p>
<pre><code class="java">public class Student {
    String name;
    Student friend;    
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student();      
        s1.friend = s2;
        s2.friend = s1;        
        s1 = null;
        s2 = null;
    }
}
</code></pre>
<p>s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。</p>
<p> <strong>引用可达法(根搜索算法)</strong></p>
<p>程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<h5 id="通用的分代垃圾回收机制"><a href="#通用的分代垃圾回收机制" class="headerlink" title="通用的分代垃圾回收机制"></a>通用的分代垃圾回收机制</h5><p>将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_java/20200609121347.png" style="zoom: 80%;"></p>
<p>Minor GC:用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)</p>
<p>Major GC：用于清理老年代区域。</p>
<p>Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。</p>
<h5 id="清理过程"><a href="#清理过程" class="headerlink" title="清理过程"></a>清理过程</h5><ol>
<li>创建新对象，大多数放在Eden区</li>
<li>Eden满了（或达到一定比例），触发Minor GC,  把有用的复制到Survivor1, 同时清空Eden区。</li>
<li>Eden区再次满了，出发Minor GC, 把Eden和Survivor1中有用的，复制到Survivor2, 同时清空Eden，Survivor1。</li>
<li>Eden区第三次满了，出发Minor GC, 把Eden和Survivor2中有用的，复制到Survivor1, 同时清空Eden，Survivor2。形成循环，Survoivor1和Survivor2中来回清空、复制，过程中有一个Survivor处于空的状态用于下次复制的。</li>
<li>重复多次（默认15），没有被Survivor清理的对象，复制到Old（Tenuerd）区。</li>
<li>当Old达到一定比例，触发Major GC，清理老年代。    </li>
<li>当Old满了，触发Full 。注意，Full GC清理代价大，系统资源消耗高。</li>
</ol>
<h3 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h3><p>本节我们将介绍Java的核心类，包括：字符串、StringBuilder、StringJoiner、包装类型、JavaBean、枚举、常用工具类</p>
<h4 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>在Java中，<strong><code>String</code>是一个引用类型</strong>，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p>
<pre><code class="java">String s1 = &quot;Hello!&quot;;
</code></pre>
<p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p>
<pre><code class="java">String s2 = new String(new char[] {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;});
</code></pre>
<p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p>
<p>Java字符串的一个重要特点就是字符串<strong><em>不可变</em></strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        String s = &quot;Hello&quot;;
        System.out.println(s); //Hello
        s = s.toUpperCase();
        System.out.println(s); //HELLO,S重新指向了新的字符串
    }
}
</code></pre>
<h5 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h5><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。<strong>必须使用<code>equals()</code></strong>方法而不能用<code>==</code>。</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        String s1 = &quot;hello&quot;;
        String s2 = &quot;hello&quot;;
        System.out.println(s1 == s2); \\true
        System.out.println(s1.equals(s2)); \\true
    }
}
</code></pre>
<p>表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</p>
<p>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：<code>String s2 = &quot;HELLO&quot;.toLowerCase();</code></p>
<p>结论：两个字符串比较，必须总是使用<code>equals()</code>方法。要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>
<p><code>String</code>类还提供了多种方法来<strong>搜索子串、提取子串</strong>。常用的方法有：</p>
<pre><code class="java">// 搜索子串:
&quot;Hello&quot;.contains(&quot;ll&quot;); // true
&quot;Hello&quot;.indexOf(&quot;l&quot;); // 2
&quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3
&quot;Hello&quot;.startsWith(&quot;He&quot;); // true
&quot;Hello&quot;.endsWith(&quot;lo&quot;); // true
</code></pre>
<pre><code class="java">//提取子串：
&quot;Hello&quot;.substring(2); // &quot;llo&quot;
&quot;Hello&quot;.substring(2, 4);// &quot;ll&quot; [)的关系
</code></pre>
<h5 id="去除首尾空白字符"><a href="#去除首尾空白字符" class="headerlink" title="去除首尾空白字符"></a>去除首尾空白字符</h5><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。<strong>空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code></strong>：</p>
<pre><code class="java">&quot;  \tHello\r\n &quot;.trim(); // &quot;Hello&quot;
</code></pre>
<p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p>
<p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p>
<pre><code class="java">&quot;\u3000Hello\u3000&quot;.strip(); // &quot;Hello&quot;
&quot; Hello &quot;.stripLeading(); // &quot;Hello &quot;
&quot; Hello &quot;.stripTrailing(); // &quot; Hello&quot;
</code></pre>
<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p>
<pre><code class="java">&quot;&quot;.isEmpty(); // true，因为字符串长度为0
&quot;  &quot;.isEmpty(); // false，因为字符串长度不为0
&quot;  \n&quot;.isBlank(); // true，因为只包含空白字符
&quot; Hello &quot;.isBlank(); // false，因为包含非空白字符
</code></pre>
<h5 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h5><p>要在字符串中替换子串，有两种方法。一种是<strong>根据字符或字符串替换</strong>：</p>
<pre><code class="java">String s = &quot;hello&quot;;
s.replace(&#39;l&#39;, &#39;w&#39;); // &quot;hewwo&quot;，所有字符&#39;l&#39;被替换为&#39;w&#39;
s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;
</code></pre>
<p>另一种是通过正则表达式替换：</p>
<pre><code>String s = &quot;A,,B;C ,D&quot;;
s.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;
</code></pre><p>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p>
<h5 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h5><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p>
<pre><code class="java">String s = &quot;A,B,C,D&quot;;
String[] ss = s.split(&quot;\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}
</code></pre>
<h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p>
<pre><code class="java">String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};
String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot;
</code></pre>
<h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        String s = &quot;Hi %s, your score is %d!&quot;;
        System.out.println(s.formatted(&quot;Alice&quot;, 80));
        System.out.println(String.format(&quot;Hi %s, your score is %.2f!&quot;, &quot;Bob&quot;, 59.5));
    }
}
</code></pre>
<p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p>
<ul>
<li><code>%s</code>：显示字符串；</li>
<li><code>%d</code>：显示整数；</li>
<li><code>%x</code>：显示十六进制整数；</li>
<li><code>%f</code>：显示浮点数。</li>
</ul>
<p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<code>%s</code>可以显示任何数据类型。</p>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p>
<pre><code class="java">String.valueOf(123); // &quot;123&quot;
String.valueOf(45.67); // &quot;45.67&quot;
String.valueOf(true); // &quot;true&quot;
String.valueOf(new Object()); // 类似java.lang.Object@636be97c
</code></pre>
<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>
<pre><code class="java">int n1 = Integer.parseInt(&quot;123&quot;); // 123
int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255
</code></pre>
<p>把字符串转换为<code>boolean</code>类型：</p>
<pre><code class="java">boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true
boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false
</code></pre>
<h5 id="转换为char"><a href="#转换为char" class="headerlink" title="转换为char[]"></a>转换为char[]</h5><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p>
<pre><code>char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]
String s = new String(cs); // char[] -&gt; String
</code></pre><p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        char[] cs = &quot;Hello&quot;.toCharArray();
        String s = new String(cs);
        System.out.println(s);
        cs[0] = &#39;X&#39;;
        System.out.println(s);
    }
}
</code></pre>
<p>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p>
<p>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p>
<h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5><p><code>ASCII</code>编码占用一个字节，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>。例如，字符<code>&#39;A&#39;</code>的编码是<code>0x41</code>，字符<code>&#39;1&#39;</code>的编码是<code>0x31</code>。</p>
<p>把汉字也纳入计算机编码，很显然一个字节不够。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>&#39;中&#39;</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p>
<p>类似的，日文有<code>Shift_JIS</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p>
<p><code>Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在<code>ASCII</code>、<code>GB2312</code>和<code>Unicode</code>的编码：</p>
<p>英文字符<code>&#39;A&#39;</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p>
<pre><code class="ascii">         ┌────┐
ASCII:   │ 41 │
         └────┘
         ┌────┬────┐
Unicode: │ 00 │ 41 │
         └────┴────┘
</code></pre>
<p>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节。</p>
<p>中文字符<code>&#39;中&#39;</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p>
<pre><code class="ascii">         ┌────┬────┐
GB2312:  │ d6 │ d0 │
         └────┴────┘
         ┌────┬────┐
Unicode: │ 4e │ 2d │
         └────┴────┘
</code></pre>
<p>因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，它是一种<strong>变长编码</strong>，用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码。通过<code>UTF-8</code>编码，英文字符<code>&#39;A&#39;</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>&#39;中&#39;</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p>
<p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>
<p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p>
<pre><code class="java">byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换
byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
</code></pre>
<p>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p>
<p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p>
<pre><code class="java">byte[] b = ...
String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
</code></pre>
<p><strong><em>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</em></strong></p>
<h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><ul>
<li>Java字符串<code>String</code>是不可变对象；</li>
<li>字符串操作不改变原字符串内容，而是返回新字符串；</li>
<li>常用的字符串操作：提取子串、查找、替换、大小写转换等；</li>
<li>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</li>
<li>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</li>
<li>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</li>
</ul>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串。</p>
<p>考察下面的循环代码：</p>
<pre><code class="java">String s = &quot;&quot;;
for (int i = 0; i &lt; 1000; i++) {
    s = s + &quot;,&quot; + i;
}
</code></pre>
<p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p>
<p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中<strong>新增字符时，不会创建新的临时对象</strong>：</p>
<pre><code class="java">StringBuilder sb = new StringBuilder(1024);
for (int i = 0; i &lt; 1000; i++) {
    sb.append(&#39;,&#39;);
    sb.append(i);
}
String s = sb.toString();
</code></pre>
<p><code>StringBuilder</code>还可以进行链式操作：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        var sb = new StringBuilder(1024);//类型的名字太长，写起来比较麻烦,如果想省略变量类型，可以使用var关键字,编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder
        sb.append(&quot;Mr &quot;)
          .append(&quot;Bob&quot;)
          .append(&quot;!&quot;)
          .insert(0, &quot;Hello, &quot;);
        System.out.println(sb.toString()); //Hello, Mr Bob! 
    }
}

</code></pre>
<p>如果我们查看<code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，<strong>定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法</strong>。</p>
<p>仿照<code>StringBuilder</code>，我们也可以设计<strong>支持链式操作</strong>的类。例如，一个可以不断增加的计数器：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Adder adder = new Adder();
        adder.add(3)
             .add(5)
             .inc()
             .add(10);
        System.out.println(adder.value());//19
    }
}

class Adder {
    private int sum = 0;

    public Adder add(int n) {
        sum += n;
        return this;
    }

    public Adder inc() {
        sum ++;
        return this;
    }

    public int value() {
        return sum;
    }
}
</code></pre>
<p>注意：对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>
<p>你可能还听说过<code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p>
<p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p>
<h4 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h4><p>用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;};
        var sj = new StringJoiner(&quot;, &quot;);
          //需要给StringJoiner指定“开头”和“结尾”：
        var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;);
        for (String name : names) {
            sj.add(name);
        }
        System.out.println(sj.toString());//Bob, Alice, Grace
        System.out.println(sj.toString());//Hello Bob, Alice, Grace! 
    }
}
</code></pre>
<p>查看源码，可以发现，<code>StringJoiner</code>内部实际上就是使用了<code>StringBuilder</code>，所以拼接效率和<code>StringBuilder</code>几乎是一模一样的。</p>
<h5 id="String-join"><a href="#String-join" class="headerlink" title="String.join()"></a>String.join()</h5><p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p>
<pre><code class="java">String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;};
var s = String.join(&quot;, &quot;, names);
</code></pre>
<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>Java的数据类型分两种：</p>
<ul>
<li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li>
<li>引用类型：所有<code>class</code>和<code>interface</code>类型</li>
</ul>
<p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code>：</p>
<pre><code class="java">String s = null;
int n = null; // compile error!
</code></pre>
<p>如何把一个基本类型视为对象（引用类型）？</p>
<p>比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p>
<pre><code class="java">public class Integer {
    private int value;
    public Integer(int value) {
        this.value = value;
    }
    public int intValue() {
        return this.value;
    }
}
</code></pre>
<p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换：</p>
<pre><code class="java">Integer n = null;
Integer n2 = new Integer(99);
int n3 = n2.intValue();
</code></pre>
<p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">对应的引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">java.lang.Boolean</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">java.lang.Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">java.lang.Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">java.lang.Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">java.lang.Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">java.lang.Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">java.lang.Double</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">java.lang.Character</td>
</tr>
</tbody>
</table>
<p>我们可以直接使用，并不需要自己去定义：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        int i = 100;
        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):
        Integer n1 = new Integer(i);
        // 通过静态方法valueOf(int)创建Integer实例:
        Integer n2 = Integer.valueOf(i);
        // 通过静态方法valueOf(String)创建Integer实例:
        Integer n3 = Integer.valueOf(&quot;100&quot;);
        System.out.println(n3.intValue());
    }
}
</code></pre>
<h5 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h5><p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>
<pre><code class="java">Integer n = 100; // 编译器自动使用Integer.valueOf(int)
int x = n; // 编译器自动使用Integer.intValue()
</code></pre>
<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p>
<p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p>
<p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>。</p>
<h5 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h5><p>所有的包装类型都是不变类。我们查看<code>Integer</code>的源码可知，它的核心代码如下：</p>
<pre><code class="java">public final class Integer {
    private final int value;
}
</code></pre>
<p>因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p>
<p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Integer x = 127;
        Integer y = 127;
        Integer m = 99999;
        Integer n = 99999;
        System.out.println(&quot;x == y: &quot; + (x==y)); // true
        System.out.println(&quot;m == n: &quot; + (m==n)); // false
        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true
        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true
    }
}
</code></pre>
<p>较小的两个相同的<code>Integer</code>返回<code>true</code>，较大的两个相同的<code>Integer</code>返回<code>false</code>，这是因为<code>Integer</code>是不变类，编译器把<code>Integer x = 127;</code>自动变为<code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code><strong>对于较小的数，始终返回相同的实例</strong>，因此，<code>==</code>比较“恰好”为<code>true</code>，但我们<em>绝不能</em>因为Java标准库的<code>Integer</code>内部有缓存优化就用<code>==</code>比较，必须用<code>equals()</code>方法比较两个<code>Integer</code>。</p>
<h5 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h5><p>最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p>
<pre><code class="java">int x1 = Integer.parseInt(&quot;100&quot;); // 100
int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析
</code></pre>
<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制
        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制
        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制
        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制
        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制
    }
}
</code></pre>
<p>注意：上述方法的输出都是<code>String</code></p>
<p>我们经常使用的<code>System.out.println(n);</code>是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用<code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p>
<p><strong>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</strong></p>
<p>Java的包装类型还定义了一些有用的静态变量</p>
<pre><code class="java">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:
Boolean t = Boolean.TRUE;
Boolean f = Boolean.FALSE;
// int可表示的最大/最小值:
int max = Integer.MAX_VALUE; // 2147483647
int min = Integer.MIN_VALUE; // -2147483648
// long类型占用的bit和byte数量:
int sizeOfLong = Long.SIZE; // 64 (bits)
int bytesOfLong = Long.BYTES; // 8 (bytes)
</code></pre>
<p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<pre><code class="java">// 向上转型为Number:
Number num = new Integer(999);
// 获取byte, int, long, float, double:
byte b = num.byteValue();
int n = num.intValue();
long ln = num.longValue();
float f = num.floatValue();
double d = num.doubleValue();
</code></pre>
<h5 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h5><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p>
<p>例如，byte是有符号整型，范围是<code>-128</code>~<code>+127</code>，但如果把<code>byte</code>看作无符号整型，它的范围就是<code>0</code>~<code>255</code>。我们把一个负的<code>byte</code>按无符号整型转换为<code>int</code>：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        byte x = -1;
        byte y = 127;
        System.out.println(Byte.toUnsignedInt(x)); // 255
        System.out.println(Byte.toUnsignedInt(y)); // 127
    }
}
</code></pre>
<p>类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code>。</p>
<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p>
<ul>
<li>若干<code>private</code>实例字段；</li>
<li>通过<code>public</code>方法来读写实例字段。</li>
</ul>
<p>如果读写方法符合以下这种命名规范：</p>
<pre><code class="java">// 读方法:
public Type getXyz()
// 写方法:
public void setXyz(Type value)
</code></pre>
<p>那么这种<code>class</code>被称为<code>JavaBean</code></p>
<p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p>
<p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>
<pre><code class="java">// 读方法:
public boolean isChild()
// 写方法:
public void setChild(boolean value)
</code></pre>
<p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p>
<ul>
<li>对应的读方法是<code>String getName()</code></li>
<li>对应的写方法是<code>setName(String)</code></li>
</ul>
<p>只有<code>getter</code>的属性称为只读属性（read-only），例如，定义一个age只读属性：</p>
<ul>
<li>对应的读方法是<code>int getAge()</code></li>
<li>无对应的写方法<code>setAge(int)</code></li>
</ul>
<p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p>
<p>很明显，只读属性很常见，只写属性不常见。</p>
<p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p>
<pre><code class="java">public class Person {
    private String name;
    private int age;

    public String getName() { return this.name; }
    public void setName(String name) { this.name = name; }

    public int getAge() { return this.age; }
    public void setAge(int age) { this.age = age; }

    public boolean isChild() {
        return age &lt;= 6;
    }
}
</code></pre>
<p>可以看出，<code>getter</code>和<code>setter</code>也是一种数据封装的方法。</p>
<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>在Java中，我们可以通过<code>static final</code>来定义常量。使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。</p>
<h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p>为了让编译器能自动检查某个值在枚举的集合内，并且不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day == Weekday.SAT || day == Weekday.SUN) {
            System.out.println(&quot;Work at home!&quot;);
        } else {
            System.out.println(&quot;Work at office!&quot;);
        }
    }
}
enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}

</code></pre>
<p>注意到定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p>
<p>和<code>int</code>定义的常量相比，使用<code>enum</code>定义枚举有如下好处：</p>
<p>首先，<code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p>
<pre><code class="java">int day = 1;
if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator &#39;==&#39;
}
</code></pre>
<p>其次，不可能引用到非枚举的值，因为无法通过编译。</p>
<p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个<code>Weekday</code>枚举类型的变量赋值为<code>Color</code>枚举类型的值：</p>
<pre><code class="java">Weekday x = Weekday.SUN; // ok!
Weekday y = Color.RED; // Compile error: incompatible types
</code></pre>
<p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p>
<h5 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h5><p>使用<code>enum</code>定义的枚举类是一种引用类型。引用类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，<strong>它比较的是两个引用类型的变量是否是同一个对象</strong>。因此，引用类型比较，要始终使用<code>equals()</code>方法，但<strong><code>enum</code>类型可以例外</strong>。</p>
<p>这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较：</p>
<pre><code>if (day == Weekday.FRI) { // ok!
}
if (day.equals(Weekday.SUN)) { // ok, but more code!
}
</code></pre><h5 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h5><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p>
<p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<p>例如，我们定义的<code>Color</code>枚举类：</p>
<pre><code class="java">public enum Color {
    RED, GREEN, BLUE;
}
</code></pre>
<p>编译器编译出的<code>class</code>大概就像这样：</p>
<pre><code class="java">public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}
</code></pre>
<p>因为<code>enum</code>是一个<code>class</code>，<strong>每个枚举的值都是<code>class</code>实例</strong>，因此，这些实例有一些方法：</p>
<p><strong>name()</strong>:返回常量名，例如：</p>
<pre><code class="java">String s = Weekday.SUN.name(); // &quot;SUN&quot;
</code></pre>
<p><strong>ordinal()</strong>:返回定义的常量的顺序，从0开始计数，例如：</p>
<pre><code>int n = Weekday.MON.ordinal(); // 1
</code></pre><p>改变枚举常量定义的顺序就会导致<code>ordinal()</code>返回值发生变化。如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且给每个枚举常量添加字段：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day.dayValue == 6 || day.dayValue == 0) {
            System.out.println(&quot;Work at home!&quot;);
        } else {
            System.out.println(&quot;Work at office!&quot;);
        }
    }
}

enum Weekday {
    MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);//每个枚举值都是class实例

    public final int dayValue;
    private Weekday(int dayValue) {
        this.dayValue = dayValue;
    }
}
</code></pre>
<p> <strong>注意：</strong>枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</p>
<p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day.dayValue == 6 || day.dayValue == 0) {
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;);
        } else {
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);
        }
    }
}

enum Weekday {
    MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;);

    public final int dayValue;
    private final String chinese;

    private Weekday(int dayValue, String chinese) {
        this.dayValue = dayValue;
        this.chinese = chinese;
    }

    @Override
    public String toString() {
        return this.chinese;
    }
}
</code></pre>
<p>覆写<code>toString()</code>的目的是在输出时更有可读性。</p>
<p> 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</p>
<h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><p>最后，枚举类可以应用在<code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code>int</code>、<code>String</code>类型更适合用在<code>switch</code>语句中：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        switch(day) {
        case MON:
        case TUE:
        case WED:
        case THU:
        case FRI:
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);
            break;
        case SAT:
        case SUN:
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;);
            break;
        default:
            throw new RuntimeException(&quot;cannot process &quot; + day);
                //加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。
        }
    }
}

enum Weekday {
    MON, TUE, WED, THU, FRI, SAT, SUN;
}
</code></pre>
<h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum { … }</code>；</p>
<p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p>
<p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p>
<p>可以为<code>enum</code>编写构造方法、字段和方法</p>
<p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p>
<p><code>enum</code>适合用在<code>switch</code>语句中。</p>
<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p>
<p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来<strong>表示任意大小的整数</strong>。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数,<strong>对<code>BigInteger</code>做运算的时候，只能使用实例方法</strong>，例如，加法运算：</p>
<pre><code class="java">BigInteger i1 = new BigInteger(&quot;1234567890&quot;);
BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;);
BigInteger sum = i1.add(i2); // 12345678902469135780
</code></pre>
<p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。也可以把<code>BigInteger</code>转换成<code>long</code>型:</p>
<pre><code class="java">BigInteger i = new BigInteger(&quot;123456789000&quot;);
System.out.println(i.longValue()); // 123456789000
System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range
</code></pre>
<p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p>
<p>可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。如果<code>BigInteger</code>的值甚至超过了<code>float</code>的最大范围（3.4*10^38),那么返回的float是Infinity 。</p>
<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p><code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<pre><code class="java">BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);
System.out.println(bd.multiply(bd)); // 15241.55677489
</code></pre>
<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如</p>
<pre><code class="java">BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);
System.out.println(d1.scale()); // 2,两位小数
</code></pre>
<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p>
<pre><code class="java">BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d2 = d1.stripTrailingZeros();
System.out.println(d1.scale()); // 4
System.out.println(d2.scale()); // 2,因为去掉了00

BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
BigDecimal d4 = d3.stripTrailingZeros();
System.out.println(d3.scale()); // 0
System.out.println(d4.scale()); // -2，表示这个数是个整数，并且末尾有2个0
</code></pre>
<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;);
        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568
        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567
        System.out.println(d2);
        System.out.println(d3);
    }
}
</code></pre>
<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>
<pre><code class="java">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);
BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入
BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽
</code></pre>
<p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p>
<pre><code class="java">public class Main {
    public static void main(String[] args) {
        BigDecimal n = new BigDecimal(&quot;12.345&quot;);
        BigDecimal m = new BigDecimal(&quot;0.12&quot;);
        BigDecimal[] dr = n.divideAndRemainder(m);
        System.out.println(dr[0]); // 102
        System.out.println(dr[1]); // 0.105
    }
}
</code></pre>
<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p>
<pre><code class="java">BigDecimal n = new BigDecimal(&quot;12.75&quot;);
BigDecimal m = new BigDecimal(&quot;0.15&quot;);
BigDecimal[] dr = n.divideAndRemainder(m);
if (dr[1].signum() == 0) {
    // n是m的整数倍
}
</code></pre>
<h4 id="比较BigDecimal"><a href="#比较BigDecimal" class="headerlink" title="比较BigDecimal"></a>比较BigDecimal</h4><p>比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等。</p>
<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>
<p> 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p>
<pre><code class="java">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;);
System.out.println(d1.equals(d2)); // false,因为scale不同
System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2
System.out.println(d1.compareTo(d2)); // 0
</code></pre>
<h4 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h4><h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><p><code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算</p>
<p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p>
<pre><code>Math.random(); // 0.53907... 每次都不一样
</code></pre><p>如果我们要生成一个区间在<code>[MIN, MAX)</code>的随机数，可以借助<code>Math.random()</code>实现，计算如下：</p>
<pre><code class="java">// 区间在[MIN, MAX)的随机数
public class Main {
    public static void main(String[] args) {
        double x = Math.random(); // x的范围是[0,1)
        double min = 10;
        double max = 50;
        double y = x * (max - min) + min; // y的范围是[10,50)
        long n = (long) y; // n的范围是[10,50)的整数
        System.out.println(y);
        System.out.println(n);
    }
}
</code></pre>
<p>Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而<code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用<code>Math</code>就足够了。</p>
<h5 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h5><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p>
<pre><code class="java">Random r = new Random();
r.nextInt(); // 2071575453,每次都不一样
r.nextInt(10); // 5,生成一个[0,10)之间的int
......
</code></pre>
<p>每次运行程序，生成的随机数都是不同的，没看出<em>伪随机数</em>的特性来。</p>
<p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列</p>
<p><code>Random r = new Random(12345);</code></p>
<p>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p>
<h5 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h5><p><code>SecureRandom</code>就是用来创建安全的随机数的：</p>
<pre><code class="java">SecureRandom sr = new SecureRandom();
System.out.println(sr.nextInt(100));
</code></pre>
<p>实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p>
<pre><code class="java">public static void main(String[] args) {
    SecureRandom sr = null;
    try {
        sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器
    } catch (NoSuchAlgorithmException e) {
        sr = new SecureRandom(); // 获取普通的安全随机数生成器
    }
    byte[] buffer = new byte[16];
    sr.nextBytes(buffer); // 用安全随机数填充buffer
    System.out.println(Arrays.toString(buffer));
}
</code></pre>
<p>SecureRandom`的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
<p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/donate/alipay.jpg"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/donate/wechatqr.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2020/06/11/Java教程笔记之Maven基础/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_maven20200611003015.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/note_maven20200611003015.png">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                Java教程笔记之Maven基础</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2020/05/26/Python入门与进阶/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/technology_git/20200526010538.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/technology_git/20200526010538.png">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                Python入门与进阶</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "4NBvruApUCpLtmlsyQLevDfx-gzGzoHsz",
        appKey: "eTSHbT3jvLQPcVYMC7QFXQFd",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="www.yulinblog.com" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg" itemprop="image" alt="YUYU" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="www.yulinblog.com" itemprop="url" rel="author">YUYU</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>一个好奇的人</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 YU YU<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>

       <!-- 不蒜子统计 -->
       <div><i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i>
        <span id="busuanzi_container_site_pv" >
             <i class="fa fa-eye" aria-hidden="true"></i><span id="busuanzi_value_site_pv"></span>
        </span>
        <span class="post-meta-divider">|</span>

        <span id="busuanzi_container_site_uv" style='display:none'>
            <i class="fa fa-user-o" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
        </span>
        <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i>
        </div>


      <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>
  var now = new Date();
  function createtime() {
    var grt= new Date("05/19/2020 22:00:00");//此处修改你的建站时间或者网站上线时间
    now.setTime(now.getTime()+250);
    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
    document.getElementById("timeDate").innerHTML = "博客已悄悄运行 "+dnum+" 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
  }
  setInterval("createtime()",250);</script>
  
      
      
</div>

    <div class="footer-device" style="font-family: 'Ubuntu', sans-serif;">
   
        <span style="color: #b9b9b9;"></i>&copy 2020 <i class="fa fa-heart" aria-hidden="true" style="color: pink;"></i> YUYU 

        </span>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b4b3bde9daad1e9f0023976853b7793";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>

<script type="text/javascript" src="/js/funnytitle.js"></script>
<script type="text/javascript" src="/js/loveclick.js"></script>



<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>


 
<div class="skin-menu no-select" id="mainskin"  style="position: fixed">
    <div class="theme-controls row-container">
        <ul class="menu-list">
            <li id="white-bg"> <i class="fa fa-television" aria-hidden="true"></i></li>
            <li id="sakura-bg"> <i class="iconfont icon-sakura"></i></li>
            <li id="gribs-bg"> <i class="fa fa-slack" aria-hidden="true"></i></li>
            <li id="KAdots-bg"> <i class="iconfont icon-dots"></i></li>
            <li id="totem-bg"> <i class="fa fa-optin-monster" aria-hidden="true"></i></li>
            <li id="pixiv-bg"> <i class="iconfont icon-pixiv"></i></li>
            <li id="bing-bg"> <i class="iconfont icon-bing"></i></li>
            <li id="dark-bg"> <i class="fa fa-moon-o" aria-hidden="true"></i></li>
        </ul>
    </div>
</div>   
<canvas id="night-mode-cover"></canvas>
 
  

<div class="changeSkin-gear no-select">
    <div class="keys" id="setbtn"> <span id="open-skinMenu"> 切换主题 | SCHEME TOOL &nbsp;<i
                class="iconfont icon-gear inline-block rotating"></i> </span></div>
</div>

  
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">ひみつきちYUYU</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/sunshine98yy" class="fa fa-github" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
        <a href="mailto:sunshine98yy@163.com" class="fa fa-envelope" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fas fa-home" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/笔记/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  笔记
                </a>
              </li>
            
              <li>
                <a href="/categories/项目/">
                  <i class="fa fa-git" aria-hidden="true"></i>
                  项目
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-share" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/光影艺术/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  摄影
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/tags/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-tag" aria-hidden="true"></i>
            标签
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/categories/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-bookmark" aria-hidden="true"></i>
            分类
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            赞赏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="980618283"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
  <script type="text/javascript" src="source/js/loveclick.js"></script>
  
</body>
</html>