{"meta":{"title":"风中的鱼","subtitle":null,"description":"心里有火眼里有光","author":"YU YU","url":""},"pages":[{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-05-19T07:23:57.767Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-05-19T08:37:48.007Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"categories","date":"2020-03-09T05:50:05.000Z","updated":"2020-05-19T15:43:16.267Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-05-18T08:11:28.691Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"tags","date":"2020-03-09T05:50:05.000Z","updated":"2020-05-19T15:18:50.643Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java教程笔记之面向对象编程","slug":"Java教程笔记之面向对象编程","date":"2020-06-09T14:24:27.000Z","updated":"2020-06-10T04:35:55.843Z","comments":true,"path":"2020/06/09/Java教程笔记之面向对象编程/","link":"","permalink":"/2020/06/09/Java教程笔记之面向对象编程/","excerpt":"","text":"重新学一遍Java,结合以前的笔记，内容主要摘自廖雪峰的官方网站,感谢分享。 Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。 和面向对象编程不同的，是面向过程编程。面向过程编程，是把模型分解成一步一步的过程。而面向对象编程，顾名思义，你得首先有个对象,有了对象后，就可以和对象进行互动： GirlFriend gf = new GirlFriend(); gf.name = &quot;Alice&quot;; gf.send(&quot;flowers&quot;); 面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。 面向对象基础class和instanceclass是一种对象模版，它定义了如何创建实例。class本身就是一种数据类型 instance是对象实例，instance是根据class创建的实例。可以创建多个instance，每个instance类型相同，但各自属性可能不相同 定义class在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： class Person { public String name; public int age; } 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 创建实例定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： Person ming = new Person(); 注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。我们可以通过这个指向实例的变量来操作实例。访问实例变量可以用变量.字段，例如： Person ming = new Person(); ming.name = &quot;Xiao Ming&quot;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = &quot;Xiao Hong&quot;; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： ┌──────────────────┐ ming ──────&gt;│Person instance │ ├──────────────────┤ │name = &quot;Xiao Ming&quot;│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────&gt;│Person instance │ ├──────────────────┤ │name = &quot;Xiao Hong&quot;│ │age = 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 小结在OOP中，class和instance是“模版”和“实例”的关系； 定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例； class定义的field，在每个instance都会拥有各自的field，且互不干扰； 通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance； 访问实例字段的方法是变量名.字段名；指向instance的变量都是引用变量。 方法一个class可以包含多个field，为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问。外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？ 我们需要使用方法（method）来让外部代码可以间接修改field public class Main { public static void main(String[] args) { Person ming =new Person(); ming.setName(&quot;zhang san&quot;); ming.setAge(12); System.out.print(ming.getName()+&quot;: &quot;+ming.getAge()); } } class Person{ private String name; private int age; public String getName() { return name; } public void setName(String name) { if (name == null || name.isBlank()){//不允许传入null和空字符串 throw new IllegalArgumentException(&quot;invalid name&quot;); } this.name = name.strip();//去掉首尾空格 } public int getAge() { return age; } public void setAge(int age) { if (age &lt; 0 || age &gt; 100) { throw new IllegalArgumentException(&quot;invalid age value&quot;); } this.age = age; } } 虽然外部代码不能直接修改private字段，但是，外部代码可以调用方法setName()和setAge()来间接修改private字段。在方法内部，我们就有机会检查参数对不对。 所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。 调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加; 定义方法定义方法的语法是： 修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法private方法不允许外部调用，内部方法可以调用。 this变量在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。通过this.field就可以访问当前实例的字段。 如果没有命名冲突，可以省略this。 class Person { private String name; public String getName() { return name; // 相当于this.name } } 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this： class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 } } 方法参数方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如： class Person { ... public void setNameAndAge(String name, int age) { ... } } 用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int： Person ming = new Person(); ming.setNameAndAge(&quot;Xiao Ming&quot;); // 编译错误：参数个数不对 ming.setNameAndAge(12, &quot;Xiao Ming&quot;); // 编译错误：参数类型不对 可变参数可变参数用类型...定义，可变参数相当于数组类型： class Group { private String[] names; public void setNames(String... names) { this.names = names; } } 调用时，可以这么写： Group g = new Group(); g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个String g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个String g.setNames(&quot;Xiao Ming&quot;); // 传入1个String g.setNames(); // 传入0个String 完全可以把可变参数改写为String[]类型： class Group { private String[] names; public void setNames(String[] names) { this.names = names; } } 但是，调用方需要自己先构造String[]，比较麻烦。例如： Group g = new Group(); g.setNames(new String[] {&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;}); // 传入1个String[] 另一个问题是，调用方可以传入null,而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。 参数绑定基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 // 基本类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15还是20?15 } } class Person { private int age; public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } } 引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。 // 引用类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { &quot;Homer&quot;, &quot;Simpson&quot; }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // &quot;Homer Simpson&quot; fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot; System.out.println(p.getName()); // &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;? } } class Person { private String[] name; public String getName() { return this.name[0] + &quot; &quot; + this.name[1]; } public void setName(String[] name) { this.name = name; } } 构造方法创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化： public class Main { public static void main(String[] args) { Person p = new Person(&quot;Xiao Ming&quot;, 15); System.out.println(p.getName()); System.out.println(p.getAge()); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。 默认构造方法如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样： class Person { public Person() { } } 如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法： public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来： public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： class Person { private String name; // 默认初始化为null private int age; // 默认初始化为0 public Person() { } } 在Java中，创建对象实例的时候，按照如下顺序进行初始化： 先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null； 执行构造方法的代码进行初始化。 因此，构造方法的代码由于后运行，所以，new Person(&quot;Xiao Ming&quot;, 12)的字段值最终由构造方法的代码确定。 多构造方法可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { } } 如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person()。 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(&quot;Unnamed&quot;); // 调用另一个构造方法Person(String) } } 方法重载方法名相同，但各自的参数不同，称为方法重载（Overload）。 注意：方法重载的返回值类型通常都是相同的。 方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 举个例子，String类提供了多个重载方法indexOf()，可以查找子串： int indexOf(int ch)：根据字符的Unicode码查找； int indexOf(String str)：根据字符串查找； int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置； int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置。 继承在前面的章节中，我们已经定义了Person类： class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } 现在，假设需要定义一个Student类，字段如下： class Student { private String name; private int age; private int score; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} public int getScore() { … } public void setScore(int score) { … } } 仔细观察，发现Student类包含了Person类已有的字段和方法，只是多出了一个score字段和相应的getScore()、setScore()方法。 能不能在Student中不要写重复的代码？ 这个时候，继承就派上用场了。 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 Java使用extends关键字来实现继承： class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … } } 通过继承，Student只需要编写额外的功能，不再需要重复代码。 注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！ 在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 继承树注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ │ ┌───────────┐ │ Student │ └───────────┘ Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ ▲ │ │ │ │ ┌───────────┐ ┌───────────┐ │ Student │ │ Teacher │ └───────────┘ └───────────┘ protected继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段： class Person { private String name; private int age; } class Student extends Person { public String hello() { return &quot;Hello, &quot; + name; // 编译错误：无法访问name字段 } } 这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问。 因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。 supersuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如： class Student extends Person { public String hello() { return &quot;Hello, &quot; + super.name; } } 在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super(); public class Main { public static void main(String[] args) { Student s = new Student(&quot;Xiao Ming&quot;, 12, 89); } } class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; } } class Student extends Person { protected int score; public Student(String name, int age, int score) { this.score = score; } } 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。 Student类的构造方法实际上是这样： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(); // 自动调用父类的构造方法 this.score = score; } } 但是，Person类并没有无参数的构造方法，因此，编译失败。 解决方法是调用Person类存在的某个构造方法。例如： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 调用父类的构造方法Person(String, int) this.score = score; } } 这样就可以正常编译了！ 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 向上转型如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例： Student s = new Student(); 如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例： Person p = new Person(); 现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？ Person p = new Student(); // ??? 测试一下就可以发现，这种指向是允许的！ 这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 Student s = new Student(); Person p = s; // upcasting, ok Object o1 = p; // upcasting, ok Object o2 = s; // upcasting, ok 注意到继承树是Student &gt; Person &gt; Object，所以，可以把Student类型转型为Person，或者更高层次的Object。 向下转型和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如： Person p1 = new Student(); // upcasting, ok Person p2 = new Person(); Student s1 = (Student) p1; // ok Student s2 = (Student) p2; // runtime error! ClassCastException! 不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。 为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型。 instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。 利用instanceof，在向下转型前可以先判断： Person p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 } 区分继承和组合在使用继承时，我们要注意逻辑一致性。继承是is关系，组合是has关系。 具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例： class Student extends Person { protected Book book; protected int score; } 多态在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 例如，在Person类中，我们定义了run()方法： class Person { public void run() { System.out.println(&quot;Person.run&quot;); } } 在子类Student中，覆写这个run()方法： class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } Override和Overload不同的是，方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。 class Person { public void run() { … } } class Student extends Person { // 不是Override，因为参数不同: public void run(String s) { … } // 不是Override，因为返回值不同: public int run() { … } } 加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错，但是@Override不是必需的。 已经知道，引用变量的声明类型可能与其实际类型不符，例如： Person p = new Student(); 如果子类覆写了父类的方法,例如student复写了person的方法，那么，一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？： public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); // 应该打印Person.run还是Student.run? } } class Person { public void run() { System.out.println(&quot;Person.run&quot;); } } class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } 运行一下上面的代码就可以知道，实际上调用的方法是Student的run()方法。因此可得出结论： Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。 这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： public void runTwice(Person p) { p.run(); p.run(); } 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。 多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。 这种不确定性的方法调用，究竟有什么作用？ 假设我们定义一种收入，需要给它报税，那么先定义一个Income类： class Income { protected double income; public double getTax() { return income * 0.1; // 税率10% } } 对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()： class Salary extends Income { @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; } } 如果你享受国务院特殊津贴，那么按照规定，可以全部免税： class StateCouncilSpecialAllowance extends Income { @Override public double getTax() { return 0; } } 现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写： public double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } 来试一下（给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税）： public class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } } class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% } } class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; } } class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; } } 利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 覆写Object方法因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 在必要的情况下，我们可以覆写Object的这几个方法。例如： class Person { ... // 显示更有意义的字符串: @Override public String toString() { return &quot;Person:name=&quot; + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); } } 调用super在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。 class Person { protected String name; public String hello() { return &quot;Hello, &quot; + name; } } Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + &quot;!&quot;; } } final继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： class Person { protected String name; public final String hello() { return &quot;Hello, &quot; + name; } } 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： final class Person { protected String name; } // compile error: 不允许继承自Person Student extends Person { } 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。例如： class Person { public final String name = &quot;Unamed&quot;; //对final字段重新赋值会报错 } 可以在构造方法中初始化final字段： class Person { public final String name; public Person(String name) { this.name = name; } } 这种方法更为常用，因为可以保证实例一旦创建，其final字段就不可修改。 小结： 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为； Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态； final修饰符有多种作用： final修饰的方法可以阻止被覆写； final修饰的class可以阻止被继承； final修饰的field必须在创建对象时初始化，随后不可修改。 抽象类由于多态的存在，每个子类都可以覆写父类的方法，如果父类的方法没有实际意义，能否去掉方法的执行语句？答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。能不能去掉父类的方法？答案还是不行，因为去掉父类的方法，就失去了多态的特性。 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： class Person {//无法编译 public abstract void run(); } 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： abstract class Person { public abstract void run(); } 抽象类如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： Person p = new Person(); // 编译错误 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); } } abstract class Person { public abstract void run(); } class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } 抽象类的使用要点: 有抽象方法的类只能定义成抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承， 抽象方法必须被子类实现。 面向抽象编程当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： Person s = new Student(); Person t = new Teacher(); 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： // 不关心Person变量的具体子类型: s.run(); t.run(); 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： // 同样不关心新的子类是如何实现run()方法的： Person e = new Employee(); e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 小结 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范； 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法； 如果不实现抽象方法，则该子类仍是一个抽象类； 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。 接口在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： abstract class Person { public abstract void run(); public abstract String getName(); } 就可以把该抽象类改写为接口：interface。在Java中，使用interface可以声明一个接口： interface Person { void run(); String getName(); } 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + &quot; run&quot;); } @Override public String getName() { return this.name; } } 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： class Student implements Person, Hello { // 实现了两个interface ... } 术语Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 抽象类和接口的对比如下： abstract class interface 继承 只能extends一个class 可以implements多个interface 字段 可以定义实例字段 不能定义实例字段 抽象方法 可以定义抽象方法 可以定义抽象方法 非抽象方法 可以定义非抽象方法 可以定义default方法 接口继承一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： interface Hello { void hello(); } interface Person extends Hello { void run(); String getName(); } 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 继承关系合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。 可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系： 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象： List list = new ArrayList(); // 用List接口引用具体子类的实例 Collection coll = list; // 向上转型为Collection接口 Iterable it = coll; // 向上转型为Iterable接口 default方法实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 public class Main { public static void main(String[] args) { Person p = new Student(&quot;Xiao Ming&quot;); p.run(); } } interface Person { String getName(); default void run() { System.out.println(getName() + &quot; run&quot;); } } class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; } } 静态字段和静态方法在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子： class Person { public String name; public int age; // 定义静态字段number: public static int number; } 我们来看看下面的代码： public class Main { public static void main(String[] args) { Person ming = new Person(&quot;Xiao Ming&quot;, 12); Person hong = new Person(&quot;Xiao Hong&quot;, 15); ming.number = 88; System.out.println(hong.number); //88 hong.number = 99; System.out.println(ming.number); //99 } } class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; } } 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例： 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： Person.number = 99; System.out.println(Person.number); 静态方法有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如： public class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); } } class Person { public static int number; public static void setNumber(int value) { number = value; } } 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 静态方法经常用于工具类。例如： Arrays.sort() Math.random() 静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。 接口的静态字段因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： public interface Person { public static final int MALE = 1; public static final int FEMALE = 2; } 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2; } 编译器会自动把该字段变为public static final类型。 小结 静态字段属于所有实例“共享”的字段，实际上是属于class的字段； 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法； 静态方法常用于工具类和辅助方法。 包在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 例如： 小明的Person类存放在包ming下面，因此，完整类名是ming.Person； 小红的Person类存放在包hong下面，因此，完整类名是hong.Person； 小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays； JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays。 在定义class的时候，我们需要在第一行声明这个class属于哪个包。 小明的Person.java文件： package ming; // 申明包名ming public class Person { } 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。 包可以是多层结构，用.隔开。例如：java.util。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是: package_sample └─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致。 包作用域位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： package hello; public class Person { // 包作用域: void hello() { System.out.println(&quot;Hello!&quot;); } } Main类也定义在hello包下面： package hello; public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 } } import在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法： 第一种，直接写出完整类名mr.jun.Arrays arrays = new mr.jun.Arrays(); 第二种写法是用import语句，导入小军的Arrays，然后写简单类名： package ming; // 导入完整类名: import mr.jun.Arrays; public class Person { public void run() { Arrays arrays = new Arrays(); } } 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）：import mr.jun.*;我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 还有一种import static的语法，它可以导入一个类的静态字段和静态方法： ackage main; // 导入System类的所有静态字段和静态方法: import static java.lang.System.*; public class Main { public static void main(String[] args) { // 相当于调用System.out.println(…) out.println(&quot;Hello, world!&quot;); } } import static很少使用。 Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 // Main.java package test; import java.text.Format; public class Main { public static void main(String[] args) { java.util.List list; // ok，使用完整类名 -&gt; java.util.List Format format = null; // ok，使用import的类 -&gt; java.text.Format String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type } } 编写class的时候，编译器会自动帮我们做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。 如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 最佳实践为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。 子包可以根据功能自行命名，如org.apache. commons.log 要注意不要和java.lang包的类重名,注意也不要和JDK常用类重名 小结Java内建的package机制是为了避免class命名冲突； JDK的核心类使用java.lang包，编译器会自动导入； JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，……； 包名推荐使用倒置的域名，例如org.apache。 作用域 定义为public的class、interface可以被其他任何类访问 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限 定义为private的field、method无法被其他类访问,确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法.由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限。 public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(&quot;private hello!&quot;); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } } } protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 default只要在同一个包，就可以访问package(default)权限的class、field和method 小结Java内建的访问权限包括public、protected、private和package(default)权限； Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束； final修饰符不是访问权限，它可以修饰class、field和method； 一个.java文件只能包含一个public类，但可以包含多个非public类。 面向对象的内存分析Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。 栈的特点如下： 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 堆的特点如下： 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点如下： JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 垃圾回收机制垃圾回收机制（Garbage Collection） 针对内存管理问题，Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配：使用new关键字创建对象即可 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情： 发现无用的对象 无用的对象指的就是没有任何变量引用该对象 回收无用对象占用的内存空间 Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理 垃圾回收相关算法引用计数法 堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。 public class Student { String name; Student friend; public static void main(String[] args) { Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; } } s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。 引用可达法(根搜索算法) 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 通用的分代垃圾回收机制将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。 Minor GC:用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) Major GC：用于清理老年代区域。 Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 清理过程 创建新对象，大多数放在Eden区 Eden满了（或达到一定比例），触发Minor GC, 把有用的复制到Survivor1, 同时清空Eden区。 Eden区再次满了，出发Minor GC, 把Eden和Survivor1中有用的，复制到Survivor2, 同时清空Eden，Survivor1。 Eden区第三次满了，出发Minor GC, 把Eden和Survivor2中有用的，复制到Survivor1, 同时清空Eden，Survivor2。形成循环，Survoivor1和Survivor2中来回清空、复制，过程中有一个Survivor处于空的状态用于下次复制的。 重复多次（默认15），没有被Survivor清理的对象，复制到Old（Tenuerd）区。 当Old达到一定比例，触发Major GC，清理老年代。 当Old满了，触发Full 。注意，Full GC清理代价大，系统资源消耗高。 Java核心类本节我们将介绍Java的核心类，包括：字符串、StringBuilder、StringJoiner、包装类型、JavaBean、枚举、常用工具类 字符串和编码String在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用&quot;...&quot;来表示一个字符串： String s1 = &quot;Hello!&quot;; 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的： String s2 = new String(new char[] {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;}); 因为String太常用了，所以Java提供了&quot;...&quot;这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 public class Main { public static void main(String[] args) { String s = &quot;Hello&quot;; System.out.println(s); //Hello s = s.toUpperCase(); System.out.println(s); //HELLO,S重新指向了新的字符串 } } 字符串比较当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。 public class Main { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; System.out.println(s1 == s2); \\\\true System.out.println(s1.equals(s2)); \\\\true } } 表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 所以，这种==比较返回true纯属巧合。换一种写法，==比较就会失败：String s2 = &quot;HELLO&quot;.toLowerCase(); 结论：两个字符串比较，必须总是使用equals()方法。要忽略大小写比较，使用equalsIgnoreCase()方法。 String类还提供了多种方法来搜索子串、提取子串。常用的方法有： // 搜索子串: &quot;Hello&quot;.contains(&quot;ll&quot;); // true &quot;Hello&quot;.indexOf(&quot;l&quot;); // 2 &quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3 &quot;Hello&quot;.startsWith(&quot;He&quot;); // true &quot;Hello&quot;.endsWith(&quot;lo&quot;); // true //提取子串： &quot;Hello&quot;.substring(2); // &quot;llo&quot; &quot;Hello&quot;.substring(2, 4);// &quot;ll&quot; [)的关系 去除首尾空白字符使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n： &quot; \\tHello\\r\\n &quot;.trim(); // &quot;Hello&quot; 注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。 另一个strip()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除： &quot;\\u3000Hello\\u3000&quot;.strip(); // &quot;Hello&quot; &quot; Hello &quot;.stripLeading(); // &quot;Hello &quot; &quot; Hello &quot;.stripTrailing(); // &quot; Hello&quot; String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串： &quot;&quot;.isEmpty(); // true，因为字符串长度为0 &quot; &quot;.isEmpty(); // false，因为字符串长度不为0 &quot; \\n&quot;.isBlank(); // true，因为只包含空白字符 &quot; Hello &quot;.isBlank(); // false，因为包含非空白字符 替换子串要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换： String s = &quot;hello&quot;; s.replace(&#39;l&#39;, &#39;w&#39;); // &quot;hewwo&quot;，所有字符&#39;l&#39;被替换为&#39;w&#39; s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot; 另一种是通过正则表达式替换： String s = &quot;A,,B;C ,D&quot;; s.replaceAll(&quot;[\\\\,\\\\;\\\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot; 上面的代码通过正则表达式，把匹配的子串统一替换为&quot;,&quot;。关于正则表达式的用法我们会在后面详细讲解。 分割字符串要分割字符串，使用split()方法，并且传入的也是正则表达式： String s = &quot;A,B,C,D&quot;; String[] ss = s.split(&quot;\\\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;} 拼接字符串拼接字符串使用静态方法join()，它用指定的字符串连接字符串数组： String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}; String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; 格式化字符串字符串提供了formatted()方法和format()静态方法，可以传入其他参数，替换占位符，然后生成新的字符串： public class Main { public static void main(String[] args) { String s = &quot;Hi %s, your score is %d!&quot;; System.out.println(s.formatted(&quot;Alice&quot;, 80)); System.out.println(String.format(&quot;Hi %s, your score is %.2f!&quot;, &quot;Bob&quot;, 59.5)); } } 有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有： %s：显示字符串； %d：显示整数； %x：显示十六进制整数； %f：显示浮点数。 占位符还可以带格式，例如%.2f表示显示两位小数。如果你不确定用啥占位符，那就始终用%s，因为%s可以显示任何数据类型。 类型转换要把任意基本类型或引用类型转换为字符串，可以使用静态方法valueOf()。这是一个重载方法，编译器会根据参数自动选择合适的方法： String.valueOf(123); // &quot;123&quot; String.valueOf(45.67); // &quot;45.67&quot; String.valueOf(true); // &quot;true&quot; String.valueOf(new Object()); // 类似java.lang.Object@636be97c 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为int类型： int n1 = Integer.parseInt(&quot;123&quot;); // 123 int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255 把字符串转换为boolean类型： boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false 转换为char[]String和char[]类型可以互相转换，方法是： char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[] String s = new String(cs); // char[] -&gt; String 如果修改了char[]数组，String并不会改变 public class Main { public static void main(String[] args) { char[] cs = &quot;Hello&quot;.toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = &#39;X&#39;; System.out.println(s); } } 这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。 字符编码ASCII编码占用一个字节，编码范围从0到127，最高位始终为0。例如，字符&#39;A&#39;的编码是0x41，字符&#39;1&#39;的编码是0x31。 把汉字也纳入计算机编码，很显然一个字节不够。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字&#39;中&#39;的GB2312编码是0xd6d0。 类似的，日文有Shift_JIS编码，这些编码因为标准不统一，同时使用，就会产生冲突。为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。 Unicode编码需要两个或者更多字节表示，我们可以比较中英文字符在ASCII、GB2312和Unicode的编码： 英文字符&#39;A&#39;的ASCII编码和Unicode编码： ┌────┐ ASCII: │ 41 │ └────┘ ┌────┬────┐ Unicode: │ 00 │ 41 │ └────┴────┘ 英文字符的Unicode编码就是简单地在前面添加一个00字节。 中文字符&#39;中&#39;的GB2312编码和Unicode编码： ┌────┬────┐ GB2312: │ d6 │ d0 │ └────┴────┘ ┌────┬────┐ Unicode: │ 4e │ 2d │ └────┴────┘ 因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符&#39;A&#39;的UTF-8编码变为0x41，正好和ASCII码一致，而中文&#39;中&#39;的UTF-8编码为3字节0xe4b8ad。 UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。 在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做： byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐 byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换 byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换 byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 注意：转换编码后，就不再是char类型，而是byte类型表示的数组。 如果要把已知编码的byte[]转换为String，可以这样做： byte[] b = ... String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换 String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 始终牢记：Java的String和char在内存中总是以Unicode编码表示。 小结 Java字符串String是不可变对象； 字符串操作不改变原字符串内容，而是返回新字符串； 常用的字符串操作：提取子串、查找、替换、大小写转换等； Java使用Unicode编码表示String和char； 转换编码就是将String和byte[]转换，需要指定编码； 转换为byte[]时，始终优先考虑UTF-8编码。 StringBuilderJava编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。 考察下面的循环代码： String s = &quot;&quot;; for (int i = 0; i &lt; 1000; i++) { s = s + &quot;,&quot; + i; } 虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： StringBuilder sb = new StringBuilder(1024); for (int i = 0; i &lt; 1000; i++) { sb.append(&#39;,&#39;); sb.append(i); } String s = sb.toString(); StringBuilder还可以进行链式操作： public class Main { public static void main(String[] args) { var sb = new StringBuilder(1024);//类型的名字太长，写起来比较麻烦,如果想省略变量类型，可以使用var关键字,编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder sb.append(&quot;Mr &quot;) .append(&quot;Bob&quot;) .append(&quot;!&quot;) .insert(0, &quot;Hello, &quot;); System.out.println(sb.toString()); //Hello, Mr Bob! } } 如果我们查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。 仿照StringBuilder，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器： public class Main { public static void main(String[] args) { Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value());//19 } } class Adder { private int sum = 0; public Adder add(int n) { sum += n; return this; } public Adder inc() { sum ++; return this; } public int value() { return sum; } } 注意：对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。 StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。 StringJoiner用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事： public class Main { public static void main(String[] args) { String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; var sj = new StringJoiner(&quot;, &quot;); //需要给StringJoiner指定“开头”和“结尾”： var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;); for (String name : names) { sj.add(name); } System.out.println(sj.toString());//Bob, Alice, Grace System.out.println(sj.toString());//Hello Bob, Alice, Grace! } } 查看源码，可以发现，StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。 String.join()String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便： String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; var s = String.join(&quot;, &quot;, names); 包装类型Java的数据类型分两种： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： String s = null; int n = null; // compile error! 如何把一个基本类型视为对象（引用类型）？ 比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）： public class Integer { private int value; public Integer(int value) { this.value = value; } public int intValue() { return this.value; } } 定义好了Integer类，我们就可以把int和Integer互相转换： Integer n = null; Integer n2 = new Integer(99); int n3 = n2.intValue(); 实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 我们可以直接使用，并不需要自己去定义： public class Main { public static void main(String[] args) { int i = 100; // 通过new操作符创建Integer实例(不推荐使用,会有编译警告): Integer n1 = new Integer(i); // 通过静态方法valueOf(int)创建Integer实例: Integer n2 = Integer.valueOf(i); // 通过静态方法valueOf(String)创建Integer实例: Integer n3 = Integer.valueOf(&quot;100&quot;); System.out.println(n3.intValue()); } } Auto BoxingJava编译器可以帮助我们自动在int和Integer之间转型： Integer n = 100; // 编译器自动使用Integer.valueOf(int) int x = n; // 编译器自动使用Integer.intValue() 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException。 不变类所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下： public final class Integer { private final int value; } 因此，一旦创建了Integer对象，该对象就是不变的。 对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较 public class Main { public static void main(String[] args) { Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(&quot;x == y: &quot; + (x==y)); // true System.out.println(&quot;m == n: &quot; + (m==n)); // false System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true } } 较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 进制转换最常用的静态方法parseInt()可以把字符串解析成一个整数： int x1 = Integer.parseInt(&quot;100&quot;); // 100 int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析 Integer还可以把整数格式化为指定进制的字符串： public class Main { public static void main(String[] args) { System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制 System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制 System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制 System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制 System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制 } } 注意：上述方法的输出都是String 我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。 这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。 Java的包装类型还定义了一些有用的静态变量 // boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段: Boolean t = Boolean.TRUE; Boolean f = Boolean.FALSE; // int可表示的最大/最小值: int max = Integer.MAX_VALUE; // 2147483647 int min = Integer.MIN_VALUE; // -2147483648 // long类型占用的bit和byte数量: int sizeOfLong = Long.SIZE; // 64 (bits) int bytesOfLong = Long.BYTES; // 8 (bytes) 最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： // 向上转型为Number: Number num = new Integer(999); // 获取byte, int, long, float, double: byte b = num.byteValue(); int n = num.intValue(); long ln = num.longValue(); float f = num.floatValue(); double d = num.doubleValue(); 处理无符号整型在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。 例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int： public class Main { public static void main(String[] args) { byte x = -1; byte y = 127; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(y)); // 127 } } 类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。 JavaBean在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 如果读写方法符合以下这种命名规范： // 读方法: public Type getXyz() // 写方法: public void setXyz(Type value) 那么这种class被称为JavaBean 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz()。 boolean字段比较特殊，它的读方法一般命名为isXyz()： // 读方法: public boolean isChild() // 写方法: public void setChild(boolean value) 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 属性只需要定义getter和setter方法，不一定需要对应的字段。例如，child只读属性定义如下： public class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } public boolean isChild() { return age &lt;= 6; } } 可以看出，getter和setter也是一种数据封装的方法。 枚举类在Java中，我们可以通过static final来定义常量。使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。 enum为了让编译器能自动检查某个值在枚举的集合内，并且不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(&quot;Work at home!&quot;); } else { System.out.println(&quot;Work at office!&quot;); } } } enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT; } 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过： int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator &#39;==&#39; } 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值： Weekday x = Weekday.SUN; // ok! Weekday y = Color.RED; // Compile error: incompatible types 这就使得编译器可以在编译期自动检查出所有可能的潜在错误。 enum的比较使用enum定义的枚举类是一种引用类型。引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： if (day == Weekday.FRI) { // ok! } if (day.equals(Weekday.SUN)) { // ok, but more code! } enum类型通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 例如，我们定义的Color枚举类： public enum Color { RED, GREEN, BLUE; } 编译器编译出的class大概就像这样： public final class Color extends Enum { // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() {} } 因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法： name():返回常量名，例如： String s = Weekday.SUN.name(); // &quot;SUN&quot; ordinal():返回定义的常量的顺序，从0开始计数，例如： int n = Weekday.MON.ordinal(); // 1 改变枚举常量定义的顺序就会导致ordinal()返回值发生变化。如果在代码中编写了类似if(x.ordinal()==1)这样的语句，就要保证enum的枚举顺序不能变。新增的常量必须放在最后。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且给每个枚举常量添加字段： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { System.out.println(&quot;Work at home!&quot;); } else { System.out.println(&quot;Work at office!&quot;); } } } enum Weekday { MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);//每个枚举值都是class实例 public final int dayValue; private Weekday(int dayValue) { this.dayValue = dayValue; } } 注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！ 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); } else { System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); } } } enum Weekday { MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) { this.dayValue = dayValue; this.chinese = chinese; } @Override public String toString() { return this.chinese; } } 覆写toString()的目的是在输出时更有可读性。 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！ switch最后，枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比int、String类型更适合用在switch语句中： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); break; case SAT: case SUN: System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); break; default: throw new RuntimeException(&quot;cannot process &quot; + day); //加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。 } } } enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN; } 小结Java使用enum定义枚举类型，它被编译器编译为final class Xxx extends Enum { … }； 通过name()获取常量定义的字符串，注意不要使用toString()； 通过ordinal()返回常量定义的顺序（无实质意义）； 可以为enum编写构造方法、字段和方法 enum的构造方法要声明为private，字段强烈建议声明为final； enum适合用在switch语句中。 BigInteger在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。 如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数,对BigInteger做运算的时候，只能使用实例方法，例如，加法运算： BigInteger i1 = new BigInteger(&quot;1234567890&quot;); BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;); BigInteger sum = i1.add(i2); // 12345678902469135780 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。也可以把BigInteger转换成long型: BigInteger i = new BigInteger(&quot;123456789000&quot;); System.out.println(i.longValue()); // 123456789000 System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range 使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException。 可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。如果BigInteger的值甚至超过了float的最大范围（3.4*10^38),那么返回的float是Infinity 。 BigDecimalBigDecimal可以表示一个任意大小且精度完全准确的浮点数。 BigDecimal bd = new BigDecimal(&quot;123.4567&quot;); System.out.println(bd.multiply(bd)); // 15241.55677489 BigDecimal用scale()表示小数位数，例如 BigDecimal d1 = new BigDecimal(&quot;123.45&quot;); System.out.println(d1.scale()); // 2,两位小数 通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal： BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;); BigDecimal d2 = d1.stripTrailingZeros(); System.out.println(d1.scale()); // 4 System.out.println(d2.scale()); // 2,因为去掉了00 BigDecimal d3 = new BigDecimal(&quot;1234500&quot;); BigDecimal d4 = d3.stripTrailingZeros(); System.out.println(d3.scale()); // 0 System.out.println(d4.scale()); // -2，表示这个数是个整数，并且末尾有2个0 可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断： public class Main { public static void main(String[] args) { BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); } } 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： BigDecimal d1 = new BigDecimal(&quot;123.456&quot;); BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;); BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入 BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 还可以对BigDecimal做除法的同时求余数： public class Main { public static void main(String[] args) { BigDecimal n = new BigDecimal(&quot;12.345&quot;); BigDecimal m = new BigDecimal(&quot;0.12&quot;); BigDecimal[] dr = n.divideAndRemainder(m); System.out.println(dr[0]); // 102 System.out.println(dr[1]); // 0.105 } } 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： BigDecimal n = new BigDecimal(&quot;12.75&quot;); BigDecimal m = new BigDecimal(&quot;0.15&quot;); BigDecimal[] dr = n.divideAndRemainder(m); if (dr[1].signum() == 0) { // n是m的整数倍 } 比较BigDecimal比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等。 必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！ BigDecimal d1 = new BigDecimal(&quot;123.456&quot;); BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;); System.out.println(d1.equals(d2)); // false,因为scale不同 System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2 System.out.println(d1.compareTo(d2)); // 0 常用工具类MathMath类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算 生成一个随机数x，x的范围是0 &lt;= x &lt; 1： Math.random(); // 0.53907... 每次都不一样 如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下： // 区间在[MIN, MAX)的随机数 public class Main { public static void main(String[] args) { double x = Math.random(); // x的范围是[0,1) double min = 10; double max = 50; double y = x * (max - min) + min; // y的范围是[10,50) long n = (long) y; // n的范围是[10,50)的整数 System.out.println(y); System.out.println(n); } } Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 RandomRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： Random r = new Random(); r.nextInt(); // 2071575453,每次都不一样 r.nextInt(10); // 5,生成一个[0,10)之间的int ...... 每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。 这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列 Random r = new Random(12345); 前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。 SecureRandomSecureRandom就是用来创建安全的随机数的： SecureRandom sr = new SecureRandom(); System.out.println(sr.nextInt(100)); 实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： public static void main(String[] args) { SecureRandom sr = null; try { sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 } catch (NoSuchAlgorithmException e) { sr = new SecureRandom(); // 获取普通的安全随机数生成器 } byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); } SecureRandom`的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶（七）","slug":"Python入门与进阶（七）","date":"2020-06-03T11:58:48.000Z","updated":"2020-06-03T12:06:08.926Z","comments":true,"path":"2020/06/03/Python入门与进阶（七）/","link":"","permalink":"/2020/06/03/Python入门与进阶（七）/","excerpt":"","text":"本章节我们揭开Python进阶部分的高级特性，详细讲解枚举、闭包，并对函数式编程做出介绍 枚举枚举是一个类from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 print(VIP.YELLOW) #VIP.YELLOW 打印出的是名字，类型是enum VIP VIP.YELLOW = 6 #会报错 ，不可更改 for v in VIP #for v in VIP.__members__: 把标签的别名也遍历得到 print(v) #枚举的遍历 枚举和普通类相比的优势 如果没有枚举类,在模块中通过变量表示枚举类型 yellow = 1 #法一 green = 2 {&#39;yellow&#39;:1,&#39;green:2&#39;} #法二 class TypeDiamond(): #法三 yellow = 1 green = 2 字典和类都是可变的。没有防止相同值的功能 枚举类型、枚举名称与枚举值print(VIP.YELLOW.value)获取枚举值 #6 print(VIP.YELLOW.name) 获取枚举名字 #YELLOW print(VIP[&#39;GREEN&#39;]) 获取枚举类型 #VIP.GREEN 枚举 比较运算from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 result = VIP.GREEN == VIP.BLACK #False result = VIP.GREEN == 2 #虽然不报错，但显示False 枚举类型直接不能做大小比较 枚举注意事项 其标签值不可修改 其不允许相同标签 其标签不支持大于小于比较符 其若有多个标签是同值的，则后续的都看做第一个标签的别名。在遍历枚举类时，别名不会被打印出来 其不允许实例化 @unique 装饰器，则不允许标签同值 枚举转换数据库中存储枚举类型最好采用值（数字） 代码中不建议用数值，建议用枚举类if a == VIP.YELLOW from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 把数字转为枚举数据类型 a = 1 print(VIP(a)) from enum import Enum, unique # 如果枚举类继承的是IntEnum，则标签值只允许为int类型 from enum import IntEnum # @unique 加上这个，则不允许标签同值 class VIP(Enum): Yellow = 1 Yellow_ALIAS = 1 # Yellow = 2 # 报错，枚举类不允许相同标签 Green = 2 Black = 3 class VIP1(Enum): Yellow = 1 Yellow_ALIAS = 1 Green = 2 Black = 3 class Common: Yellow = 1 Black = 3 Red = 4 print(&#39;-------枚举类型及值-------&#39;) print(VIP.Yellow) print(VIP[&#39;Yellow&#39;]) print(VIP.Yellow.name) print(type(VIP.Yellow)) print(type(VIP[&#39;Yellow&#39;])) print(type(VIP.Yellow.name)) print(&#39;-------枚举类型与普通类对比-------&#39;) print(VIP.Yellow.value) print(Common.Yellow) Common.Yellow = 2 # VIP.Yellow=2 # 报错，枚举类不可修改 # 遍历枚举类——Yellow_ALIAS不会被打印 print(&#39;-------for v in VIP-------&#39;) for v in VIP: print(v) # Yellow_ALIAS会被打印 print(&#39;-------for v in VIP.__members__-------&#39;) for v in VIP.__members__: print(v) print(&#39;-------for v in VIP.__members__.items()-------&#39;) for v in VIP.__members__.items(): print(v) print(&#39;-------成员变量的别名及比较运算符-------&#39;) print(VIP.Yellow_ALIAS) print(VIP.Yellow is VIP.Yellow_ALIAS) print(VIP.Yellow == VIP.Yellow_ALIAS) print(VIP.Yellow == VIP1.Yellow_ALIAS) # print(VIP.Yellow&lt;VIP.Black) # 报错，枚举类不支持大于小于运算符 print(&#39;-------枚举转换-------&#39;) a = 1 print(VIP(a)) # 输出结果 -------枚举类型及值------- VIP.Yellow VIP.Yellow Yellow &lt;enum &#39;VIP&#39;&gt; &lt;enum &#39;VIP&#39;&gt; &lt;class &#39;str&#39;&gt; -------枚举类型与普通类对比------- 1 1 -------for v in VIP------- VIP.Yellow VIP.Green VIP.Black -------for v in VIP.__members__------- Yellow Yellow_ALIAS Green Black -------for v in VIP.__members__.items()------- (&#39;Yellow&#39;, &lt;VIP.Yellow: 1&gt;) (&#39;Yellow_ALIAS&#39;, &lt;VIP.Yellow: 1&gt;) (&#39;Green&#39;, &lt;VIP.Green: 2&gt;) (&#39;Black&#39;, &lt;VIP.Black: 3&gt;) -------成员变量的别名及比较运算符------- VIP.Yellow True True False -------枚举转换------- VIP.Yellow 扩展： from enum import IntEnum，unique #强制要求值是数字,限制值不能相同 加强设计模式的学习,进阶学习 闭包函数：其他语言中，函数只是一段可执行的代码，并不是对象，不能实例化。 在python中，一切皆对象。可以把函数赋给一个变量，可以把一个函数当做另一个函数的参数 示例： def curve_pre(): #调用curve_pre函数，拿到的是一个函数结果 a = 25 def curve(x): return a*x*x return curve #把curve函数作为结果返回给curve_pre f = curve_pre() print(f(2)) #100 def curve_pre(): #调用curve_pre函数，拿到的是一个函数结果 a = 25 def curve(x): return a*x*x return curve #把curve函数作为结果返回给curve_pre实际是返回了闭包 a = 10 f = curve_pre() print(f(2)) #100 没有取a=10来运算（闭包的取值） 闭包定义 闭包 = 函数 + 环境变量 （环境变量必须函数定义时的外部变量，且不为全局变量） 闭包的意义：把函数调用的现场保护起来了，不受外部变量的影响 闭包的经典误区def f1(): a = 10 def f2(): a = 20 #a被ptython认为是一个局部变量，此时并不引用外面的环境变量，因此不是闭包 print(a) #20 print(a) #10 第一次打印 f2() #执行f2,a=20 print(a) #10内部的a(局部变量)不会影响外部的a f1() #1.执行 f1,开始调用f1函数 结论：如果没有在函数中引用全局变量，或者仅引用局部变量，都不会形成闭包 练习： 编写函数，得到旅行者的位置（关键需要保存上一次函数调用的结果状态） 非闭包方法 代码质量不高，在函数内部定义全局变量，代码自封性不强（因为可能其他代码段也会改变全局变量） #编写函数，得到旅行者的位置 #关键需要保存上一次函数调用的结果状态 origin = 0 def go(step): global origin #声明origin是全局变量 new_pos = origin + step origin = new_pos #python认为等号左边origin此时是局部变量，是存在的， #不会在外面引用,解决方法：增加global origin return new_pos print(go(2)) print(go(3)) print(go(6)) 闭包方法： origin = 0 #这是工厂模式 def factory(pos): #参数是当前旅行者正处于的位置,pos是环境变量，有保存现场功能 def go(step): nonlocal pos #强制让pos不是局部变量 new_pos = pos +step pos = new_pos #pos此时会认为是局部变量 return new_pos return go tourist = factory(origin) print(tourist(2)) print(tourist(3)) print(tourist(5)) 函数式编程本章节进一步介绍函数式编程的lambda、mapeduce、filter以及装饰器 匿名函数：lambda表达式 def add(x, y): return x+y ---------用匿名函数实现-------------- #lambda parameter_list: expression #不能再表达式中用代码块（如赋值语句等） f = lambda x,y: x+y f(1,2) #匿名函数的调用 --------配合正则表达式使用会更方便------ 三元表达式其他语言：a &gt; y ? x : y 判断条件？结果1：结果2 python:条件为真时返回的结果 if 条件判断 else 条件为假时返回的结果 x if x&gt;y else y map闭包不建议在业务代码使用，在架构编写方面可以推荐。 map推荐在python中多使用 list_x = [1,2,3,4,5,6,7,8] def square(x): return x*x -------使用for循环------ for x in list_x: square(x) --------使用map------ r = map(square,list_x) print(r) #map对象 print(list(r)) map函数映射，把原来集合元素通过函数关系映射到另一个集合。 --------使用map和lambda精简-------- r = map(lambda x: x*x,list_x) #map多参数的传入， #x,y参数个数要相等，否则结果有缺失 list_x = [1,2,3,4,5,6,7,8] list_y = [1,2,3,4,5,6,7,8] r = map(lambda x,y: x*x+y,list_x,list_y) reducefrom functools import reduce #连续计算，连续调用lambda 每一次lamnda的计算结果将作为下一次表达式的参数作为运算，直至遍历结果 list_x = [1,2,3,4,5,6,7,8] r = reduce(lambda x,y: x+y,list_x) print(r) 1+2 3（上一次表达式的结果）+3 6+4 ((((1+2)+3)+4)+5) ... lambda是联系计算，计算操作表达式内定义 扩展：大数据计算模型（map/reduce） 映射 规约 并行计算 filter#filter list_x = [1, 0, 1, 0, 0, 1] r = filter(lambda x:True if x == 1 else False, list_x) print(list(r)) 命令式编程vs函数式编程命令式编程关键点： def if else for 函数式编程： map reduce filter lambda算子 lisp 函数式编程的鼻祖 装饰器import time def f1(): print(time.time()) #结果是unix时间戳，1591168510.2112603 print(&#39;This is a function&#39;) #如果有100个函数，都需要自带打印时间的功能。 #原则：当需求产生变更的时候，尽量不改变函数、对象或类下面的具体实现 #对修改是封闭的，对扩展是开放的 f1() 解决方案： import time def f1(): print(&#39;This is a function&#39;) #如果有100个函数，都需要自带打印时间的功能。 #原则：当需求产生变更的时候，尽量不改变函数、对象或类下面的具体实现 #对修改是封闭的，对扩展是开放的 def f2(): print(&#39;This is a function&#39;) def print_current_time(func): print(time.time()) func() print_current_time(f1) print_current_time(f2) 上述缺点：新增的功能是属于每个函数的，最好能和原来的函数绑定 改进： import time #装饰器结构 def decorator(func): def wrapper(): print(time.time()) func() return wrapper def f1(): print(&#39;this is a function&#39;) f = decorator(f1) #改变了调用方式 f() 改进： import time #装饰器结构 def decorator(func): def wrapper(): print(time.time()) func() return wrapper @decorator #语法糖，不改变原来的调用方式 def f1(): print(&#39;this is a function&#39;) f1() #不改变原来的调用方式 体现了AOP的设计思想 支持不同参数： import time #装饰器结构 def decorator(func): def wrapper(*args): #支持不同参数的个数 print(time.time()) func(*args) return wrapper @decorator #不改变原来的调用方式 def f1(func_name): print(&#39;this is a function&#39;+func_name) @decorator #不改变原来的调用方式 def f2(func_name1,func_name2): print(&#39;this is a function&#39;+func_name1) f1(&#39;test func&#39;) f2(&#39;test func1&#39;,&#39;test func2&#39;)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶（六）","slug":"Python入门与进阶（六）","date":"2020-06-01T14:35:21.000Z","updated":"2020-06-01T14:41:03.744Z","comments":true,"path":"2020/06/01/Python入门与进阶（六）/","link":"","permalink":"/2020/06/01/Python入门与进阶（六）/","excerpt":"","text":"正则表达式也是文本解析中非常重要的知识点。本章我们将讲解什如何在Python中编写正则表达式与常见的正则表达式。此外，JSON作为非常重要的数据格式，我们会重点讲解，包括JSON对象，JSON字符串，Python类型与JSON的转换。 正则表达式初识正则表达式是一个特殊的字符序列，检测一个字符串是否与我们所设定的这样的字符序列相匹配。如果匹配，帮助我们快速检索文本，实现一些替换文本的操作。可以用正则表达式来1.检测一串数字是否是电话号码2.检测一个字符串是都符合email3.把一个文本里指定的单词替换为另一个单词等等 例：判断A中是否含python A = &#39;C|C++|Java|Python|Javascript&#39; #我们可以采用python中的内置函数,优先考虑内置函数 print(A.index(&#39;Python&#39;)&gt;-1) #True print(&#39;Python&#39; in A) #True 采用正则表达式 import re A = &#39;C|C++|Java|Python|Javascript&#39; #re.findall(&#39;正则表达式&#39;, A) #A是要匹配的字符串 r = re.findall(&#39;Python&#39;, A) #A是要匹配的字符串,r是列表 #print(r) #返回结果是一个列表 if len(r) &gt; 0 print(&#39;字符串中包含Python&#39;) 元字符与普通字符普通字符：正常文本字符，如上例中的’python’ 元字符：在正则表达式中具有特殊意义的专用字符,如‘\\d’。 示例： #找出A中的所有数字 import re A = &#39;C0C++34Java5Python56Javascript&#39; r = re.findall(&#39;\\d&#39;, A) #A是要匹配的字符串 print(r) #返回结果是一个列表 正则表达式全集 字符集#找出中间字母是c到f的单词 import re S = &#39;abc,acc,adc,aec,afc,ahc&#39; r = re.findall(&#39;a[c-f]c&#39;, S) #A是要匹配的字符串 print(r) #返回结果是一个列表 字符 含义 [] 或 () 分组，且 [^] 非 ^ 开头 $ 结尾 [a-b] 数字或字母范围 概括字符集 字符 含义 . 除换行之外的所有字符 \\d 数字 \\D 非数字 \\s 空白字符 \\S 非空白字符 \\w 下划线、字母、数字 \\W 非下划线、字母、数字 \\w即[0-9A-Za-z_]，\\W匹配任何非单词字符。等价于[^A-Za-z0-9_]。概括字符集表述更加简洁 数量词import re S = &#39;python 1111java6784php&#39; #提取3个单词 #r = re.findall(&#39;[a-z]{3}&#39;, S) #匹配a-z的数量是固定的3个 r = re.findall(&#39;[a-z]{3,6}&#39;, S) print(r) #返回结果是一个列表，[&#39;python&#39;, &#39;java&#39;, &#39;php&#39;] #问题：为什么匹配到3字符的时候不输出pyt,而是到python? #解：贪婪 贪婪与非贪婪数量词有贪婪和非贪婪之分，默认情况下是贪婪的方式 贪婪：数量词限定在一个区间之内，python倾向于尽可能多的取最大的值，一直到某个字符不满足条件时停止 非贪婪：[a-z]{3,6}? 匹配0次1次或者无限多次import re S = &#39;pytho1python6pythonn&#39; #*匹配0次或者无限多次 [&#39;pytho&#39;, &#39;python&#39;, &#39;pythonn&#39;] #+匹配1次或者无限多次 [&#39;python&#39;, &#39;pythonn&#39;] #？匹配0次或者1次 [&#39;pytho&#39;, &#39;python&#39;, &#39;python&#39;] 会把正确的匹配结果纳入（可用来去重） r = re.findall(&#39;python*&#39;, S) print(r) #返回结果是一个列表 字符 含义 {a,b} 指定前一个字符的出现次数(贪婪) * 前面的一个字符出现0到n次 + 前面的一个字符出现1到n次 ? 前面的一个字符出现0到1次 边界匹配符^ $ import re qq = &#39;10000013332&#39; #要求qq在4-8位 r = re.findall(&#39;^\\d{4,8}$&#39;, qq) #^从字符串的开始匹配，$从字符串的末尾开始匹配 print(r) #返回结果是一个列表 组import re A = &#39;PythonPythonPythonPythonPython&#39; #要求判断字符串里是否包含3个python r = re.findall(&#39;(Python){3}&#39;, A) #括号括起来成为组，一组的字符重复3次 print(r) #返回结果是一个列表 [abc]或关系，（ABC）组关系 匹配模式参数r = re.findall(&#39;正则表达式&#39;, 字符串，模式1|模式2)多个模式用|连在一起 匹配 findall 格式：re.findall(子串,主串[,模式|模式2...])功能：匹配返回：以列表形式，返回匹配到的子串说明：模式中\\|表示且 字符 含义 re.I 忽视大小写 re.S 使 . 匹配包括换行在内的所有字符，改变.号的行为 re模块下的其他正则表达式re.sub格式：re.sub(原内容，新内容/函数，主串，替换次数)功能：替换返回：返回新的主串说明：替换次数为0表全体换，为n表示替换n个 #示例 import re language = &#39;PythonC#JavaPHPC#&#39; r = re.sub(&#39;C#&#39;,&#39;Go&#39;,language,1) print(r) #PythonGoJavaPHPC# 进阶： 动态替换，根据不同的匹配结果进行不同的替换 &lt;re.Match object; span=(6, 8), match=’C#’&gt; 返回的第一个C#之前有6个字符，自己占7,8 import re def convert(value): #print(value) matched = value.group() return &#39;!!&#39; + matched + &#39;!!&#39; language = &#39;PythonC#JavaPHPC#&#39; r = re.sub(&#39;C#&#39;,convert,language) print(r) #Python!!C#!!JavaPHP!!C#!! 把函数作为参数传递的作用import re a = &#39;A8C3721D86&#39; #找出所有数字，&gt;=6的统一替换成9,&lt;6替换成0 def convert(value): matched = value.group() if int(matched) &gt;= 6: #默认字符串形式存储 return &#39;9&#39; else: return &#39;0&#39; r = re.sub(&#39;\\d&#39;, convert, a) print(r) # A9C0900D99 search与match函数match、search、findall用法区别 match 格式：re.match(子串,主串)功能：匹配（仅匹配一个）说明：从首字符开始匹配，若没找到对应的结果返回空,若想获取返回Match对象转为值，则用group()方法 search 格式：re.search(子串,主串)功能：匹配到一个结果（仅匹配一个），就返回结果.若想获取返回Match对象转为值，则用group()方法 match、search的比较示例代码： import re a = &#39;A8C3721D86&#39; r1 = re.match(&#39;\\d&#39;, a) print(r1) r2 = re.search(&#39;\\d&#39;, a) print(r2) # 输出结果 None &lt;re.Match object; span=(1, 2), match=&#39;8&#39;&gt; match、search、findall的比较示例代码： import re a = &#39;8C3721D86&#39; r1 = re.match(&#39;\\d&#39;, a) print(r1) r2 = re.search(&#39;\\d&#39;, a) print(r2) r3 = re.findall(&#39;\\d&#39;, a) print(r3) # 输出结果 &lt;re.Match object; span=(0, 1), match=&#39;8&#39;&gt; &lt;re.Match object; span=(0, 1), match=&#39;8&#39;&gt; [&#39;8&#39;, &#39;3&#39;, &#39;7&#39;, &#39;2&#39;, &#39;1&#39;, &#39;8&#39;, &#39;6&#39;] group分组 函数 功能 .group() 用来提取出分组截获的字符串 .span() 返回匹配到的子串在主串中的位置 import re s = &#39;life is short,i use python&#39; r = re.search(&#39;life(.*)python&#39;,s) print(r.group(1)) #获取分组的匹配 #0永远记录正则表达式的完整匹配结果 用findall import re s = &#39;life is short,i use python&#39; r = re.findall(&#39;life(.*)python&#39;,s) print(r) #获取分组的匹配 理解JSONJavaScript Object Notation JavaScript对象标记 JSON是一种轻量级的数据交换格式。 JSON载体：JSON字符串，字符串是json的表现形式 JSON优势：易于阅读、易于解析、网络传输效率高，适合跨语言交换数据 JSON字符串：是指符合JSON格式的字符串 注意：JSON中只能使用双引号，轻量相对于xml而言，符合JSON格式的字符串叫做JSON字符串 json是一种数据格式，适合跨语言交换数据 反序列化和序列化由字符串到语言下的某一数据结构叫反序列化 python字典转化为字符串 JSON函数 函数 功能 json.loads(json字符串) 反序列化，JSON字符串转Python对象 json.dumps(python对象) 序列化，Python对象转JSON字符串 JSON与Python类型的对照 JSON Python object dict array list string str number(int) int number(real) float true True flase False null None #反序列化 import json json_str = &#39;{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39; #数字不用加引号 #json有很多数据类型，如数组&#39;[{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18，“},{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}]&#39; #把json字符串转换成python自己的数据类型(字典) student = json.loads(json_str) print(type(student)) #dict字典类型 print(student) print(student[&quot;name&quot;]) print(student[&quot;age&quot;]) ******************** json_str = &#39;[{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39;,{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39;] #序列化 import json student = [ {&#39;name&#39;:&#39;qiyue&#39;, &#39;age&#39;:18 ,&#39;flag&#39;:False}, {&#39;name&#39;:&#39;qiyue&#39;, &#39;age&#39;:18} ] #把json字符串转换成对应的python结构(字典) json_str = json.dumps(student) print(type(json_str)) print(json_str) JSON对象，JSON，JSON字符串？ JSON对象在JavaScript中概念成立 JSON有自己的数据类型，虽然它和JavaScript的数据类型有些相似 REST服务的标准格式：JSON","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶（五）","slug":"Python入门与进阶（五）","date":"2020-05-31T02:37:59.000Z","updated":"2020-05-31T02:51:58.133Z","comments":true,"path":"2020/05/31/Python入门与进阶（五）/","link":"","permalink":"/2020/05/31/Python入门与进阶（五）/","excerpt":"","text":"讲解面向对象的概念。包括面向对象的三大特性（继承、封装、多态）、类的基本构成元素、python的内置类属性、方法重写、运算符重载、静态方法等 类的定义class 类名: #类命名建议第一个字母大写，驼峰命名 pass class Student(): name = &#39;&#39; age = 0 def print_file(self): #加固定的参数self，否则会报错,后面会解释 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) 类实例化对象名=类名([实参]) # 形参写在类的构造函数中 演示（在另外一个模块中引用类）： from c1 import Student student1 = Student() #类的实例化 student1.print_file() #调用类下面的方法 note:类的基本作用是封装代码。 方法要加参数self,访问实例变量方式是self.变量 类内部只做定义，不推荐在类内部实例化和调用方法 类中的变量称谓数据成员 方法：设计层面来讲 函数：程序运行，过程式的一种称谓 变量： 变量 访问 实例变量 通过self.变量名访问 类变量 通过cls.变量访问 如果在实例化对象中找不到变量，则会去相应的类中寻找，若也没有，则去所在类的父类中寻找… 在构造函数内，直接通过变量名访问的是形参，而非实例对象。 类与对象类的定义 类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起 对象的定义 对象是实例化的类 构造函数def __init__(self): #构造函数 pass 作用:生成不同的对象 构造函数__init__在实例化类时，将自动调用 构造函数是个实例方法 构造函数只能返回None 对象的参数由构造函数接收，构造函数的第一个参数为self 在构造函数内部，通常初始化类的特征值 class Student(): name = &#39;&#39; age = 0 def __init__(self,name,age): #构造函数 #初始化对象的属性 name = name #wrong age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 #行为与特征 def print_file(self): #加固定的参数，否则会报错 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) student1 = Student(&#39;石敢当&#39;，18) print(student1.name) #这里输出结果是空值，说明构造函数里的赋值并没有改变变量name的取值 释疑： student1 = Student(&#39;石敢当&#39;，18) #print(student1.name) print(student1.__dict__) #__dict__作用保存对象下的所有变量 #输出结果是空子典{}，说明不存在实例变量 类变量和实例变量实例变量和对象相关联。 class Student(): name = &#39;yuyu&#39; #类变量 age = 0 def __init__(self,name,age): #注意是两条下划线 #构造函数 #初始化对象的属性 self.name = name #定义实例变量，和对象相关，与类无关 self.age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 print(self.name) #实例对象的name student1 = Student(&#39;yanglin&#39;, 18) student2 = Student(&#39;yu&#39;, 20) print(student1.name) #此时输出正确结果 yanglin print(student2.name) #yu print(Student.name) #yuyu 类与对象的变量查找顺序 机制：访问一个实例变量，先在对象的实例列表里查找有没有该变量，没有则会去相应的类中寻找，若也没有，则去类的父类中查找…… self与实例方法定义实例方法时，需要参数,调用实例方法时，不需要传参 def __init__(self,name,age): #self可以自己更改，python中建议使用self #构造方法 #初始化对象的属性 self.name = name self.age = age #行为与特征 def print_file(self): #加固定的参数，否则会报错 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) self就是当前调用方法的对象,self代表的是实例不是类 如：sutdent1.print_file() self代表student1 实例方法 # 定义 def funcname(self): pass # 调用 实例.方法() 在实例方法中访问实例变量与类变量方法代表类的行为，变量代表刻画类的特征。方法需要对变量对运算和逻辑上的操作，改变类的特征。 实例方法操作实例变量 self.变量名访问 def __init__(self,name,age): #注意是两条下划线 #构造函数 #初始化对象的属性 self.name = name #定义实例变量，和对象相关，与类无关 self.age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 print(self.name) #实例对象的name 实例方法访问类变量： class Student(): total = 0 def __init__(self): #注意是两条下划线 print(total) #访问错误 ******正确访问类变量的方式1******* print(Student.total) #访问成功 ******正确访问类变量的方式2******* print(self.__class__.total) #访问成功 类方法下面是实例方法改变类变量的例子 class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.__class__.sum += 1 print(&quot;当前班级学生总数为：&quot;+ str(self.__class__.sum)) #每当创建一个学生对象，班级学生总数加一 student1 = Student(&quot;yu&quot;, 18) student2 = Student(&quot;yu1&quot;, 18) student3 = Student(&quot;yu2&quot;, 18) print(Student.sum) 类方法的定义： @classmethod def plus_sum(cls): pass # 调用 类.方法() 上述方法用类方法操作改进: class Student(): sum = 0 name = &#39;&#39; age = 0 def __init__(self, name, age): self.name = name self.age = age @classmethod #类方法 def plus_sum(cls): cls.sum += 1 print(cls.sum) student1 = Student(&quot;yu&quot;, 18) Student.plus_sum() student2 = Student(&quot;yu1&quot;, 18) Student.plus_sum() student3 = Student(&quot;yu2&quot;, 18) Student.plus_sum() 类方法和实例方法的区别：关联的对象不同，一个是类，一个是对象 类方法不能访问实例变量 静态方法 @staticmethod def funcname(parameter_list): pass # 调用 类.方法()或实例.方法() 静态方法可以被对象和类调用 静态方法的内部可以访问类变量 静态方法不能访问实例变量 建议不要经常使用静态方法，和普通的函数基本没有区别 和C#，java中的静态方法有区别 成员可见性：公开与私有 在变量或方法名前加__，则变为私有 细节理解：在创建私有的实例变量时，实际python会把变量名改为_类名__变量名，所以在外部访问私有变量__变量名时，实际是创建了新变量__变量名。但是通过_类名__变量名可以修改和访问！ 建议：对类变量，建议不要直接修改，而是通过方法来修改，这样有利于保护变量 内建属性 内建属性 说明 __class__ 表示实例所在的类 __dict__ 查看类或实例的自定义属性 继承继承from 文件 import 父类 # 子类的定义 class 子类(父类): pass 建议：一个文件夹只写一个类，那么只需在子类文件上写from 文件 import 父类* 多继承：一个子类继承多个父类。python支持多继承 调用父类构造函数 父类： class Human(): sum = 0 def __init__(self, name, age): self.name = name self.age = age def get_name(self): print(self.name) 子类： from c2 import Human class Student(Human): def __init__(self, school, name, age): #注意：这里包含了子类形参和父类形参 self.school = school #self.子类变量=值 # Human.__init__(self, name, age) #子类构造函数中调用父类的构造函数 #父类.__init__(self[,父类形参]) # 注意：这里包含了父类的self及父类形参 #为什么要传self: #上面语句是一个类调用一个实例方法(不合规的)。对象实例化中调用构造函数时，python会自己 #帮我们补全，而普通方法的调用，需要传去全部的参数 super(Student,self).__init__(name,age) #推荐使用 student1 = Student(&#39;china&#39;,&#39;yuyu&#39;, 18) print(student1.name) print(student1.age) print(student1.sum) print(Student.sum) student1.get_name() 细节理解：为什么在上述代码中，父类的构造函数调用需要写self形参，但是实例化父类时，参数中却不需要写self？原因：实例化父类过程中，对于self的指向，会由python帮我们自动完成。而上述代码，并没有实例化父类，python不会帮我们自动完成，而需要我们显式地写出self。 推荐 class 子类(父类): def __init__(self[,子类及父类形参]): self.子类成员变量=值 super(子类,self).__init__(父类形参) 父子方法同名问题若父类和子类具有同名的实例方法，则在调用的是子类的。如果想调用父类同名实例方法，需要在定义子类方法时，加上super(子类,self).方法() ####","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶（四）","slug":"Python入门与进阶（四）","date":"2020-05-30T05:40:46.000Z","updated":"2020-05-30T05:45:36.184Z","comments":true,"path":"2020/05/30/Python入门与进阶（四）/","link":"","permalink":"/2020/05/30/Python入门与进阶（四）/","excerpt":"","text":"包、模块python项目的组织结构 Python包与模块的名字包的名字就是文件夹的名字，模块的名字就是文件的名字 不同包下两个同名的模块区分：包名.模块名 包下面可以包含子包 python如何区分一个普通的文件夹和包：在文件夹下面有一个特殊的文件_init_.py _init_.py这个模块的名字就是包名。 模块导入import模块导入的意义是引用别的模块的组织资源import module_name python导入一个模块时，会执行该模块的代码 语句 功能 import 模块 引入模块 from 包 import 模块/* 引入指定/全部模块 from 模块 import 部分/* 引入模块的指定/全部部分 说明：可以设置星号*所涵盖的内容，在被导入的文件中，设置__all__=[&#39;name1&#39;,&#39;name2&#39;...] import t.c7 #需要引用不同包（t包）下C7模块的a变量 print(t.c7.a) ****************** import c7 #需要同包下C7模块的a变量 print(c7.a) ****************** import t.t1.t2.c7 as m #如果命名空间过长，可以用m（自定义）代替命名，简化引用名 print(m.a) ************************************ from t.c7 import a print(a) #不需要加全部的命名空间 ****************** from t import c7 print(c7.a) ****************** from t.c7 import * #*引入全部部分或指定部分(在被导入的文件中，设置了`__all__=[&#39;name1&#39;,&#39;name2&#39;...]`) print(a) print(b) __init__.py 的用法Python杂谈: init.py的作用 包和模块是不会被重复导入的 避免循环导入（互相导入（形成环）对方的内容） 函数 功能性 隐藏细节 避免编写重复的代码 函数定义 def 函数名(参数列表): ... return 返回值1,返回值2.... 参数列表可以没有 若没写return，则返回None 若return返回多个值，则返回类型为元组 推荐使用变量1,变量2...=函数()的形式获取返回值（序列解包），不推荐使用元组[索引]获取，会降低代码可读性 序列解包a = 1 b = 2 c = 3 #等价于 a,b,c = 1,2,3 d = 1,2,3 #d是tuple类型 a,b,c = d #序列解包。需要注意的是元素的个数要相等 函数参数 类型 格式 说明 必须参数 调用时函数(实参) 形参和实参顺序要求一致 关键字参数 调用时函数(形参=实参) 形参和实参顺序可以不一致 默认参数 函数定义时def 函数名(形参=值) 实参可覆盖默认参数。注意：默认参数需写在形参列表的最后 def add(x, y): #x,y是形参 ······ add(3,2) #3,2是实参 x=3,y=2 add(y=3,x=2) #关键字参数 内置函数 函数 功能 len() 返回元素个数 id() 查看变量内存地址 type() 类型判断 isinstance(变量名,(类型1，类型2..)) 变量是否属于其中的一个类型 input([‘提示语’]) 接收用户输入的信息，返回为 string 类型 round(数值,保留位数) 四舍五入 字符串.index(子串,起始位置,结束位置) 返回开始的索引值，没找到则抛出异常。 主串.replace(‘旧子串’,’新子串’,匹配次数) 替换 字典.get(键名, 默认值) 返回指定键的值，如果不存在则返回默认值 其他 None不是False、&#39;&#39;、0、[]，尤其在判空时需要注意 对象存在不代表其一定为True，对象的bool值由__bool__或__len__内置函数决定 使用\\或()可实现跨行书写","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[]},{"title":"Python入门与进阶（三）","slug":"Python入门与进阶（三）","date":"2020-05-29T13:08:41.000Z","updated":"2020-05-30T05:36:46.879Z","comments":true,"path":"2020/05/29/Python入门与进阶（三）/","link":"","permalink":"/2020/05/29/Python入门与进阶（三）/","excerpt":"","text":"变量变量命名规则 系统关键字不能用在变量名中。 Python中的变量名区分大小写。 变量名由字母，数字，下划线构成，开头不能是数字。 python中不存在变量的定义，变量本身没有类型，一般说把X赋值给变量，不说定义变量为X（动态性语言的特性体现） a = 1 a = &#39;1&#39; a = [1,2,3] 值类型和引用类型a = 1; b = a; a = 3; print(b) #b=1,b的值并没有改变 ********************************** a = [1,2,3] b = a a[0] = &#39;1&#39; print(a) #[&#39;1&#39;,2,3,4,5] print(b) #[&#39;1&#39;,2,3,4,5],此时b改变了 引用类型是可变的，值类型是不可变的 int str tuple值类型(不可改变) list set dict引用类型(可变) a = &#39;hello&#39; id(a) # a = a + &#39;python&#39; id(a) # ******a有不同的id，说明相加后得到的a是新的变量python****** &#39;python&#39;[0] #显示p &#39;python&#39;[0] = a #报错，值类型不可改变 列表和元组的对比元组定义好后就无法改变，列表可更改。 建议用元组 。避免合作开发过程中对方更改造成的报错。 a = (1,2,3,[1,2,4]) #如何访问4 a[3][2] a = (1,2,3,[1,2,[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]]) #访问c a[3][2][2] 运算符算术运算符python中算符运算符并不是只能对数字做运算 +加、-减、*乘、/除、//取整除、%取余、**幂 赋值运算符= +=、-=、*=、/=、//=、%=、**=注意：python中没有自增/自减运算符 c=1 c=c+1等效于c+=1 用法同其他语言 逻辑运算符and与、or或、 not非 主要操作布尔类型 非布尔类型参与运算的结果要根据计算机的运算流程判断 1 and 2 #返回2 ，计算机的运算流程，需要2才能给出结果 1 or 0 #返回1 到1即可给出结果 比较（关系）运算符== != &gt; &lt; &gt;= &lt;= 产生布尔值的运算结果 字符串、列表等均可进行比较 身份运算符 运算符 用法 功能 is 元素 is 序列 检测两个变量身份(内存地址)是否全等 not is 元素 not is 序列 检测两个变量身份(内存地址)是否不等 == 比较值，is 比较身份，类型 type判断 对象三个特征 id 、value、type ******is和==的区别******** a = 1 b = 1.0 a == b #true a is b #false ==比较值是否相等，is比较两个变量的身份（内存地址）是否相等 id(a)和id(b)不等 a = {1,2,3} b = {2,1,3} a == b #True 集合是无序的，所以不会影响最终取值 a is b #False 地址不同 ---------------- c = (1,2,3) d = (2,1,3) c == d #False 元组是序列，有序 c is d #False 内存地址不同 ---------------- 判断变量的类型 isinstance(a,str) #判断a是否是str类型 isinstance(a,(int,str,float)) #判断a是否是下面的三种类型之一 注意：python中没有===运算符 成员运算符 运算符 用法 功能 in 元素 in 序列 检测序列中是否包含指定元素 not in 元素 not in 序列 检测序列中是否不包含指定元素 注意：字典的成员运算符是针对键 b = &#39;c&#39; b in {&#39;c&#39;:1} #true 位运算符&amp;按位与 |按位与 ^按位异或 -按位取反 &lt;&lt; 左移动&gt;&gt;右移动 都是把数字当做二进制数进行运算 表达式运算符优先级 运算符 用法 { } 括号（分组） f(args…) 函数调用 x[index:index] 切片 x[index] 索引值 x.attribute 属性 ** 指数 ~x 取反 +x,-x 正、负值 *、/、% 乘、除、求余 +、- 加、减 &lt;&lt;、&gt;&gt; 左移、右移 &amp; 按位 AND ^ 按位 XOR \\ 按位 OR in、is、is not、&lt; 、&lt;=、&gt;、&gt;=、&lt;&gt;、!=、== 比较、算数、身份 not x 布尔 NOT and 布尔 AND or 布尔 OR lambda lambda 表达式 ******可以通过括号使先后顺序更清楚或强行改变顺序******** not a or b + 2 == c #(not a) or ((b+2) == c) a or b and c #a or (b and c) 语句python中语句不用括号，依据空格和换行分隔。 python没有switch 条件控制if 条件1: 语句 elif 条件2: 语句 else: 语句 pass空语句/占位语句，保持代码结构域的完整性 while循环while 条件： 语句 else: 语句 说明：在条件语句为 false 时，执行 else 的语句块 for循环# 第一种情况 #主要用来遍历/循环 for 元素 in 序列/集合/字典: 语句 else: 语句 # 第二种情况 for 变量 in range(范围): 语句 else: 语句 break跳出循环（内循环），continue停止当前操作，直接继续下面的循环 说明：在for语句遍历完毕时，执行 else 的语句块，并不要求强行使用elserange()的参数说明： range(x)：从0遍历到x，默认偏移量为1（遍历到x之前的数，取不到x,下同） range(x,y)：从x遍历到y，默认偏移量为1 range(x,y,z)：从x遍历到y，偏移量为z。若x&gt;y，则为递减，反之递增 a = [1,2,3,4,5,6,7,8] for i in range(1,len(a),2) print(a[i],end=&#39;|&#39;) *******等效于*********** b = a[0:len(a):2] print(b)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶（二）","slug":"Python入门与进阶（二）","date":"2020-05-26T14:17:38.000Z","updated":"2020-05-30T05:24:41.268Z","comments":true,"path":"2020/05/26/Python入门与进阶（二）/","link":"","permalink":"/2020/05/26/Python入门与进阶（二）/","excerpt":"","text":"代码与写代码代码是现实世界事物在计算机世界中的映射 写代码是将现实世界中的事物用计算机语言来描述 计算机语言的基本数据类型是构成代码的基础。 基本数据类型 Number:数字整数：int 浮点数：float 布尔类型：bool 表示真、假 True、False 复数：complex 其他语言：浮点数有单精度float,双精度double的分别。python中只有float代表浮点数 ​ 整数有short,int,long的分别，python只有int 数值运算 在加减乘计算时，如果有浮点数参与运算，Python会把结果转换成为浮点数。 除法中， / 返回浮点数，// 返回整数(只保留整数部分)。 进制二进制0b开头，八进制0o开头，十六进制0x开头 不同进制间的转换 bin(10) #十进制转二进制 bin(0o7) #八进制转二进制 int(0b111) #二进制转十进制 int(0o77) #八进制转十进制 hex(888) #十进制转十六进制 oct(0x777) #十六进制转八进制 ······ 只要是非0的数都表示布尔真，只有0、空值表示布尔假 bool(2) #True bool(2.2) #True bool(-1.1) #True bool(&#39;abc&#39;) #True bool(0) #False bool(&#39;&#39;) #False bool([]) #False bool(None) #False 函数 描述 int() 转十进制 bin() 转二进制 oct() 转八进制 hex() 转十六进制 ord() 转ascii bool() 转bool（非空、非0、非None，则为True） String字符串单引号、双引号、多行字符串注意引号必须成对出现 &#39;hello world&#39; &quot;hello world&quot; &quot;let&#39;s go&quot; #单双引号是为了在引号中引用引号 &#39;&#39;&#39; hello world &#39;&#39;&#39; #三（单双）引号可以显示多行字符串，print(&quot;hello\\nworld&quot;)有同样效果 &#39;1&#39; #str类型 转移字符特殊的字符：表示无法“看见”的字符、与语言本身语法有冲突的字符 \\n #换行 \\r #回车 \\&#39; #单引号 \\t #横向制表符 print(&#39;c:\\northwind\\northwest&#39;) #输出结果会换行 print(&#39;c:\\\\northwind\\\\northwest&#39;) 或print(r&#39;c:\\northwind\\northwest&#39;) #输出结果c:\\northwind\\northwest #加上r后不是一个普通的字符串，而是一个原始字符串（所见即所得） ······ 字符串运算字符串拼接 &quot;hello&quot;+&quot;world&quot; #输出helloworld 字符串复制 &quot;hello&quot;*n #hello拼接n次 字符串访问 &quot;hello world&quot;[下标a:下标b] #从左往右以0开始，从右往左以-1开始,截取序列的[a,b) &quot;hello world&quot;[n] #从左往右以0开始，反之以-1开始,访问单个字符 #输出world的方法 &quot;hello world&quot;[6:] &quot;hello world&quot;[-5:] 组列表list[1,2,3,4] [&quot;hello&quot;,1.9,True,[1,2]] #列表内部元素的类型不是固定的 列表的基本操作 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;][n] #方法同string [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;][a:b] #方法同上 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]+[&quot;pear&quot;,&quot;lemon&quot;] #两个列表合并 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]*3 #重复3次 元组tuple(1,2,3,4) (&quot;hello&quot;,1.9,True,(1,2)) #元组内部元素的类型不是固定的 元组的基本操作 (1,2,3,4)[0] #方法同上 (1,2,3,4)[0:2] (1,2,3)+(4,5,6) (1,2,3)*3 元组和列表的区别元组的元素不能修改，列表的元素可以修改。 注意：当元组内只有一个元素时，其类型是单个元素对应的类型。如（1）为int，（‘asd’）为str。而当列表内只有一个元素时，仍然是list类型。 type((1)) 只有一个元素时，内部的（）做成运算符号处理。若要定义一个只有一个元素的元组，（1，） Python中，str,list,typle都是序列 序列共有特征 #根据序号找值 #根据切片（范围）找值 # *复制 # a not in [序列] 判断元素a是否（不）在序列中 #len(序列) 序列的元素长度 #max(序列) 集合set① 格式{元素1，元素2...}或set(&#39;元素1元素2元素3...&#39;) ② 特性集合是无序的，且元素不重复。 注意：创建空集合必须用 set()而不是 { }，因为 { } 是用来创建一个空字典。 {1,1,1,2,2,3} #最后显示{1,2,3} ③ 操作集合 运算符 功能 - 差集 \\ 并集 &amp; 交集 a ^ b a和b不同时存在的元素 {1,2,3,4,5,6}-{3,4} #{1,2,5,6} {1,2,3,4,5,6}&amp;{3,4} #{3,4} {1,2,3,4,5,6}|{3,4} #{1,2,3,4,5,6,7} 字典Dictionary① 格式{‘键1’:’值1’,’键2’:’值2’…} {&#39;w&#39;:&#39;上&#39;,&#39;a&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;} ② 特性 键名不可以重复，若重复，后面的值会替换前面相同的键名；键名为不可变类型，可以为number、string、tuple类型。 ③ 操作字典 操作 功能 字典[键名] 访问字典中的某个元素值 {&#39;w&#39;:&#39;上&#39;,&#39;a&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[&#39;w&#39;] #访问得到上 {1:&#39;上&#39;,&#39;1&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[1] #显示上 {1:&#39;上&#39;,&#39;1&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[&#39;1&#39;] #显示左","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶（一）","slug":"Python入门与进阶（一）","date":"2020-05-25T17:04:11.000Z","updated":"2020-05-25T17:09:08.764Z","comments":true,"path":"2020/05/26/Python入门与进阶（一）/","link":"","permalink":"/2020/05/26/Python入门与进阶（一）/","excerpt":"","text":"Python特点1.Python是一门编程语言，它只是众多编程语言中的一种。 2.语言简洁、优雅，编写的程序容易阅读。 3.跨平台，可以运行在Windows、Linux以及MacOS 4.易于学习。如果把编程语言当作解决问题的工具，python确实比C++、Java、JavaScript等语言要易于学习和掌握。 5.极为强大而丰富的标准库与第三方库，比如电子邮件，比如GUI界面。 6.Python是面向对象的语言。面向对象是一种思想。 个人理解（供参考）：面向对象理解成代码的体制和构建的方式。由面向对象来组织代码，让整个工程或项目更佳清晰，组织方式合理，源代码更易阅读和管理。项目足够庞大时，面向过程的思想不易于代码的管理。 个人喜欢Python原因1.简洁，灵活，优雅，哲学 简洁胜于复杂。 做也许好过不做，但不假思索就动手还不如不做。 2.易于上手难于精通 3.Python既有动态脚本的特性，又有面向对象的特性，非常具有自己的特点。 Python的缺点相较于C、C++、Java，运行效率较慢 主流语言分两大类，编译型语言（C、C++）、解释型语言（JavaScript、Python）。 编译型语言在程序执行前会预先编译，将源代码编译成机器码，执行效率高。 解释型语言没有编译过程，执行时解释。 Java和C #没有严格的划分。有编译过程，编译成中间代码（非机器码） 运行效率与开发效率，鱼与熊掌不可兼得。适合的才是最好的。 一个学习编程的经典误区不要把思维局限在web编程，这只是编程的一个应用方向。 用途爬虫、大数据与数据分析（Spark）、自动化运维与测试、web开发(Flask、Django等)、机器学习(Tensor Flow)、胶水语言（混合其他语言来编程，能够把其他语言制作的各种模块很轻松的连接在一起）。 Python环境安装1.Windows下一键环境安装包【Python官网】—【downloads】—【Windows】 2.安装Python1.打开安装包，按下图方式安装。推荐自定义安装 2.默认勾选，pip一定要选 3.下一步，选择安装位置 4.完成安装，阅读官方使用说明文档documentation 3.IDLE与第一段Python代码","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"git基础专题（四）","slug":"git基础专题（四）","date":"2020-05-25T11:30:50.000Z","updated":"2020-05-25T11:38:47.172Z","comments":true,"path":"2020/05/25/git基础专题（四）/","link":"","permalink":"/2020/05/25/git基础专题（四）/","excerpt":"","text":"git常规命令集 一、新建代码库git init # 在当前目录新建一个Git代码库 git init [project-name] # 新建一个目录，将其初始化为Git代码库 git clone [url] # 下载一个项目和它的整个代码历史 二、配置git config --list # 显示当前的Git配置 git config -e [--global] # 编辑Git配置文件 git config [--global] user.name &quot;[name]&quot; # 设置提交代码时的用户信息 git config [--global] user.email &quot;[email address]&quot; # 设置提交代码时的用户邮箱信息 三、增加/删除文件git add [file1] [file2] ... # 添加指定文件到暂存区 git add [dir] # 添加指定目录到暂存区，包括子目录 git add . # 添加当前目录的所有文件到暂存区$ git add -p # 添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] ... # 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] # 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] # 改名文件，并且将这个改名放入暂存区 四、代码提交git commit -m [message] # 提交暂存区到仓库区 git commit [file1] [file2] ... -m [message] # 提交暂存区的指定文件到仓库区 git commit -a # 提交工作区自上次commit之后的变化，直接到仓库区 git commit -v # 提交时显示所有diff信息 git commit --amend -m [message] # 使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend [file1] [file2] ... # 重做上一次commit，并包括指定文件的新变化 五、分支git branch # 列出所有本地分支 git branch -r # 列出所有远程分支 git branch -a # 列出所有本地分支和远程分支 git branch [branch-name] # 新建一个分支，但依然停留在当前分支 git checkout -b [branch] # 新建一个分支，并切换到该分支 git branch [branch] [commit] # 新建一个分支，指向指定commit git branch --track [branch] [remote-branch] #新建一个分支，与指定的远程分支建立追踪关系 git checkout [branch-name] # 切换到指定分支，并更新工作区 git checkout - # 切换到上一个分支 git branch --set-upstream [branch] [remote-branch] # 建立追踪关系，在现有分支与指定的远程分支之间 git merge [branch] # 合并指定分支到当前分支 git cherry-pick [commit] # 选择一个commit，合并进当前分支 git branch -d [branch-name] # 删除分支 git push origin --delete [branch-name] git branch -dr [remote/branch] # 删除远程分支 六、标签git tag # 列出所有tag git tag [tag] # 新建一个tag在当前commit git tag [tag] [commit] # 新建一个tag在指定commit git tag -d [tag] # 删除本地tag git push origin :refs/tags/[tagName] # 删除远程tag git show [tag] # 查看tag信息 git push [remote] [tag] # 提交指定tag git push [remote] --tags # 提交所有tag git checkout -b [branch] [tag] # 新建一个分支，指向某个tag 七、查看信息git status # 显示有变更的文件 git log # 显示当前分支的版本历史 git log --stat # 显示commit历史，以及每次commit发生变更的文件 git log -S [keyword] # 搜索提交历史，根据关键词 git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --grep feature # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 git log --follow [file] git whatchanged [file] # 显示某个文件的版本历史，包括文件改名 git log -p [file] # 显示指定文件相关的每一次diff git log -5 --pretty --oneline # 显示过去5次提交 git shortlog -sn # 显示所有提交过的用户，按提交次数排序 git blame [file] # 显示指定文件是什么人在什么时间修改过 git diff # 显示暂存区和工作区的差异 git diff --cached [file] # 显示暂存区和上一个commit的差异 git diff HEAD # 显示工作区与当前分支最新commit之间的差异 git diff [first-branch]...[second-branch] # 显示两次提交之间的差异 git diff --shortstat &quot;@{0 day ago}&quot; # 显示今天你写了多少行代码 git show [commit] # 显示某次提交的元数据和内容变化 git show --name-only [commit] # 显示某次提交发生变化的文件 git show [commit]:[filename] # 显示某次提交时，某个文件的内容 git reflog# 显示当前分支的最近几次提交 八、远程同步git fetch [remote] # 下载远程仓库的所有变动 git remote -v # 显示所有远程仓库 git remote show [remote] # 显示某个远程仓库的信息 git remote add [shortname] [url] # 增加一个新的远程仓库，并命名 git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 git push [remote] [branch] # 上传本地指定分支到远程仓库 git push [remote] --force # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --all # 推送所有分支到远程仓库 九、撤销git checkout [file] # 恢复暂存区的指定文件到工作区 git checkout [commit] [file] # 恢复某个commit的指定文件到暂存区和工作区 git checkout . # 恢复暂存区的所有文件到工作区 git reset [file] # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset --hard # 重置暂存区与工作区，与上一次commit保持一致 git reset [commit] # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset --hard [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --keep [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git revert [commit] # 新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支 git stash git stash pop # 暂时将未提交的变化移除，稍后再移入 参考资料https://www.zhihu.com/question/38008771/answer/517332296","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"git基础专题（三）","slug":"git基础专题（三）","date":"2020-05-23T08:30:03.000Z","updated":"2020-05-25T11:27:27.290Z","comments":true,"path":"2020/05/23/git基础专题（三）/","link":"","permalink":"/2020/05/23/git基础专题（三）/","excerpt":"","text":"创建与合并分支Git把每次的提交串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。首先，我们来创建dev分支，然后切换到dev分支上。如下操作： git checkout -b dev #创建并切换分支 git branch #查看当前的分支 git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令 git branch dev git checkout dev git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。 我们在dev分支上继续做demo，比如我们现在在test.txt再增加一行3333，以下为dev分支未添加内容之前和添加内容之后 现在dev分支工作已完成，现在我们切换到主分支master上，继续查看test.txt内容如下 因为不是分支demo，所以3333不显示 我们把dev分支上的内容合并到分支master上，可以在master分支上，使用如下命令git merge dev : git merge命令用于合并指定分支到当前分支上，合并后，再查看test.txt内容，可以看到，和dev分支最新提交的是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，我们可以接着删除dev分支了:git branch -d dev 总结创建与合并分支命令： git branch #查看分支 git branch name #创建分支 git checkout name #切换分支 git checkout –b name #创建+切换分支 git merge name(name为某分支) #合并某分支到当前分支 git branch –d name #删除分支 如何解决冲突下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在test.txt添加一行内容4444，然后提交 同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为5555。如下左图： 现在我们需要在master分支上来合并fenzhi1， Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改成和主干代码上一样（fenzhi1删除4444，改5555和master保持一致）再保存。可参考git处理冲突合并 分支管理策略分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。如git merge –no-ff -m “注释” dev。将dev分支删除后，用git log还能查看被删除的分支信息。 bug分支在开发中，会经常碰到bug问题，有了bug就需要修复，在Git中，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。比如在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。并不是不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。git stash git checkout dev git stash #将当前的工作现场隐藏起来 git status #查看状态是干净的 现在可以通过创建issue-404分支来修复bug了。首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下： git checkout -b issue-404 #创建临时分支 *****修改test文件bug******** git add test.txt git commit -m &#39;fix bug 404&#39; git checkout master #切换到master分支 git merge --no-ff -m &quot;merge bug 404&quot; issue-404 #合并分支issue-404内容 ****合并分支后查看内容，和issue-404内容一致**** git branch -d issue-404 #在master分支上删除临时分支 现在回到dev分支上干活 git checkout dev #从master分支切换到dev分支 git status 工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令git stash list来查看下。工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。2.另一种方式是直接使用git stash pop,恢复的同时把stash内容也删除了。 多人协作当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。要查看远程库的信息 使用 git remote要查看远程库的详细信息 使用 git remote –v 一：推送分支推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上,使用命令 git push origin master。要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev那么一般情况下，那些分支要推送呢？master分支是主分支，因此要时刻与远程同步。一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。 二：抓取分支：多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫demo2，接着进入testgit2目录，进行克隆远程的库到本地来git clone git@github.com:sunshine98yy/testgit.git（如下左图），现在目录下生成（如下右图） 现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支： git checkout –b dev origin/dev #创建远程origin的dev分支到本地来 ****对分支内容进行修改，添加提交***** git push origin dev #把现在的dev分支推到远程去 小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时。 由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 git pull也失败了，是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系)。根据命令行提示只需要执行以下命令即可,设置dev和origin/dev的链接:分支的upstream git branch --set-upstream-to=origin/远程分支的名字(我的是dev) 本地分支的名字(我的是dev) 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push 现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。 git push origin dev #继续推送到远程仓库中 因此：多人协作工作模式一般是这样的：首先，可以试图用git push origin branch-name推送自己的修改.如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":" git基础专题（二）","slug":"git基础专题（二）","date":"2020-05-22T13:56:49.000Z","updated":"2020-05-24T13:57:53.551Z","comments":true,"path":"2020/05/22/git基础专题（二）/","link":"","permalink":"/2020/05/22/git基础专题（二）/","excerpt":"","text":"git操作创建版本库版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 下面演示创建本地版本库，提交文件到本地版本库 创建一个版本库非常简单，如下我在【D盘】 下新建一个demo1版本库。进入D盘，创建demo1文件夹，文件夹为空。 1.通过命令 git init 把这个目录变成git可以管理的仓库这时候你当前demo1目录下会多了一个.git的目录（.表示此文件隐藏），这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。 2.把文件添加到版本库中。在版本库中新建test.txt文件，文件内容git repo1。 echo &quot;git repo1&quot; &gt;&gt; test.txt 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 ​ 第一步：使用命令 git add readme.txt添加到暂存区里面去。git add test.txt ​ 第二步：用命令 git commit告诉Git，把文件提交到仓库。git commit -m &quot;repo1 first commit&quot; 现在我们已经提交了一个test.txt文件，我们下面可以通过命令git status来查看是否还有文件未提交。显示working tree clean ,说明没有任何文件未提交。 现在继续来改下test.txt内容，比如我在下面添加一行change内容，继续使用git status来查看下结果，如下： 上面的命令告诉我们 test.txt文件已被修改，但是未被提交的修改。接下来我想看下test.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：git diff test.txt如下： 如上可以看到，test.txt文件内容从一行git repo改成 二行 添加了一行change内容。知道了对test.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。 版本回退如上，我们已经学会了修改文件，现在我继续对test.txt文件进行修改，再增加一行内容为second change，并提交到本地仓库。 现在我已经对test.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令git log ，演示如下所示。我们也可以使用命令 git log --pretty=oneline来精简显示信息 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可。 文本中的内容会回退到对应版本的内容。此时git log显示的最新的版本是回退的版本。后面新的版本不会显示。如下图，最新的second add 不会显示 此时我又想回退到最新的版本second add。内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者second add内容的版本号我并不知道呢？要如何知道增加second add内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog演示如下： 通过上面的显示我们可以知道，增加内容second add的版本号是 b65c2d7。我们现在可以命令git reset --hard b65c2d7来恢复了。 工作区与暂存区的区别工作区：就是你在电脑上看到的目录，比如目录下demo1里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。我们前面说过使用Git提交文件到版本库有两步：第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 Git撤销修改和删除文件操作一：撤销修改工作区做了改动并添加到暂存区，未提交。此时需要恢复到改动前的版本: 第一：如果我知道要删掉哪那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^ 只是工作区做了改动，此时需要恢复到改动前的版本： git checkout -- file 可以丢弃工作区的修改，如下命令：git checkout -- test.txt, 把test.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：1.test.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。2.另外一种是test.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。对于第二种情况，我想我们继续做demo来看下，假如现在我对test.txt添加一行 内容为1111，我git add 增加到暂存区后，接着添加内容2222，我想通过撤销命令让其回到暂存区后的状态。如下所示： 注意：命令git checkout – test.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。 二：删除文件。在版本库demo1目录添加一个文件b.txt,提交,然后删除 git add b.txt git commit -m &#39;添加b.txt文件&#39; rm b.txt #可以直接在目录下删除b.txt文件或者使用命令rm b.txt 执行完上述步骤后，此时有两个选择: 1.我想彻底从版本库中删掉此文件，可以再执行commit命令 提交掉 2.如果我想在版本库中恢复此文件，使用命令git checkout -- b.txt 远程仓库目前使用的git命令都是在本地执行，如果想通过git分享我们的代码，或者想与其他开发人员合作，就需要将数据放到一台其他人员能连接的服务器上。 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要先设置SSH,步骤见《git基础专题（二）》。 如何添加远程仓库我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以让其他人通过该仓库来协作。 新建一个名为testgit的仓库，效果如下 GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 运行如下命令 git remote add origin https://github.com/sunshine98yy/testgit.git #本地仓库与远程仓库关联命令 git push -u origin master #推到远程仓库上命令 执行git remote就是先将本地仓库与远程仓库建立一个连接，origin是你为远端仓库所起的名字，一般都叫orign,后接远端仓库真实地址。我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 注意master是你要上传的分支的名字，如果当前所在的分支不叫master，会提示错误git show-ref显示远端的相关分支 从现在起，只要本地作了提交，就可以通过如下命令：git push origin master把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 如何克隆远程仓库实际开发中需要多人合作，所以需要将远程仓库的代码克隆到本地，然后在本地进行开发，开发完成后需要推送到远程仓库中，方便协作。（远程代码拷贝一份到本地，基于本地的代码进行开发） git clone git@github.com:sunshine98yy/clone_demo.git #（远程代码拷贝到本地）–&gt;提交改动到本地仓库–&gt;本地仓库push到远程仓库克隆仓库默认跟远程仓库分支绑定！！直接命令git push到远程仓库","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"SOURCETREE 3.1.3 版本跳过BITBUCKET注册方法（亲测好用）","slug":"SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）","date":"2020-05-21T14:25:21.000Z","updated":"2020-05-21T14:34:00.962Z","comments":true,"path":"2020/05/21/SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）/","link":"","permalink":"/2020/05/21/SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）/","excerpt":"","text":"1.首先下载并安装好git程序。 2.接着下载并执行SourceTreeSetup-3.1.3.exe，会进入登录或注册bitbucket的界面，我只是想用软件，并不想去注册账号。怎么办？请往下看。 3.打开 %LocalAppData%\\Atlassian目录，接着进入SourceTree目录，创建accounts.json文件，并修改accounts.json内容如下： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot;&quot;, &quot;Email&quot;: null }, &quot;IsDefault&quot;: false } ] 4.打开 %LocalAppData%\\Atlassian，进入“SourceTree.exe_Url_iayhtc13zv3obzuz5vchezjs1az2q5ef”（注该目录可能和版本相关，不同版本的路径可能不完全一样。） 接着进入”3.1.3.3158“目录，打开user.config文件，在里面加入六行代码。 &lt;setting name=&quot;AgreedToEULA&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;True&lt;/value&gt; &lt;/setting&gt; &lt;setting name=&quot;AgreedToEULAVersion&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;20160201&lt;/value&gt; &lt;/setting&gt; 5.再次执行SourceTreeSetup-3.1.3.exe，即可跳过注册，完成安装。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"git基础专题（一）","slug":"git基础专题（一）","date":"2020-05-21T11:44:51.000Z","updated":"2020-05-22T03:14:27.697Z","comments":true,"path":"2020/05/21/git基础专题（一）/","link":"","permalink":"/2020/05/21/git基础专题（一）/","excerpt":"","text":"Git简介Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是Linus Torvalds为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是现在很多其他自由软件项目中也使用了 Git。 Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 SVN与Git的最主要的区别SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 Windows 平台上安装下载打开Git 官网 ，点击自己需要的版本，按照提示根据自己电脑系统版本下载相应Git,Mysysgit t是 windows版的Git。 安装打开下载好的Git安装包后，一直点击Next，保持默认选项，直到出现Install，点击Install，安装完成后点击Finish 使用安装好后，在电脑桌面或者打开某一本地磁盘，在空白位置右击鼠标会发现多了两个选项Git GUI Here和Git Bash Here，如图所示，点击Git Bash Here即可从当前位置打开并使用使用Git。 自己遇到的问题：git bash/gui here找不到应用程序 由于移动过git的安装目录，因此选择git bash here 时windows无法访问指定设备路径或文件报错解决办法：https://blog.csdn.net/weixin_39643135/article/details/79440222 配置Git环境1.打开GitHub官网，注册一个账号，注册好后，双击桌面上的Git Bash快捷图标，进行环境配置。 2.配置用户名git config --global user.name &quot;username&quot; ##username是自己的账户名，global表示所有仓库都会使用这种配置，可针对某个仓库进行配置 3.配置邮箱git config --global user.email &quot;username@email.com&quot; ##username@email.com注册账号时用的邮箱 因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。 4.命令查看之前的配置是否成功 键入git config --global --list 5.生成ssh秘钥 键入ssh-keygen -t rsa生成ssh，连敲三次回车键，结束后去系统盘目录下（一般在 C:\\用户\\当前用户\\ .ssh）查看是否生成 .ssh 文件夹，此文件夹中包含以下两个文件：id_rsa、id_rsa.pub ssh-keygen -t rsa -C &quot;你的邮箱&quot; #邮箱是github的注册邮箱 Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 6.在 GitHub 账户中添加你的公钥 运行下面命令，将公钥的内容复制到剪切板clip &lt; ~/.ssh/id_rsa.pub 打开【github】—【settings】—【SSH and GPG keys】—【new ssh key】—【把内容粘到key区域】—【add SSH key】 7.测试配置是否成功 在Git Bash命令框中键入ssh -T git@github.com命令，回车后若出现下面情况，则说明环境配置成功。(连网状态下) $ ssh -T git@github.com Hi sunshine98yy! You&#39;ve successfully authenticated, but GitHub does not provide shell access. git的图形化界面操作软件选择sourcetree作为git的图形化操作软件，可以根据自己的需要选择不同的图形化操作软件。 安装过程很简单。本人安装完后碰到需要注册的问题，由于是外国网站，访问可能会有问题，提供下面绕过注册的方法。 SOURCETREE 3.1.3 版本跳过BITBUCKET注册方法（亲测好用）) 参考文献https://zazdream.com/2020/02/17/Git%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ https://www.runoob.com/git/git-install-setup.html 自学Git，有哪些书籍或者好的学习资源？","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Hexo搭建个人网站(步骤篇)","slug":"Hexo搭建个人博客网站（步骤篇）","date":"2020-05-21T11:20:00.000Z","updated":"2020-05-21T13:58:07.576Z","comments":true,"path":"2020/05/21/Hexo搭建个人博客网站（步骤篇）/","link":"","permalink":"/2020/05/21/Hexo搭建个人博客网站（步骤篇）/","excerpt":"","text":"环境部署安装gitNode.js官网 点击自己需要的版本，一路next默认安装即可。教程可参见之前的博客 安装Node.jsGit 官网 点击自己需要的版本默认安装即可。教程可参见博客,写的很详细了nodejs安装与环境变量配置 安装HexoHexo就是我们的个人博客网站的框架， 这里需要自己在某个磁盘里创建一个文件夹，Hexo框架和以后你自己发布的网页都在这个文件夹中，我在D盘创建一个YY_Blog的文件夹。 1.使用npm下载hexo：在命令行上（任意目录）使用npm install -g hexo 全局安装hexo； 2.安装完成后，在你喜爱的文件夹下（如D:\\YY_Blog），执行以下指令hexo init(在D:\\YY_Blog内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件；（过程有点慢，耐心等待） 3.安装依赖包：npm install至此，hexo博客环境已经搭建完成，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000即可查看效果： $ hexo g #等价于hexo generate 生成静态网页 $ hexo s #等价于hexo server 启动预览服务器，开启-d选项时可以预览草稿 将hexo部署到github上上文已经在本地部署好了hexo博客系统，但仅仅本地能够访问。如果想让别人访问到你的博客，你可以租一台云主机，然后把hexo系统部署到云主机上，好处是带宽、容量可以得到保证，缺点是需要花费一笔租金。还有另一种免费的方法，就是把hexo部署到githu pages或者gitcafe pages上，本文以github为例。 关于git的安装配置以及github添加公钥的流程可以参见我的博客 [[git的安装配置]]: d 1.创建repository【your repositories】—【new】 如下图所示，这里要注意，repository名称一定是github的用户名+.github.io,否则github pages无法访问。 2.在github中添加公钥打开git bash输入以下命令 $ git config --global user.name &quot;你的用户名&quot; $ git config --global user.email &quot;你的邮箱&quot; 每次使用git命令从github上同步代码时，需要SSH连接认证。这时就需要你在本地先生成SSH KEY(命令如下)，然后把其拷贝到github上。点击Git Bash Here 输入以下命令： $ ssh-keygen -t rsa -C &quot;你的邮箱&quot; #邮箱是github的注册邮箱 Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 运行下面命令，将公钥的内容复制到剪切板 clip &lt; ~/.ssh/id_rsa.pub 打开github—&gt;settings—&gt;SSH and GPG keys—&gt;new ssh key—&gt;把内容粘到key区域—&gt;add SSH key 如下图 3.部署hexo1.编辑_config.yml(在D:\\YY_Blog下)，repository是在github中申请的地址。如下： 注意：所有的冒号后面空一格 deploy: type: git repository: https://github.com/sunshine98yy/sunshine98yy.github.io.git branch: master 2.执行下面命令 生成、部署hexo博客到github上,这样，你就可以在sunshine98yy.github.io来访问你的博客了。(后面会有专门一栏讲如何绑定自己专属域名) hexo g hexo d 注意 在执行hexo d命令时，有可能会显示如下错误信息：ERROR Deployer not found : github 解决方法如下： 在hexo的配置文件中，把deploy的type改成git 运行如下命令：npm install hexo-deployer-git --save 文献参考https://blog.csdn.net/ParanoidYang/article/details/71436028 https://blog.csdn.net/guoxiaorui666/article/details/99623023 https://lanjingling.github.io/2015/09/23/hexo%E7%AE%80%E4%BB%8B/","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo搭建个人博客网站（原理篇）","slug":"Hexo搭建个人博客网站（原理篇）","date":"2020-05-20T15:14:57.000Z","updated":"2020-05-21T13:33:12.332Z","comments":true,"path":"2020/05/20/Hexo搭建个人博客网站（原理篇）/","link":"","permalink":"/2020/05/20/Hexo搭建个人博客网站（原理篇）/","excerpt":"","text":"前言学习HEXO的初衷是想建立一个博客网站，分享记录日常所学。参考了网上很多的资料，在安装、配置、开发的过程中补过坑，也接触了新的领域。挖掘新事物的过程就像从开始发现一粒沙到后来窥探到瀚海星辰一般有趣。在结合资料的基础上，将整个过程梳理记录一下。 首先需要阐明本文使用Windows环境配置。 Hexo这章我们主要来讲一下 Hexo 是怎样生成 HTML 的。 Hexo简介hexo是使用nodejs开发的一个快速、简洁、高效、开源的静态博客生成器。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 为什么选择Hexo hexo非常小巧，使用nodejs开发，下载安装时只需要几个npm命令即可。 纯静态博客，不需要什么额外的mysql数据库、php环境…仅仅需要一个nodejs环境即可。 由于是静态博客，所以，可以非常方便部署到github、gitcafe上(后者是国内的，速度可能更有保证) 支持markdown语法、兼容windows linux mac，高可扩展性和自定义，而且有非常多的hexo主题… 工作原理hexo文件架构├── node_modules： #依赖包-安装插件及所需nodejs模块。 ├── public #最终网页信息。即存放被解析markdown、html文件。 ├── scaffolds #模板文件夹。即当您新建文章时，根据 scaffold生成文件。 ├── source #资源文件夹。即存放用户资源。 | └── _posts #博客文章目录。 └── themes #存放主题。Hexo根据主题生成静态页面。 ├── _config.yml #网站的配置信息。标题、网站名称等。 ├── db.json： #source解析所得到的缓存文件。 ├── package.json # 应用程序信息。即配置Hexo运行需要js包。 首先本地文件夹的source就是数据库，以.md（markdown）格式存储文章，theme文件夹是主题文件（决定页面模板）。 我们可以通过部署流程来逐步详尽分析。以下先来了解hexo有哪些部署命令，再分析部署的步骤流程 hexo命令总览hexo可以粗略分为三个子项目，分别是: hexo-cli hexo (下文中用hexo core来指代) hexo plugins hexo-cli：hexo命令行，作用是： 1.启动hexo命令进程和参数解析机制。每次我们输入hexo xxx命令后，都会通过node调用hexo-cli中的entry函数(比如，可以把’hexo init’视为’node hexo-cli/entry.js init’)，hexo init命令仅仅在安装时调用 2.实现hexo命令的三个初始参数：init/version/plugins 3.加载hexo核心模块，并初始化 hexo core：hexo核心，作用是：实现hexo的new、generate、publish等功能 hexo plugins: 指一些能够扩展hexo的插件。插件可以按功能分成两类: 1.扩展hexo命令的参数，如hexo-server(安装这个插件以后才能使用hexo server命令) 2.扩展hexo解析文件的”能力”，如增加jade模版解析功能的hexo-render-jade插件 介绍hexo主要命令： hexo n title #等价于 hexo new [layout] title 发布新文章 hexo p filename #等价于hexo publish filename 将_drafts下的文件放到_posts下，也就是发布草稿 hexo g #等价于hexo generate 生成静态网页 hexo s #等价于hexo server 启动预览服务器，开启-d选项时可以预览草稿 hexo d #等价于hexo deploy 发布到远程服务器，开启–generate选项可以在deploy前自动generate hexo s –debug #使用hexo s 启动本地服务后，如果修改了配置或者文章内容，需要停止服务后重新启动才能生效。这样，在调试或写文章阶段非常不方便，可以使用下面命令，以debug的方式启动，这样每次修改后就无需重启服务了。 部署的流程hexo g：生成静态文件。将我们的数据和界面模板相结合生成静态文件的过程。Hexo（node.js程序）遍历主题文件中你的source目录（js、css、img等静态资源），建立索引，再根据索引生成由html、js、css、img建立的纯静态文件并放在public文件夹里。public就是你的博客了，而这些恰好能被git pages识别。 hexo d：部署文件。主要是根据在_config.yml中配置的git仓库或者coding的地址，将public文件通过git方式push到上传到github或coding的指定分支，然后在根据pages服务呈现出页面。当然把public文件部署至你的服务器也是OK滴。 Hexo的模板引擎模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离 1.请看Hexo文件结构，source文件夹与themes文件夹是同级的，进而我们就可以将source文件夹理解为数据库，而主题文件夹相当于界面。hexo g就将我们的数据和界面相结合生成静态文件public 2.Hexo模板引擎默认使用ejs编写（本文以ejs模板举例，其他的有swig、jade）。hexo首先会解析.md文件，然后根据layout变量判断布局类型，再调用相应布局文件，这样每一块内容都是独立的，提供代码的复用性。最终生成一个html页面 3.布局模板文件位于layout文件夹下，以下将布局模板简称模板。layout文件结构在不同主题下文件排布不一，但整体框架是一样的，有： 公共模板。里面引入了head、footer等公共组件，在其他模板下会自动引入公共模板 首页模板 文章模板 分类模板 归档模板 …… 每个模板都默认使用layout布局，您可在文章的前置申明中指定其他布局，比如“post”或者“page”或是设为false来关闭布局功能（如果不填默认是post，这个在_config.yml中可以设置默认值），您甚至可在布局中再使用其他布局来建立嵌套布局 我们使用的模板。hexo new [layout] &lt;title&gt;就会使用对应的模板。 数据填充上面解释了界面的原理，此篇将分析数据及数据如何与界面结合。 数据的填充主要是 hexo -g 的时候将数据传递给 ejs 模板，然后再由 ejs 模板填充到 HTML 中。 配置文件中的数据Hexo 的配置文件 _config.yml 使用 yml语法 。例如博客的名字、副标题等等之类。这些数据项组织在 config 对象中。可以是数字、字符串、对象、数组。 如果要在模板中使用某个具体的值，比如字符串、数字、逻辑变量或者对象的某个成员，可以在主题的模板文件 ejs中直接使用： {% block title %} {{ page.title }} | {{ config.title }} {% endblock %} Github PagesHexo搭建的博客项目源码托管在github，并享受github pages服务。 GitHub pages简称pages服务，每个仓库都有一个pages服务，可用来展示项目，通过简单的设置项目的index.html，并以此做为入口供用户参观访问。大部分的 pages 服务都是用来搭建个人博客的。言外之意不仅能搭建博客，还能做些其他的事情~ 生成博客的页面有动、静态页面之分，著名的博客 wordpress ，既是动态页面生成的博客，其思路是 php + MySql 。 博客hexo生成的是静态页面，而Github pages 又支持静态页面的解析。因此二者一拍即合能够用来生成 html 拼合成博客。 参考文献：https://hexo.io/zh-cn/docs/github-pages https://juejin.im/post/598eeaff5188257d592e55bb#heading-5","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo运营前记","slug":"Hexo运营前记","date":"2020-05-20T11:30:23.000Z","updated":"2020-05-20T11:19:52.510Z","comments":true,"path":"2020/05/20/Hexo运营前记/","link":"","permalink":"/2020/05/20/Hexo运营前记/","excerpt":"","text":"着手搭建博客是一件不在计划内的事情。起因是前段时间接触Linux的内容，讲到用SSH实现客户端到服务器端的免密登录时，有用一个hexo+github page搭建网站过程中的环节举例。虽然只是一句话带过的例子，在我尝试配置了本地SSH秘钥后，完全发现了一个新的探索方向（折腾方向）。 做博客就像打游戏，当你以为自己升到80级时，对于别人来说这仅仅处于20级的位置，层次浅到非常。 花在上面的时间前前后后有两周的晚上，开始照着官方文档来，实现基本配置。后面又浏览了下大佬们的博客，对比一下自己眼前毫无特色的主页不香了。于是推倒重建找主题，加美化插件。只能说一时折腾一时爽，永远折腾永远爽吧。 整个过程大致是换了两个主题，Icarus、Sakura。搭建用CDN加速连接的图库，熟悉hexo框架的基本命令，markdown的基本语法（没错，写博客更博客不像空间发状态那么直接），走了一遍git的工作流程，购买解析了域名。不停地倒腾配置文件，最主要的是找合适的优化插件。耗费这么多精力是我一开始没想到的。自己就像在海边捡起一枚贝壳，透过小小的贝壳看到大海的模样。下面是一开始Icarus的主题，其实还是挺好看的。作者最近用新的语言重新写了一套框架，因此想自己发挥的难度对我这种新手难度很大。 Icarus这款主题主打简洁大方，页面清爽。在上面增加了板娘的效果，评论打赏分类标签历程展示，基本都能实现，icarus也有缺点，无多级导航（仅仅是个人喜好）。后来浏览到sakura主题，也就是现在的主题。在简洁和酷炫之间还是选择了后者。模板用的人还不多，下载了主题star了下项目，感谢原作者的创作。下面是自己DIY的样式。 “工欲善其事必先利其器”，搭建的博客网站是记录自己历程的利器。也很是佩服自己这把年纪了还能这么折腾。 折腾被赋予了一个新的含义——走出舒适区。诚然，走出舒适区现在已然成许多人的口号，嘴上说说而已的口号，智商常常不在线的我更是如此。 漫长的道路，现在只是一个开始的起点。 A journey like life, welcome to my entire world!","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"画廊——日常","slug":"画廊","date":"2020-05-19T14:06:43.000Z","updated":"2020-05-21T06:14:52.200Z","comments":true,"path":"2020/05/19/画廊/","link":"","permalink":"/2020/05/19/画廊/","excerpt":"","text":"献给我琳~","categories":[],"tags":[{"name":"光影艺术","slug":"光影艺术","permalink":"/tags/光影艺术/"}],"keywords":[]},{"title":"SSM+Springboot商铺系统(一)","slug":"SSM-Springboot商铺系统","date":"2020-05-19T13:21:08.000Z","updated":"2020-05-19T13:31:48.298Z","comments":true,"path":"2020/05/19/SSM-Springboot商铺系统/","link":"","permalink":"/2020/05/19/SSM-Springboot商铺系统/","excerpt":"","text":"待更~","categories":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}],"tags":[],"keywords":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}]},{"title":"Linux核心技术与应用笔记（一）","slug":"Linux核心技术与应用笔记（一）","date":"2020-05-19T11:24:34.000Z","updated":"2020-05-19T11:42:58.713Z","comments":true,"path":"2020/05/19/Linux核心技术与应用笔记（一）/","link":"","permalink":"/2020/05/19/Linux核心技术与应用笔记（一）/","excerpt":"","text":"待更~~~~","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Sakura主题配置总结","slug":"Hexo-Theme-Sakura","date":"2020-05-19T02:45:01.000Z","updated":"2020-05-20T15:44:32.309Z","comments":true,"path":"2020/05/19/Hexo-Theme-Sakura/","link":"","permalink":"/2020/05/19/Hexo-Theme-Sakura/","excerpt":"","text":"前言搭建完框架后，为博客找一个主题。主题的搭建往往是无止境的，适合爱折腾的选手。在网上被迫欣赏大佬们的华丽主题后，我看着自己一开始配置的主题，突然觉得不香了。是时候换一拨了，挑选了一个用的人比较少的sakura主题，在github上star了项目，感谢原作者的辛勤创作。 一： 主题下载hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 二： 主题配置博客根目录下的_config配置站点（显示在浏览器导航页的信息） # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://sunshine98yy.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/sunshine98yy/sunshine98yy.github.io.git,backup # coding: https://git.coding.net/sunshine98yy/sunshine98yy.git,backup 顶部站点名字其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: YU YU 顶部导航栏# 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } 前面的path是网页路径，这个不建议修改，但可以修改。后面的如: fa: fas fa-home fa-1x 这个就是对应的图标设置,关于这个图标大家可以去fontawesome看教程以及选择自己喜欢的图标，导航栏下拉下拉菜单的图标修改和导航栏相同。 头像修改# favicon and site master avatar # 站点的favicon和头像 输入图片路径【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg 我这个是使用cdn后的路径，也可以修改为： favicon: https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg 大家可以用jsDeliver+github搭建自己的cdn,具体教程请点击查看我的另一篇博客其中有详细介绍！ # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"},{"name":"sakura","slug":"sakura","permalink":"/tags/sakura/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}