{"meta":{"title":"风中的鱼","subtitle":null,"description":"心里有火眼里有光","author":"YU YU","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-05-19T07:23:57.767Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"categories","date":"2020-03-09T05:50:05.000Z","updated":"2020-05-19T15:43:16.267Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-05-19T08:37:48.007Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-05-18T08:11:28.691Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-09T05:50:05.000Z","updated":"2020-05-19T15:18:50.643Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"}],"posts":[{"title":"纯正商业级应用-微信小程序开发实战（更新中）","slug":"电纯正商业级应用-微信小程序开发实战","date":"2020-08-04T11:24:34.000Z","updated":"2020-08-06T16:18:40.864Z","comments":true,"path":"2020/08/04/电纯正商业级应用-微信小程序开发实战/","link":"","permalink":"/2020/08/04/电纯正商业级应用-微信小程序开发实战/","excerpt":"","text":"实战项目笔记根据imooc七月的《纯正商业级应用-微信小程序开发实战》记录。 开发项目前提，有设计图，数据，需求。课程提供相应设计图原稿（PSD），在线API提供数据，线上案例参考。 学习小程序开发，建议多阅读参考小程序开发者文档 小程序杂记入手小程序前，务必理解回调函数。 回调函数的理解回调函数式什么 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 关于js的callback回调函数以及嵌套回调函数的执行过程理解 JS中回调函数(callback)理解 箭头函数JS中的箭头函数与this 异步处理微信小程序踩坑系列——从wx.request谈谈异步处理 微信小程序组件开发规范微信小程序组件开发规范 准备工作申请appkey提供了在线的API，开发者需要申请开发者key(appkey)，访问www.7yue.pro提供直接用，前提购买该课程 可以自己在github上搜，提供一下appkey 纯正商业级应用-微信小程序开发实战 appkey RdshydjBvcYZhMZC GgRhTjUNUYn1fHke 注册微信小程序1.进入微信公众平台官网，新用户需注册，点击立即注册 http://mp.weixin.qq.com 2.注册微信小程序账号（个人、企业） 微信对个人小程序较保守，做产品上线时，分析自己需要取得哪些资质 微信公众号：小程序（小程序、小游戏）、服务号、订阅号、企业微信 注册完成后，在邮箱点击确认注册信息 3.下载微信开发者工具 在小程序首页中，选择【文档】—【开发】—【工具】—【下载】 下载软件后，按照安装向导进行安装（自定义安装路径） 4.获取appid 使用appid可以调用开放API，无ID无法调用开放API,建议填上 进入小程序后台管理界面，【开发】—【开发设置】—【开发者ID】查看 熟悉开发工具首次登陆微信开发者工具，需要扫码登陆 新建项目填写项目名和AppID，选择项目目录 进入工作界面，开发工具为我们初始化了部分文件 机型适配观察上特别注意下iPhone X机型 开发工具快捷键按F1快速查看快捷键，按需查询 常用快捷键 快速打开文件 ctrl+p 搜索近期打开的文件 ctrl+e 格式化代码 ctrl+shift+F 其他设置外观设置或快捷键设置：勾选【设置】按钮选择 小程序基础知识小程序文件类型小程序有四种文件类型（wxss、wxml、js、json），和传统的css、html相比只是扩展名不同，其他大体无区别 上手小程序需要有js/css/javascript基础 json文件无注释，只用双引号 小程序的组织结构基础结构 每个小程序有三个全局文件，全局配置文件（app.json）、全局样式文件（app.wxss）和全局业务文件（app.js）,名字默认无法更改。 小程序由多个页面（page）组成，一个page页面一般由四种文件类型构成。 进阶结构（组件式编程思想） 一个页面由更多的组件构成，每个组件包含四种基本类型 如旧岛项目的目录 新建第一个小程序页面小程序框架 新建空白项目，项目下新建app.js，app.json。新建pages文件夹，文件夹下新建classic文件夹，新建page，在page（目录下会自动生成四个文件classic新建前提需要补充前面两个新建文件的初始代码，否则无法创建）。 #app.js App( ) #app.json { } 新建page（classic）后，app.json内容自动生成如下,我们称为路径注册： 小程序中每新建一个页面，都必须在App.json中注册，否则小程序找不到page页面 { &quot;pages&quot;: [ &quot;pages/classic&quot; ] } 要删除这四个文件方法： 在文件所在文件夹中删除 参考小程序开发文档 pages用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 .json, .js, .wxml, .wxss 四个文件进行处理。 数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。 #app.json { &quot;pages&quot;: [ &quot;pages/classic/classic&quot; ] } window用于设置小程序的状态栏、导航条、标题、窗口背景色。 &quot;window&quot;: { &quot;navigationBarBackgroundColor&quot;: &quot;#FFFF00&quot;, //导航栏背景颜色 &quot;navigationBarTitleText&quot;:&quot;微信接口功能演示&quot;, //导航栏标题文字内容 &quot;navigationBarTextStyle&quot;:&quot;black&quot;, //导航栏标题颜色，仅支持 black / white &quot;navigationStyle&quot;:&quot;default&quot; //导航栏样式，仅支持以下值：default 默认样式，custom 自定义导航栏 } backgroundColor窗口的背景色:开发界面中不会显示background区域，开启下拉刷新，可实现。在真机上上拉或下拉可显示 通常情况下，background的颜色和page保持一致，默认白色。 #app.json { &quot;pages&quot;: [ &quot;pages/classic/classic&quot; ], &quot;window&quot;: { &quot;navigationBarBackgroundColor&quot;: &quot;#FFFF00&quot;, &quot;navigationBarTitleText&quot;:&quot;鱼鱼的世界&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot;, &quot;navigationStyle&quot;:&quot;default&quot;, &quot;backgroundColor&quot;:&quot;#D80000&quot;, &quot;enablePullDownRefresh&quot;:true //是否开启全局的下拉刷新。 } } 效果如下： wxmlWXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构 wxml是一个或多个组件的集合 小程序中的组件和html的标签类似，不同的组件支持不同的属性。 有些组件成对出现，也有不用成对出现。 内置组件，微信提供，可直接用 自定义组件 flex布局（重要）布局 代码控制元素排布 需要布局的技巧和嵌套的思维 block、inline和inline-block块级元素独占一行，默认情况下，是否是块级元素通过display设置，默认是block 块状元素转为行内元素：display:inline 行内元素默认不设置高宽，要实现行内元素有高宽属性，设置display:inline-block;(并列显示在一行) #wxss .chunk{ display: inline-block; width: 100px; height: 200px; } .color1{ background-color: brown; } .color2{ background-color: aqua; } .color3{ background-color: blue; } #wxml &lt;view class=&quot;chunk color1&quot;/&gt; &lt;view class=&quot;chunk color2&quot;/&gt; &lt;view class=&quot;chunk color3&quot;/&gt; flex容器容器将消除容器内item的块状特性，块状元素放置于弹性盒子中，块状元素的特性会消除。flex是 flexible box(弹性盒子、弹性布局)的缩写 两个基本概念 flex container和flex item ，弹性布局需要container和item #wxss .chunk{ width: 100px; height: 200px; } .container{ display: flex; } .color1{ background-color: brown; } .color2{ background-color: aqua; } .color3{ background-color: blue; } #wxml，为3个小色块增加一个容器 &lt;view class = &quot;container&quot;&gt; &lt;view class=&quot;chunk color1&quot;/&gt; &lt;view class=&quot;chunk color2&quot;/&gt; &lt;view class=&quot;chunk color3&quot;/&gt; &lt;/view&gt; flex-direction属性解析设置容器下子项item的排布方向 .container{ display: flex; flex-direction: column; //纵向排列 flex-direction: row;//水平排列（默认是水平排列） flex-direction: row-reverse;//reverse倒序排布(靠右开始，有偏移现象) flex-direction: column-reverse; } view组件高度自适应，宽度默认100% 使用reverse ，元素的内容和位置都会倒序 container容器内元素高度自适应。对于上面的view组件来说，不指定高度的话通常自适应填满高度。指定容器后出现偏移效果。 justify-content属性解析控制子元素的对齐方向： justify-content:flex-end（下右） justify-content:flex-start（上左） justify-content:center（居中） justify-content:space-between //水平（垂直）方向平均分布 justify-content:space-around //实现等距分布（每个item之间的距离均相等） 主轴与交叉轴主轴和交叉轴的方向取决于flex-direction justify-content指的是主轴上的排布和对齐方式，align-items指的是交叉轴上的排布和对齐方式 .container{ display: flex; flex-direction: column; //此时垂直方向是主轴 height: 400px; background: #999999; justify-content: start; align-items: center; } 当flex-direction: column-reverse;或flex-direction: column-reverse;时，主轴水平垂直方向不变，变得是轴朝向（左-右，上-下） baseline与stretch属性align-items: baseline; 并不是让子元素对齐，而是让元素内的文字对齐，以第一个元素的文字作为基线对齐 align-items:stretch:不让子 元素随其内容自适用（没有定义height的情况） flex-wrap与消除间距一行中总元素的宽度大于行宽度，会默认让元素平均分配一行的宽度，不会出现换行 flex-wrap: wrap; //元素换行 flex-wrap: nowrap; //默认，元素不换行 消除换行后的间距:间距是flex的默认特性，可以设置总高度消除换行的效果。 小程序组件组件概述以项目中心形点赞按钮为例： 自定义组件，实现js，css，wxml的复用 新建存放所有组键的目录components，新建心形组件目录,如like，新建component，如index。index只是组件的文件名，并不是组件的名字。 组件新建完成后不会有任何效果 要使组件生效：需在页面中引用组件，并在wmxl使用它才会生效 在classic页面中引用组件 like不是组件名，只是组件的目录。为了规范组件名，使用like-cmp(根据实际规范调整) 配置文件中引入组件 #classic.json { &quot;usingComponents&quot;: { &quot;like-cmp&quot;:&quot;/components/like/index&quot; //键名：键值 } } 页面中使用引入的组件 #classic.wxml &lt;like-cmp/&gt;（自定义组件） 绝对路径：/components/like/index 相对路径：../../components/like/index /表示根目录，../表示返回上一级目录。在同级别目录下才能访问 项目实战LIKE组件实现功能：点击心形图片，显示点赞数加1，并且图片有切换效果。 图片图片的存放存放组件用图片的方式： 在对应的组件目录下面新建images图片 component文件夹下新建images,统一存放 根目录下的images存放和页面page相关的图片 ​ 此处选择把images文件夹放在like目录下 引用图片 #index.wxml &lt;image src=&quot;images/like.png&quot;&gt;&lt;/image&gt; 问题：图片显示尺寸过大 在小程序中使用image标签引入图片时必须用image标签设置高和宽，否则是默认尺寸。 设置图片的原始尺寸 #index.wxss .container{ height:32px; width:28px; } #index.wxml &lt;image class=&quot;container&quot; src=&quot;images/like.png&quot;&gt;&lt;/image&gt; 问题：按照原始尺寸设计图片效果还是过大 尺寸的单位px是固定尺寸单位，px 和小程序系统中看到的图片大小比例是1：2，用的话除以2（iPhone6的标准）， rpx可以屏幕自适应，px 和小程序系统中看到的图片大小比例是 1：1 根据不同的情况做不同的选择。如字体的大小推荐px,不随机型变化而变化。绝大多数情况可以使用rpx。 2倍换算的前提：以iphone6尺寸为前提（宽750，高1334像素） 样式样式设计考虑数字和图标的布局问题 #index.wxml &lt;view class = &quot;container&quot;&gt;//放入容器 &lt;image src=&quot;images/like.png&quot;/&gt; &lt;text&gt;9&lt;/text&gt;//真实数字取值从服务器中得到 &lt;/view&gt; #index.wxss .container{ display: flex; //应用flex布局的第一步 flex-direction: row; padding: 10rpx; //9不会被遮挡 width: 80rpx;//限定宽度，无法自适应 } //样式选择器写法，子元素少的情况使用 .container image{//image是子元素，此写法避免了给每个元素定义一个新的样式名称 width: 32rpx; height: 28rpx; } .container text{ position: relative;//数字进行偏移 bottom: 10rpx;//上偏移 left:6 rpx;//右偏移 font-size: 24rpx; color: #bbbbbb; line-height:24rpx ; //文字上下本身有空白间距，消除字体自带上下空白间距 } 现在的效果组件占满了一行。容器设置了flex,并不会改变自身的块状属性，改变了子元素的块状属性。 #index.wxss .container{ display: inline-flex; //宽度自适应 flex-direction: row; padding: 10rpx; //9不会被遮挡 } 自适应缺陷：数字的位数跳动时，由于变化也会使页面产生跳动。根据实际情况确定 组件样式继承全局样式（app.wxss）中设置的样式影响到组件的话，就说组件继承了全局样式。 #app.wxss page{ font-family: cambria; font-size: 32rpx; } 全局样式给了一种统一默认的样式，某个组件有自己样式可以覆盖 问题：page设置样式为什么能影响组件？ 虽然组件本身不是页面，但要使用组件时需要被引用到页面中 组件能继承的样式只有两种：font,color 几乎所有的css样式可以被page页面继承 组件状态切换和数字加减监听到用户操作后触发业务逻辑,在js中写业务逻辑 监听用户的点击事件bind:tap=“onLike” #index.wxml &lt;view bind:tap=&quot;onLike&quot; class = &quot;container&quot;&gt; &lt;image src=&quot;images/like.png&quot;/&gt; &lt;text&gt;9&lt;/text&gt; &lt;/view&gt; #index.js methods: { onLike:function(event){ console.log(event); } } index.js的默认代码结构 Component({ /** * 组件的属性列表 */ properties: { }, /** * 组件的初始数据 */ data: { }, /** * 组件的方法列表 */ methods: { } }) catch:tap 和bind:tap 参考文档 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡 组件数据、事件与属性数据来源的三种途径 数据绑定数据从js传到wxml中，并由wxml来显示数据的模式叫做数据绑定 数据从js传到wxml中，使用双括号进行引用 #index.wxml &lt;view bind:tap=&quot;onLike&quot; class = &quot;container&quot;&gt; &lt;image src=&quot;images/like.png&quot;/&gt; &lt;text&gt;{{count}}&lt;/text&gt; //双花括号引用js中的数据 &lt;/view&gt; #index.js /** * 组件的初始数据 */ data: { count:99 } 三元表达式与图片切换 data: { like:true, count1:99, count2:999//true,显示99，false,显示999 } &lt;text&gt;{{like?count1:count2}}&lt;/text&gt; //使用三元表达式 三元表达式也可以用在属性中 &lt;image src=&quot;{{like?'images/like.png':'images/like@dis.png'}}&quot;/&gt; 可以用三元表达式实现点击后图片更换的效果 (在双引号中表示字符串时用单引号) 写法可以优化，将路径定义成js变量 data: { like:true, count1:99, count2:999//true,显示99，false,显示999 yesSrc:&#39;images/like.png&#39; nosrc:&#39;images/like@dis.png&#39; } &lt;image src=&quot;{{like?yesSrc:noSrc}}&quot;/&gt; 组件的封装性和开放性data: { like:true, count:99, //从组件的外部可以访问开放的数据 yesSrc:&#39;images/like.png&#39; nosrc:&#39;images/like@dis.png&#39; //内部数据不需开放 } 开放的数据：从组件外部可以设置被开放出来的数据，如like,count,开放的数据也可以称为属性 properties下面定义的变量称为属性。属性是js对象,可以指定3个属性的特性，type必填，value和observer选填。value不填会自动选取默认值。 语法如下 properties: { like:{ type: Boolean, value: false, observer:function(){ } }, count:{ type:Number, } }, data: { yesSrc:&#39;images/like.png&#39; nosrc:&#39;images/like@dis.png&#39; //内部数据不需开放 属性亦可以通过{{}}引用 let,var与组件事件应用ES6建议使用let定义变量。let声明变量的作用域局限在块级，var定义的变量作用域至少是一个函数之内，是全域。 setData（）方法接收一个js对象，在对象中更新变量。 用于将数据从逻辑层发送到视图层 （异步），同时改变对应的 this.data 的值（同步）。对象以key:value形式表示，将this.data中key对应的值改变成value 应用：通过鼠标点击切换like属性状态 在onlike函数中修改LIKE属性的取值 通过this关键字访问component下面的各种变量 methods: { onLike:function(event){ let like = this.properties.like let count = this.properties.count count = like?count-1:count+1//like为真，点一次是假，-1 //更新数值 this.setData({ count:count, like:!like }) } 访问API数据与ES6在小程序中的应用看待组件的两种观点 组件实现代码的分离（对初学者来说更重要） 组件实现代码的复用 访问和封装API项目（Blink） APl介绍和测试API访问项目的API需要APPKEY，七月有风网站有开发文档，点击可查看API说明 http://bl.7yue.pro/v1/classic/latest?appkey=GgRhTjUNUYn1fHke 小程序中访问API加载数据加载时机：在classic页面初始化时向服务器发送请求获取数据 生命周期函数微信提供生命周期函数监听页面的生命周期，描述了一个页面完整的生命历程。 在classic页面的classic.js中，小程序已经初始化了很多生命周期函数. 对于生命周期函数来说，原理和之前自己创建的监听点击事件类似，区别在于函数的触发由小程序内部的系统来调用，不用bind来监听。触发函数名由系统定义。 // pages/classic/classic.js Page({ /** * 页面的初始数据*/ data: { }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { }, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** * 生命周期函数--监听页面显示 */ onShow: function () { }, /*** 生命周期函数--监听页面隐藏 */ onHide: function () { }, /*** 生命周期函数--监听页面卸载 */ onUnload: function () { }, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { }, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /*** 用户点击右上角分享 */ onShareAppMessage: function () { } }) onload是最先被触发，更快的从服务器获取数据 发起 HTTPS 网络请求wx.request(Object object)函数，专门用于向服务器发起http请求,函数接收js对象，对象可以包含很多子参数 属性 类型 默认值 必填 说明 最低版本 url string 是 开发者服务器接口地址 data string/object/ArrayBuffer 否 请求的参数 header Object 否 设置请求的 header，header 中不能设置 Referer。 content-type 默认为 application/json timeout number 否 超时时间，单位为毫秒 2.10.0 method string GET 否 HTTP 请求方法 dataType string json 否 返回的数据格式 responseType string text 否 响应的数据类型 1.7.0 enableHttp2 boolean false 否 开启 http2 2.10.4 enableQuic boolean false 否 开启 quic 2.10.4 enableCache boolean false 否 开启 cache 2.10.4 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 不管服务器返回的http状态码的值是多少，都会执行success回调函数。只有如断网断电，走fail回调函数 onLoad: function (options) { wx.request({ url:&#39;http://bl.7yue.pro/v1/classic/latest&#39;, header:{ appkey:&quot;GgRhTjUNUYn1fHke&quot;, } }) }, 出现不在合法域名列表的报错：设置—项目设置—不校验合法域名（只适用于开发阶段），最终上线发布还是需要后台账户添加访问的域名 出现401错误，点击调试器右上方方框按钮调试器弹出 以上是简单的访问示例，还需要对访问请求封装。避免到处写request。 重要概念*同步、异步与回调函数目前服务器返回的数据显示在network调试窗口，如何在JS代码中获取服务器返回的数据？ wx.request是异步函数，let a =wx.request()不能使用。无法用a接收异步调用结果。 在小程序中，request只有异步没有同步（强制异步）。 异步编程:性能好，维护代码成本高 同步编程：等待某个调用结束后代码才会继续进行 那么如何接收异步函数的调用结果呢？回调函数 回调函数：在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。（一个函数被传入之后又被调用）如果没有名称(函数表达式)，就叫做匿名回调函数。 //success是回调函数，在success函数中接收异步调用的结果。 什么时候调用这个回调函数？ 服务器返回数据时，小程序触发success函数的执行，把服务器调用的结果当作参数(res)输出 写法一： onLoad: function (options) { wx.request({ url: &#39;http://bl.7yue.pro/v1/classic/latest&#39;, header:{ appkey:&quot;GgRhTjUNUYn1fHke&quot;, }, success:function(res){ console.log(res) } }) }, 输出的是一个json对象，我们主要关注的是data 当前回调函数的缺点： 回调函数success外可以正确访问this,回调函数内无法正确访问this data: { test:1, }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(this.data.test) //能够访问1 wx.request({ url:&#39;http://bl.7yue.pro/v1/classic/latest&#39;, header:{ appkey:&quot;GgRhTjUNUYn1fHke&quot;, }, success:function(res){ console.log(this.data.test)//报错，无法正确访问1 } }) }, 这是回调函数定义的最大缺陷。函数作用域发生了改变，this的指代不明确。 解决方法 ​ 先在回调函数的外面把this的指代保存 onLoad: function (options) { console.log(this.data.test) let that = this.data.test wx.request({ url:&#39;http://bl.7yue.pro/v1/classic/latest&#39;, header:{ appkey:&quot;GgRhTjUNUYn1fHke&quot;, }, success:function(res){ console.log(that) //1 } }) }, 更好的方法:ES6中箭头函数 箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj success:(res)=&gt;{ console.log(this.data.test)//可以正确访问 } Promise函数,要正确的使用 解决异步嵌套的问题（回调地狱） 二次封装const常量对上述的wx.reques进行二次封装，封装原因： ​ 处理返回的异常 ​ 不用每次使用都写链接 项目根目录下新建config.js文件 #config.js const config = { //设置固定不变的常量，参数不可改变 api_base_url:&#39;http://bl.7yue.pro/v1/&#39;, appkey: &quot;GgRhTjUNUYn1fHke&quot; } 新建util文件夹，文件夹下新建http.js文件（对wx.request做封装），需要对request进行封装（API调用封装成一个类） Module export 和import在ES6里，一个js文件就是一个模块，模块内部定义的变量外部无法访问，需要模块主动输出（export） export #config.js export const config = { //设置固定不变的常量，参数不可改变 api_base_url:&#39;http://bl.7yue.pro/v1/&#39;, appkey: &quot;GgRhTjUNUYn1fHke&quot; } export let fun1 = function(){ //函数 } ------------另一种写法-------- #config.js const config = { //设置固定不变的常量，参数不可改变 api_base_url:&#39;http://bl.7yue.pro/v1/&#39;, appkey: &quot;GgRhTjUNUYn1fHke&quot; } let fun1 = function(){ //函数 } export {config,fun1} export {config as config1,fun1} //导出时改变名字 import #http.js import {config，fun1} from &#39;/config.js&#39; 封装HTTP类对request进行封装（API调用封装成一个类） #http.js import {config} from &#39;/config.js&#39;//引用路径错，要使用相对路径 class HTTP{ //params包含访问一个api时包含的全部参数 request(params){//给类添加方法，直接写方法名 if(!params.method){ params.method=&quot;GET&quot; //默认GET } //params(url,method,data) wx.request({ url:config.api_base_url+params.url, method:params.method, data:params.data, header:{ &#39;content-type&#39;:&#39;application/json&#39;, &#39;appkey&#39;:config.appkey }, success: (res)=&gt;{ let code = res.statusCode.toString() //显而易见，我们只有在HTTP状态码为2**才调用success，所以我们需要对响应结果的状态码进行判断，根据判断结果决定是否执行params.success if (code.startsWith(&#39;2&#39;)){ //状态码是2开头，成功，否则失败 } else{ } }, fail:(err)=&gt;{ } }) } } export {HTTP} *回调函数传递给调用方我们希望classic.js的success函数能打印服务器最终返回的信息。在http.js 的回调函数中把res返回给调用方。如何把res返回给调用方呢？ 调用request方法时其实传了一个params,有一个已经设定好的success函数，在http.js中判断成功后调用params下的success函数把res传递进来就可以 #classic.js import {HTTP} from &#39;/util/http.js&#39;（会报错） import {HTTP} from &#39;../../util/http.js&#39; let http = new HTTP()//实例化一个类 onLoad: function (options) { //request需要接收的参数 http.request({ url: &#39;classic/latest&#39;, success:(res)=&gt;{//res为http中的res.data console.log(res) } }) }, 上述代码运行报错 问题：为什么路径会解析错误？ 小程序把绝对路径当做相对路径来解析 通用错误处理HTTP状态码帮助大致判断成功还是失败 错误码表示具体的业务错误 #http.js import {config} from &#39;../config.js&#39; const tips = { //json对象，记录每个错误码对应的错误提示 1:&#39;出现了一个错误&#39;, //默认的错误码 1005:&#39;appkey无效，请申请&#39;, 3000:&#39;期刊不存在&#39; } class HTTP{ request(params){ //url,method,data, wx.request({ url:config.api_base_url+params.url, method:params.method, data:params.data, header:{ &#39;content-type&#39;:&#39;application/json&#39;, &#39;appkey&#39;:config.appkey }, success: (res)=&gt;{//访问服务器得到的数据 let code = res.statusCode.toString() if (code.startsWith(&#39;2&#39;)){ //状态码是2开头，成功，否则失败 params.success(res.data)//结果返回回去 } else{ //服务器异常 let error_code = res.data.error_code this._show_error(error_code) } }, fail:(err)=&gt;{ //API调用失败 // wx.showToast({ //向用户提供错误信息，接收json对象 // title: &#39;错误&#39;, //向用户提示的文字 // icon:&#39;none&#39;, // duration:&#39;2000&#39; //设置showToast的显示时间 // }) this._show_error(1) } }) } _show_error(error_code){//标注表示私有方法 if(!error_code){ error_code = 1 } wx.showToast({ title: tips[error_code], icon:&#39;none&#39;, duration:2000 }) } } export{HTTP} 流行页面编码与组件的细节*引入model概念根目录下新建models文件夹，文件夹下新建classic.js文件 之前在pages的classic文件下onload函数里调用http的request方法，现在在models/classic的getlatest方法中发送http请求 #models/classic.js import {HTTP} from &#39;../util/http.js&#39; class ClassicModel extends HTTP{类继承 getLatest(){ this.request({通过继承来引用方法的话不用实例化了 url:&#39;classic/latest&#39;, success:(res)=&gt;{//res为http中得到的服务器数据res.data } }) } } export {ClassModel} 回到主调方pages下的classic.js，想在onload中接收到API的请求结果，该何如调用？ 既然有了model,通过model的调用来获取API的结果 怎么接受getlatest方法的调用结果呢？ let latest = classic.getlatest() 错误，getlatest是一个异步的方法。为什么getlatest是一个异步的方法呢？关于js的callback回调函数以及嵌套回调函数的执行过程理解 希望接受异步函数的调用结果只能用回调函数，我们把这个回调函数当做参数传到getLatest（）中，getLatest中接受这个参数，sCallback #pages下的classic.js import {ClassicModel} from &#39;../../models/classic.js&#39; let classic = new classicModel() onLoad: function (options) { classic.getLatest((res)=&gt;{ console.log(res) } )//异步的方法 }, #classic.js import {HTTP} from &#39;../util/http.js&#39; class ClassicModel extends HTTP{ getLatest(sCallback){//去服务器加载最新的期刊,getLast中需要接收这个回调函数,用sCallback， this.request({通过继承来引用方法的话不用实例化了 url:&#39;classic/latest&#39;, success:(res)=&gt;{ //访问成功，success函数接收到api的调用结果后调用sCallback函数把结果回传回去 sCallback(res) } }) } } export {ClassModel} 使用回调函数剥夺了函数return的能力 有什么办法能在执行getLatest方法后通过变量等于的方式接收到此次调用的结果？有，promise 组件属性赋值与页面渲染流程现在已经成功在getLates()回调函数中拿到服务器回传的数据，拿到数据后做什么？ 把数据显示在页面上。页面由一个个组件构成，我们要把从服务器取到的数据传入组件内部让组件显示这个数据。 如like组件，把js中的数据传达页面上，调用setData函数 #classic.js data: { classicData:null }, onLoad: function (options) { classic.getLatest((res)=&gt;{ this.setData({//接受json对象 classicData:res }) }) }, 如何把like组件需要的数据传到like组件中？ 从组件的外部设置组件的属性 #classic.wxml &lt;v-like like=&quot;{{classicData.like_status}}&quot; count = &quot;{{classicData.fav_nums}}&quot; like_status是classicData(json)对象的一个属性 在小程序setData中所有的js对象可以在调试器中看到 调试器——AppData,快速查找设置属性的名字 流程：在页面的classic.js中加载服务器数据——数据绑定——wxml可以使用数据——-通过组属性传递到组件内部 setData：做数据更新 movie组件的实现components目录下新建文件夹classic，文件夹下新建movie文件夹，新建index的component文件。 在index.wxml下编写骨架 #index.wxml &lt;view&gt; &lt;image&gt;&lt;/image&gt; &lt;image&gt;&lt;/image&gt; &lt;text&gt;&lt;/text&gt; &lt;/view&gt; 完成骨架后，有两个 问题需要解决1.骨架的样式2.骨架中需要填入数据 思考数据的思路：data内部数据（小图片电影）和properties属性数据(文本图片，大图片) #index.js properties:{ img:String content:String }, movie下新建文件夹images,存放movie@tag.png #index.wxml &lt;view&gt; &lt;image src=&quot;{{img}}&quot;&gt;&lt;/image&gt; &lt;image src=&quot;images/movie@tag.png&quot;&gt;&lt;/image&gt; &lt;text&gt;{{content}}&lt;/text&gt; &lt;/view&gt; classic.json引用movie-cmp组件 { &quot;usingComponents&quot;: { &quot;like-cmp&quot;:&quot;/components/like/index&quot;, &quot;movie-cmp&quot;:&quot;/components/classic/movie/index&quot; } } classsic.wxml中引用组件 &lt;like-cmp like=&quot;{{classicData.like_status}}&quot; count=&quot;{{classicData.fav_nums}}&quot;/&gt; &lt;movie-cmp img=&quot;{{classicData.image}}&quot; content=&quot;{{classicData.content}}&quot; index.wxss编写样式 #index.wxml &lt;view class=&quot;classic-container&quot;&gt; &lt;image class=&quot;class-img&quot; src=&quot;{{img}}&quot;&gt;&lt;/image&gt; &lt;image clasa=&quot;tag&quot; src=&quot;images/movie@tag.png&quot;&gt;&lt;/image&gt; &lt;text class=&quot;ccontent&quot;&gt;{{content}}&lt;/text&gt; &lt;/view&gt; .classic-container{ display:flex; flex-direction:column, align-items:center //所有元素居中对齐 } .classic-img{ width:750rpx; height:500rpx, } .tag{ width:46rpx; height:142rpx; position:relative;//是相对当前位置的偏移 right:310rpx; bottom:58rpx; } .content{ font-size:36rpx; max-width:550rpx; //文本换行(不固定宽度，自适应) } 再谈组件通过组件提交数据到服务器","categories":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"/tags/小程序/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}]},{"title":"SQL教程","slug":"SQL教程","date":"2020-07-22T14:28:11.000Z","updated":"2020-07-22T14:31:16.912Z","comments":true,"path":"2020/07/22/SQL教程/","link":"","permalink":"/2020/07/22/SQL教程/","excerpt":"","text":"SQL教程SQL是访问和处理关系数据库的计算机标准语言。 关系数据库概述应用程序需要保存用户的数据，要保存用户的数据，一个最简单的方法是把用户数据写入文件。例如，要保存一个班级所有学生的信息，可以向文件中写入一个CSV文件： id,name,gender,score 1,小明,M,90 2,小红,F,95 3,小军,M,88 4,小丽,F,88 但是，随着应用程序的功能越来越复杂，数据量越来越大，管理这些数据就成了大问题： 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑。 数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心： ┌──────────────┐ │ application │ └──────────────┘ ▲│ ││ read││write ││ │▼ ┌──────────────┐ │ database │ └──────────────┘ 数据模型数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型： 层次模型 网状模型 关系模型 层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树。 网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网。 关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表： 随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。 基于数学理论的关系模型虽然讲起来挺复杂，但是，基于日常生活的关系模型却十分容易理解。我们以学校班级为例，一个班级的学生就可以用一个表格存起来，并且定义如下： 其中，班级ID对应着另一个班级表： 通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。 数据类型对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等： 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-10^38 DOUBLE 浮点型 8字节浮点数，范围约+/-10^308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，REAL又可以写成FLOAT(24)。还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。 选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。 主流关系数据库目前，主流的关系数据库主要分为以下几类： 商用数据库，例如：Oracle，SQL Server，DB2等； 开源数据库，例如：MySQL，PostgreSQL等； 桌面数据库，以微软Access为代表，适合桌面应用程序使用； 嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。 SQLSQL是结构化查询语言(Structured Query Language)的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。 不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。 虽然SQL已经被ANSI组织定义为标准，但是各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。 现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。 总的来说，SQL语言定义了这么几种操作数据库的能力： DDL：Data Definition Language ​ DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 DML：Data Manipulation Language ​ DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 DQL：Data Query Language ​ DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。 语法特点SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。 所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。 安装MySQLMySQL是目前应用最广泛的开源关系数据库。MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括： InnoDB：一款支持事务的数据库引擎。 MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。 MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。 使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。 MySQL官方版本分了好几个版本： Community Edition：社区开源版本，免费； Standard Edition：标准版； Enterprise Edition：企业版； Cluster Carrier Grade Edition：集群版。 以上版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。 安装MySQL要在Windows或Mac上安装MySQL，首先从MySQL官方网站下载最新的MySQL Community Server版本： https://dev.mysql.com/downloads/mysql/ 选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个root用户，并提示输入root口令。 要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令apt-get install mysql-server安装最新的MySQL版本。 运行MySQLMySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过mysql这个命令行程序来连接MySQL服务器。 在命令提示符下输入mysql -u root -p，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为mysql&gt;。 输入exit退出MySQL命令行。注意，MySQL服务器仍在后台运行。 关系模型关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。 表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。 字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串&#39;&#39;。 通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。 和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。 例如，一个班级表： 每一行对应着一个班级，而一个班级对应着多个学生，所以班级表和学生表的关系就是“一对多”： 反过来，如果我们先在学生表中定位了一行记录，例如ID=1的小明，要确定他的班级，只需要根据他的“班级ID”对应的值201找到班级表中ID=201的记录，即二年级一班。所以，学生表和班级表是“多对一”的关系。 如果我们把班级表分拆得细一点，例如，单独创建一个教师表： 班级表只存储教师ID： 这样，一个班级总是对应一个教师，班级表和教师表就是“一对一”关系。 在关系数据库中，关系是通过主键和外键来维护的。 主键 主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。 可以使用多个列作为联合主键，但联合主键并不常用。 在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的 对于关系表，有个很重要的约束，任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。 例如，假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。 对主键的要求，最关键的一点：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 对于大部分应用来说，通常自增类型的主键就能满足需求。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。 联合主键关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 对于联合主键，允许一列有重复，只要不是所有主键列都重复即可： 如果我们把上述表的id_num和id_type这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 外键 关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。 当我们用主键唯一标识记录时，我们就可以在students表中确定任意一个学生的记录： id name other columns… 1 小明 … 2 小红 … 我们还可以在classes表中确定任意一个班级记录： id name other columns… 1 一班 … 2 二班 … 如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？ 由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个classes的记录可以对应多个students表的记录。为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应： id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 例如： 小明的class_id是1，因此，对应的classes表的记录是id=1的一班； 小红的class_id是1，因此，对应的classes表的记录是id=1的一班； 小白的class_id是2，因此，对应的classes表的记录是id=2的二班。 在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。 外键并不是通过列名实现的，而是通过定义外键约束实现的： ALTER TABLE students ADD CONSTRAINT fk_class_id FOREIGN KEY (class_id) REFERENCES classes (id); 其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 要删除一个外键约束，也是通过ALTER TABLE实现的： ALTER TABLE students DROP FOREIGN KEY fk_class_id; 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 多对多通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系： teachers表： id name 1 张老师 2 王老师 3 李老师 4 赵老师 classes表： id name 1 一班 2 二班 中间表teacher_class关联两个一对多关系： id teacher_id class_id 1 1 1 2 1 2 3 2 1 4 2 2 5 3 1 6 4 2 通过中间表teacher_class可知teachers到classes的关系： id=1的张老师对应id=1,2的一班和二班； id=2的王老师对应id=1,2的一班和二班； id=3的李老师对应id=1的一班； id=4的赵老师对应id=2的二班。 同理可知classes到teachers的关系： id=1的一班对应id=1,2,3的张老师、王老师和李老师； id=2的二班对应id=1,2,4的张老师、王老师和赵老师； 因此，通过中间表，我们就定义了一个“多对多”关系。 一对一一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。 例如，students表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表contacts，我们就可以得到一个“一对一”关系： id student_id mobile 1 1 135xxxx6300 2 2 138xxxx2209 3 5 139xxxx8086 有细心的童鞋会问，既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？ 如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，一对一关系准确地说，是contacts表一对一对应students表。 还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。 索引索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 通过对数据库表创建索引，可以提高查询速度。 通过创建唯一索引，可以保证某一列的值具有唯一性。 数据库索引对于用户和应用程序来说都是透明的。 例如，对于students表： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 如果要经常根据score列进行查询，就可以对score列创建索引： ALTER TABLE students ADD INDEX idx_score (score); 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如： ALTER TABLE students ADD INDEX idx_name_score (name, score); 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 唯一索引在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复： ALTER TABLE students ADD UNIQUE INDEX uni_name (name); 通过UNIQUE关键字我们就添加了一个唯一索引。 也可以只对某一列添加一个唯一约束而不创建唯一索引： ALTER TABLE students ADD CONSTRAINT uni_name UNIQUE (name); 这种情况下，name列没有索引，但仍然具有唯一性保证。 无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。 查询数据在关系数据库中，最常用的操作就是查询。 基本查询要查询数据库表的数据，我们使用如下的SQL语句： SELECT * FROM &lt;表名&gt; 假设表名是students，要查询students表的所有行，我们用如下SQL语句： SELECT * FROM students; 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句： SELECT 100+200; 100 + 200 300 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 条件查询使用SELECT * FROM &lt;表名&gt;可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。 SELECT语句可以通过WHERE条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是SELECT * FROM students WHERE score &gt;= 80。 其中，WHERE关键字后面的score &gt;= 80就是条件。score是列名，该列存储了学生的成绩，因此，score &gt;= 80就筛选出了指定条件的记录： 因此，条件查询的语法就是： SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; 条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。 SELECT * FROM students WHERE score &gt;= 80 AND gender = &#39;M&#39;; 第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。 SELECT * FROM students WHERE score &gt;= 80 OR gender = &#39;M&#39;; 第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。 例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：class_id = 2，再加上NOT：NOT class_id = 2： SELECT * FROM students WHERE NOT class_id = 2; 上述NOT条件NOT class_id = 2其实等价于class_id &lt;&gt; 2，因此，NOT查询不是很常用。 要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生： SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#39;M&#39;; 如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。 常用的条件表达式 条件 表达式举例1 表达式举例2 说明 使用=判断相等 score = 80 name = ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;=判断大于或相等 score &gt;= 80 name &gt;= ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;= ‘abc’ 使用&lt;=判断小于或相等 score &lt;= 80 name &lt;= ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’ 投影查询 使用SELECT *表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。 SELECT语句可以对结果集的列进行重命名。 使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 例如，从students表中返回id、score和name这三列： SELECT id, score, name FROM students; 这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。 使用SELECT 列1, 列2, 列3 FROM ...时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...。 例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变： SELECT id, score points, name FROM students; 投影查询同样可以接WHERE条件，实现复杂的查询： SELECT id, score points, name FROM students WHERE gender = &#39;M&#39;; 排序 使用ORDER BY可以对结果集进行排序； 可以对多列进行升序、倒序排序。 我们使用SELECT查询时，查询结果集通常是按照id排序的，也就是根据主键排序。 如果我们要根据其他条件排序怎么办？可以加上ORDER BY子句。例如按照成绩从低到高进行排序： SELECT id, name, gender, score FROM students ORDER BY score; 如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”： SELECT id, name, gender, score FROM students ORDER BY score DESC; 如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序： SELECT id, name, gender, score FROM students ORDER BY score DESC, gender; 默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序： SELECT id, name, gender, score FROM students WHERE class_id = 1 ORDER BY score DESC; 这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。 分页查询分页使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现。我们先把所有学生按照成绩从高到低进行排序： SELECT id, name, gender, score FROM students ORDER BY score DESC; 现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0 -- 查询第1页 SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 0; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。 如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3： -- 查询第2页 SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 3; 类似的，查询第3页的时候，OFFSET应该设定为6。 可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT总是设定为pageSize； OFFSET计算公式为pageSize * (pageIndex - 1)。 这样就能正确查询出第N页的记录集。 如果原本记录集一共就10条记录，但我们把OFFSET设置为20，会得到什么结果呢？ OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。 注意OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 聚合查询对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询： SELECT COUNT(*) FROM students; COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果： -- 使用聚合查询并设置结果集的列名为num: SELECT COUNT(*) num FROM students; COUNT(*)和COUNT(id)实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等： -- 使用聚合查询并设置WHERE条件: SELECT COUNT(*) boys FROM students WHERE gender = &#39;M&#39;; 除了COUNT()函数外，SQL还提供了如下聚合函数： 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 要统计男生的平均成绩，我们用下面的聚合查询： SELECT AVG(score) average FROM students WHERE gender = &#39;M&#39; 要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL。 分组如果我们要统计一班的学生数量，我们知道，可以用SELECT COUNT(*) num FROM students WHERE class_id = 1;。如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？ 对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询： -- 按class_id分组: SELECT COUNT(*) num FROM students GROUP BY class_id; num 4 3 3 执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。 但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中： -- 按class_id分组: SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; class_id num 1 4 2 3 3 3 这下结果集就可以一目了然地看出各个班级的学生人数。 我们再试试把name放入结果集： SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id; 不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数： -- 按class_id, gender分组: SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender; class_id gender num 1 M 2 1 F 2 2 F 1 2 M 2 3 F 2 3 M 1 多表查询ELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 这种一次查询两个表的数据，查询的结果也是一个二维表，它是A表和B表的“乘积”，即A表的每一行与B表的每一行都两两拼在一起返回。结果集的列数是A表和B表的列数之和，行数是A表和B表的行数之积。 SELECT * FROM students, classes; 上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理 要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名： SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cname FROM students, classes; 多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点： SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c; 注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。 多表查询也是可以添加WHERE条件的 SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c WHERE s.gender = &#39;M&#39; AND c.id = 1; 这个查询的结果集每行记录都满足条件s.gender = &#39;M&#39;和c.id = 1。添加WHERE条件后结果集的数量大大减少了。 连接查询 JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;； JOIN查询仍然可以使用WHERE条件和ORDER BY排序。 连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成： -- 选出所有学生 SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s; 假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 内连接这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现： SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s INNER JOIN classes c on s.class_id = c.id; 注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 使用别名不是必须的，但可以更好地简化查询语句。 外连接有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果： SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s RIGHT OUTER JOIN classes c ON s.class_id = c.id; 执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。 因为根据ON条件s.class_id = c.id，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。 有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是： INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。 RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。 LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL： 最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL。 假设查询语句是： SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： LEFT OUTER JOIN是选出左表存在的记录： RIGHT OUTER JOIN是选出右表存在的记录： FULL OUTER JOIN则是选出左右表都存在的记录： 修改数据关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。 而对于增、删、改，对应的SQL语句分别是： INSERT：插入新记录； UPDATE：更新已有记录； DELETE：删除已有记录。 INSERT 使用INSERT，我们就可以一次向一个表中插入一条或多条记录。 当我们需要向数据库表中插入一条新记录时，就必须使用INSERT语句。 INSERT语句的基本语法是： INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); 例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值： -- 添加一条新记录 INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) ...，但是对应的VALUES就得变成(80, &#39;M&#39;, &#39;大牛&#39;, 2)。 -- 查询并观察结果: SELECT * FROM students; 注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。 字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) ...，但是对应的VALUES就得变成(80, &#39;M&#39;, &#39;大牛&#39;, 2)。 还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(...)包含的一组值： -- 一次性添加多条新记录 INSERT INTO students (class_id, name, gender, score) VALUES (1, &#39;大宝&#39;, &#39;M&#39;, 87), (2, &#39;二宝&#39;, &#39;M&#39;, 81); SELECT * FROM students; UPDATE 使用UPDATE，我们就可以一次更新表中的一条或多条记录。 更新数据库表中的记录，我们就必须使用UPDATE语句。 UPDATE语句的基本语法是： UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 例如，我们想更新students表id=1的记录的name和score这两个字段，先写出UPDATE students SET name=&#39;大牛&#39;, score=66，然后在WHERE子句中写出需要更新的行的筛选条件id=1： -- 更新id=1的记录 UPDATE students SET name=&#39;大牛&#39;, score=66 WHERE id=1; -- 查询并观察结果: SELECT * FROM students WHERE id=1; 注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录。 -- 更新id=5,6,7的记录 UPDATE students SET name=&#39;小牛&#39;, score=77 WHERE id&gt;=5 AND id&lt;=7; 在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分： -- 更新score&lt;80的记录 UPDATE students SET score=score+10 WHERE score&lt;80; 其中，SET score=score+10就是给当前行的score字段的值加上了10。 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。 最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如： UPDATE students SET score=60; 这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。 MySQL在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。 例如，更新id=1的记录时： mysql&gt; UPDATE students SET name=&#39;大宝&#39; WHERE id=1; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 MySQL会返回1，可以从打印的结果Rows matched: 1 Changed: 1看到。 当更新id=999的记录时： mysql&gt; UPDATE students SET name=&#39;大宝&#39; WHERE id=999; Query OK, 0 rows affected (0.00 sec) Rows matched: 0 Changed: 0 Warnings: 0 MySQL会返回0，可以从打印的结果Rows matched: 0 Changed: 0看到。 DELETE 使用DELETE，我们就可以一次删除表中的一条或多条记录。 如果要删除数据库表中的记录，我们可以使用DELETE语句。 DELETE语句的基本语法是： DELETE FROM &lt;表名&gt; WHERE ...; 例如，我们想删除students表中id=1的记录，就需要这么写： -- 删除id=1的记录 DELETE FROM students WHERE id=1; 注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录。 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。 最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据： DELETE FROM students; 这时，整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。 MySQL在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。 例如，分别执行删除id=1和id=999的记录： mysql&gt; DELETE FROM students WHERE id=1; Query OK, 1 row affected (0.01 sec) mysql&gt; DELETE FROM students WHERE id=999; Query OK, 0 rows affected (0.01 sec) MySQL 命令行程序mysql实际上是MySQL客户端，真正的MySQL服务器程序是mysqld，在后台运行 安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。 打开命令提示符，输入命令mysql -u root -p，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为mysql&gt;： 输入exit断开与MySQL Server的连接并返回到命令提示符。 MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。 MySQL Client和MySQL Server的关系如下： ┌──────────────┐ SQL ┌──────────────┐ │ MySQL Client │───────&gt;│ MySQL Server │ └──────────────┘ TCP └──────────────┘ 在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。 也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名： mysql -h 10.0.1.99 -u root -p 管理MySQL数据库在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令： mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | shici | | sys | | test | | school | +--------------------+ 其中，information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。 要创建一个新数据库，使用命令： mysql&gt; CREATE DATABASE test; Query OK, 1 row affected (0.01 sec) 要删除一个数据库，使用命令： mysql&gt; DROP DATABASE test; Query OK, 0 rows affected (0.01 sec) 注意：删除一个数据库将导致该数据库的所有表全部被删除。 对一个数据库进行操作时，要首先将其切换为当前数据库： mysql&gt; USE test; Database changed 表列出当前数据库的所有表，使用命令： mysql&gt; SHOW TABLES; +---------------------+ | Tables_in_test | +---------------------+ | classes | | statistics | | students | | students_of_class1 | +---------------------+ 要查看一个表的结构，使用命令： mysql&gt; DESC students; +----------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +----------+--------------+------+-----+---------+----------------+ | id | bigint(20) | NO | PRI | NULL | auto_increment | | class_id | bigint(20) | NO | | NULL | | | name | varchar(100) | NO | | NULL | | | gender | varchar(1) | NO | | NULL | | | score | int(11) | NO | | NULL | | +----------+--------------+------+-----+---------+----------------+ 5 rows in set (0.00 sec) 还可以使用以下命令查看创建表的SQL语句： mysql&gt; SHOW CREATE TABLE students; +----------+-------------------------------------------------------+ | students | CREATE TABLE `students` ( | | | `id` bigint(20) NOT NULL AUTO_INCREMENT, | | | `class_id` bigint(20) NOT NULL, | | | `name` varchar(100) NOT NULL, | | | `gender` varchar(1) NOT NULL, | | | `score` int(11) NOT NULL, | | | PRIMARY KEY (`id`) | | | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 | +----------+-------------------------------------------------------+ 1 row in set (0.00 sec) 创建表使用CREATE TABLE语句，而删除表使用DROP TABLE语句： mysql&gt; DROP TABLE students; Query OK, 0 rows affected (0.01 sec) 修改表就比较复杂。如果要给students表新增一列birth，使用： ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL; 要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)： ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL; 要删除列，使用： ALTER TABLE students DROP COLUMN birthday; 退出MySQL使用EXIT命令退出MySQL： mysql&gt; EXIT Bye 注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。 实用SQL语句插入或替换如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入： REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99); 若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。 插入或更新如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句： INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name=&#39;小明&#39;, gender=&#39;F&#39;, score=99; 若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。 插入或忽略如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句： INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99); 若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。 快照如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT： -- 对class_id=1的记录进行快照，并存储为新表students_of_class1: CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1; 新创建的表结构和SELECT使用的表结构完全一致。 写入查询结果集如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。 例如，创建一个统计成绩的表statistics，记录各班的平均成绩： CREATE TABLE statistics ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, average DOUBLE NOT NULL, PRIMARY KEY (id) ); 然后，我们就可以用一条语句写入各班的平均成绩： INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id; 确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果： &gt; SELECT * FROM statistics; +----+----------+--------------+ | id | class_id | average | +----+----------+--------------+ | 1 | 1 | 86.5 | | 2 | 2 | 73.666666666 | | 3 | 3 | 88.333333333 | +----+----------+--------------+ 3 rows in set (0.00 sec) 强制使用指定索引在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。例如： &gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; 指定索引的前提是索引idx_class_id必须存在。 事务在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作： -- 从id=1的账户给id=2的账户转账100元 -- 第一步：将id=1的A账户余额减去100 UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- 第二步：将id=2的B账户余额加上100 UPDATE accounts SET balance = balance + 100 WHERE id = 2; 这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。 这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。 数据库事务具有ACID这4个特性： A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。 对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。 要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务，例如，把上述的转账操作作为一个显式事务： BEGIN; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; 很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。 COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。 有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败： BEGIN; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; ROLLBACK; 数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以 隔离级别​ 对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。 SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况： Isolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - 我们会依次介绍4种隔离级别的数据一致性问题。 Read Uncommitted​ Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。 首先，我们准备好students表的数据，该表仅一行记录： mysql&gt; select * from students; +----+-------+ | id | name | +----+-------+ | 1 | Alice | +----+-------+ 1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 2 BEGIN; BEGIN; 3 UPDATE students SET name = ‘Bob’ WHERE id = 1; 4 SELECT * FROM students WHERE id = 1; 5 ROLLBACK; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; 当事务A执行完第3步时，它更新了id=1的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。 随后，事务A在第5步进行了回滚，事务B再次读取id=1的记录，发现和上一次读取到的数据不一致，这就是脏读。 可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。 Read Committed在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。 不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。 我们仍然先准备好students表的数据： mysql&gt; select * from students; +----+-------+ | id | name | +----+-------+ | 1 | Alice | +----+-------+ 1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 2 BEGIN; BEGIN; 3 SELECT * FROM students WHERE id = 1; 4 UPDATE students SET name = ‘Bob’ WHERE id = 1; 5 COMMIT; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; 当事务B第一次执行第3步的查询时，得到的结果是Alice，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了Bob，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。 Repeatable Read在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。 幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。 我们仍然先准备好students表的数据： mysql&gt; select * from students; +----+-------+ | id | name | +----+-------+ | 1 | Alice | +----+-------+ 1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 2 BEGIN; BEGIN; 3 SELECT * FROM students WHERE id = 99; 4 INSERT INTO students (id, name) VALUES (99, ‘Bob’); 5 COMMIT; 6 SELECT * FROM students WHERE id = 99; 7 UPDATE students SET name = ‘Alice’ WHERE id = 99; 8 SELECT * FROM students WHERE id = 99; 9 COMMIT; ​ 事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。 可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。 SerializableSerializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。 虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。 默认隔离级别如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[]},{"title":"Java教程笔记之泛型","slug":"Java教程笔记之泛型","date":"2020-07-04T09:14:51.000Z","updated":"2020-07-04T09:14:49.141Z","comments":true,"path":"2020/07/04/Java教程笔记之泛型/","link":"","permalink":"/2020/07/04/Java教程笔记之泛型/","excerpt":"","text":"泛型是一种“代码模板”，可以用一套代码套用各种类型。 泛型什么是泛型以ArrayList举例，它可以看做可变长度的数组，因此用起来比数组更方便。实际上ArrayList内部就是一个object[]数组，配合存储一个当前分配的长度，就可以充当“可变数组”： public class ArrayList{ private Object[] array; private int size; public void add(Object e){...} public void remove(int index){...} public Object get(int index){...} } 如果用上述ArrayList存储String类型，会有这么几个缺点： 需要强制转型； 不方便，易出错。 例如，代码必须这么写： ArrayList list = new ArrayList(); list.add(&quot;Hello&quot;); // 获取到Object，必须强制转型为String: String first = (String) list.get(0); 很容易出现ClassCastException，因为容易“误转型”： list.add(new Integer(123)); // ERROR: ClassCastException: String second = (String) list.get(1); 要解决上述问题，我们可以为String单独编写一种ArrayList： public class StringArrayList{ private String[] array; private int size; public void add(String e){...} public void remove(int index){...} public Object get(int index){...} } 这样一来，存入的必须是String，取出的也一定是String，不需要强制转型，因为编译器会强制检查放入的类型： StringArrayList list = new StringArrayList(); list.add(&quot;Hello&quot;); String first = list.get(0); list.add(new Integer(123));// 编译错误: 不允许放入非String类型: 然而，新的问题是，如果要存储Integer，还需要为Integer单独编写一种ArrayList,实际上，还需要为其他所有class单独编写一种ArrayList： LongArrayList DoubleArrayList PersonArrayList … 这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。为了解决新的问题，我们必须把ArrayList变成一种模板：ArrayList&lt;T&gt;，代码如下： public class ArrayList&lt;T&gt;{ private T[] array; private int size; public void add(T e){...} public void remove(int index){...} public Object get(int index){...} } T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList： // 创建可以存储String的ArrayList: ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;(); // 创建可以存储Float的ArrayList: ArrayList&lt;Float&gt; floatList = new ArrayList&lt;Float&gt;(); // 创建可以存储Person的ArrayList: ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); 因此，泛型就是定义一种模板，例如ArrayList，然后在代码中为用到的类创建对应的ArrayList&lt;类型&gt;： ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;(); 由编译器针对类型作检查： strList.add(&quot;hello&quot;); // OK String s = strList.get(0); // OK strList.add(new Integer(123)); // compile error! Integer n = strList.get(0); // compile error! 这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。 向上转型在Java标准库中的ArrayList实现了List接口，它可以向上转型为List： public class ArrayList&lt;T&gt; implements List&lt;T&gt; { ... } List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 即类型ArrayList&lt;T&gt;可以向上转型为List&lt;T&gt; 要特别注意：不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;或List&lt;Number&gt;。 这是为什么呢？假设ArrayList&lt;Integer&gt;可以向上转型为ArrayList&lt;Number&gt;，观察一下代码： // 创建ArrayList&lt;Integer&gt;类型： ArrayList&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;(); // 添加一个Integer： integerList.add(new Integer(123)); // “向上转型”为ArrayList&lt;Number&gt;： ArrayList&lt;Number&gt; numberList = integerList; // 添加一个Float，因为Float也是Number： numberList.add(new Float(12.34)); // 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）： Integer n = integerList.get(1); // ClassCastException! 我们把一个ArrayList&lt;Integer&gt;转型为ArrayList&lt;Number&gt;类型后，这个ArrayList&lt;Number&gt;就可以接受Float类型，因为Float是Number的子类。但是，ArrayList&lt;Number&gt;实际上和ArrayList&lt;Integer&gt;是同一个对象，也就是ArrayList&lt;Integer&gt;类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。 实际上，编译器为了避免这种错误，根本就不允许把ArrayList&lt;Integer&gt;转型为ArrayList&lt;Number&gt;。 ArrayList&lt;Integer&gt;和ArrayList&lt;Number&gt;两者完全没有继承关系。 小结泛型就是编写模板代码来适应任意类型； 泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查； 注意泛型的继承关系：可以把ArrayList&lt;Integer&gt;向上转型为List&lt;Integer&gt;（T不能变！），但不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;（T不能变成父类）。 使用泛型使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object： // 编译器警告: List list = new ArrayList(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); String first = (String) list.get(0); String second = (String) list.get(1); 此时，只能把&lt;T&gt;当作Object使用，没有发挥泛型的优势。 当我们定义泛型类型&lt;String&gt;后，List&lt;T&gt;的泛型接口变为强类型List&lt;String&gt;： // 无编译器警告: List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); // 无强制转型: String first = list.get(0); String second = list.get(1); 类似，当我们定义泛型类型&lt;Number&gt;后，List&lt;T&gt;的泛型接口变为强类型List&lt;Number&gt;： List&lt;Number&gt; list = new ArrayList&lt;Number&gt;(); list.add(new Integer(123)); list.add(new Double(12.34)); Number first = list.get(0); Number second = list.get(1); 编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码： List&lt;Number&gt; list = new ArrayList&lt;Number&gt;(); 编译器看到泛型类型List&lt;Number&gt;就可以自动推断出后面的ArrayList&lt;T&gt;的泛型类型必须是ArrayList&lt;Number&gt;，因此，可以把代码简写为： // 可以省略后面的Number，编译器可以自动推断泛型类型： List&lt;Number&gt; list = new ArrayList&lt;&gt;(); 泛型接口除了ArrayList&lt;T&gt;使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable&lt;T&gt;这个泛型接口： public interface Comparable&lt;T&gt; { /** * 返回-1: 当前实例比参数o小 * 返回0: 当前实例与参数o相等 * 返回1: 当前实例比参数o大 */ int compareTo(T o); } 可以直接对String数组进行排序： public class Main { public static void main(String[] args) { String[] ss = new String[] { &quot;Orange&quot;, &quot;Apple&quot;, &quot;Pear&quot; }; Arrays.sort(ss); System.out.println(Arrays.toString(ss)); } } 这是因为String本身已经实现了Comparable&lt;T&gt;接口。 对自定义的Person类型试试： import java.util.Arrays; public class Main { public static void main(String[] args) { Person[] ps = new Person[] { new Person(&quot;Bob&quot;, 61), new Person(&quot;Alice&quot;, 88), new Person(&quot;Lily&quot;, 75), }; Arrays.sort(ps); System.out.println(Arrays.toString(ps)); } } 实现正确的泛型类型： class Person implements Comparable&lt;Person&gt; { String name; int score; Person(String name, int score) { this.name = name; this.score = score; } public int compareTo(Person other) {// return this.name.compareTo(other.name); } public String toString() { return this.name + &quot;,&quot; + this.score; } } 小结使用泛型时，把泛型参数T替换为需要的class类型，例如：ArrayList&lt;String&gt;，ArrayList&lt;Number&gt;等； 可以省略编译器能自动推断出的类型，例如：List&lt;String&gt; list = new ArrayList&lt;&gt;();； 不指定泛型参数类型时，编译器会给出警告，且只能将T视为Object类型； 可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。 编写泛型泛型类一般用在集合类中，我们很少需要编写泛型类。如果确实需要编写一个泛型类，可以按照以下步骤来编写： 首先，按照某种类型，例如：String，来编写类： public class Pair { private String first; private String last; public Pair(String first, String last) { this.first = first; this.last = last; } public String getFirst() { return first; } public String getLast() { return last; } } 标记所有的特定类型，这里是String,把特定类型String替换为T，并申明&lt;T&gt;： public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; } } 熟练后即可直接从T开始编写。 静态方法要特别注意，泛型类型&lt;T&gt;不能用于静态方法。 public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 对静态方法使用&lt;T&gt;: public static Pair&lt;T&gt; create(T first, T last) {//编译错误 return new Pair&lt;T&gt;(first, last); } } 上述代码会导致编译错误，我们无法在静态方法create()的方法参数和返回类型上使用泛型类型T。 对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如，&lt;K&gt;： public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 静态泛型方法应该使用其他类型区分: //静态方法由于随着类的加载而加载，不能访问类的泛型（因为在创建对象的时候才确定），因此必须定义自己的泛型类型。 public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) { return new Pair&lt;K&gt;(first, last); } } 这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。 多个泛型类型泛型还可以定义多种类型。例如，我们希望Pair存储两个类型不一样的对象，就可以使用类型``： public class Pair&lt;T, K&gt; { private T first; private K last; public Pair(T first, K last) { this.first = first; this.last = last; } public T getFirst() { ... } public K getLast() { ... } } 使用的时候，需要指出两种类型： Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(&quot;test&quot;, 123); Java标准库的Map就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。 小结编写泛型时，需要定义泛型类型&lt;T&gt;； 静态方法不能引用泛型类型&lt;T&gt;，必须定义其他类型（例如&lt;K&gt;）来实现静态泛型方法； 泛型可以同时定义多种类型，例如Map&lt;K,V&gt;。 擦拭法泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。 Java语言的泛型实现方式是擦拭法（Type Erasure）。所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。 例如，我们编写了一个泛型类Pair，这是编译器看到的代码： public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; } } 而虚拟机根本不知道泛型。这是虚拟机执行的代码： public class Pair { private Object first; private Object last; public Pair(Object first, Object last) { this.first = first; this.last = last; } public Object getFirst() { return first; } public Object getLast() { return last; } } 因此，Java使用擦拭法实现泛型，导致了： 编译器把类型&lt;T&gt;视为Object； 编译器根据&lt;T&gt;实现安全的强制转型。 使用泛型的时候，我们编写的代码也是编译器看到的代码： Pair&lt;String&gt; p = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;); String first = p.getFirst(); String last = p.getLast(); 而虚拟机执行的代码并没有泛型： Pair p = new Pair(&quot;Hello&quot;, &quot;world&quot;); //在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。 String first = (String) p.getFirst(); String last = (String) p.getLast(); 所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。 Java泛型的局限局限一：`不能是基本类型，例如int，因为实际类型是Object，Object`类型无法持有基本类型： Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error! 局限二：无法取得带泛型的Class。观察以下代码： public class Main { public static void main(String[] args) { Pair&lt;String&gt; p1 = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;); Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456); Class c1 = p1.getClass(); Class c2 = p2.getClass(); System.out.println(c1==c2); // true System.out.println(c1==Pair.class); // true } } class Pair&lt;T&gt; { ...... } 我们对Pair&lt;String&gt;和Pair&lt;Integer&gt;类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。 换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair&lt;Object&gt;。 局限三：无法判断带泛型的类型： Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456); // Compile error: if (p instanceof Pair&lt;String&gt;) { } 原因和前面一样，并不存在Pair.class，而是只有唯一的Pair.class。 局限四：不能实例化T类型： public class Pair&lt;T&gt; { private T first; private T last; public Pair() { // Compile error: first = new T(); last = new T(); } } 上述代码无法通过编译，因为构造方法的两行语句： first = new T(); last = new T(); 擦拭后实际上变成了： first = new Object(); last = new Object(); 这样一来，创建new Pair&lt;String&gt;()和创建new Pair&lt;Integer&gt;()就全部成了Object，显然编译器要阻止这种类型不对的代码。 要实例化T类型，我们必须借助额外的Class参数： public class Pair&lt;T&gt; { private T first; private T last; public Pair(Class&lt;T&gt; clazz) { first = clazz.newInstance(); last = clazz.newInstance(); } } 上述代码借助Class&lt;T&gt;参数并通过反射来实例化T类型，使用的时候，也必须传入Class。例如： Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class); 因为传入了Class的实例，所以我们借助String.class就可以实例化String类型。 泛型继承一个类可以继承自一个泛型类。例如：父类的类型是Pair，子类的类型是IntPair，可以这么继承： public class IntPair extends Pair&lt;Integer&gt; { } 使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可： IntPair ip = new IntPair(1, 2); 我们无法获取Pair&lt;Integer&gt;的T类型，即给定一个变量Pair&lt;Integer&gt; p，无法从p中获取到Integer类型。 但是，在父类是泛型类型的情况下，编译器就必须把类型T（对IntPair来说，也就是Integer类型）保存到子类的class文件中，不然编译器就不知道IntPair只能存取Integer这种类型。 在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂： import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; public class Main { public static void main(String[] args) { Class&lt;IntPair&gt; clazz = IntPair.class; Type t = clazz.getGenericSuperclass(); if (t instanceof ParameterizedType) { ParameterizedType pt = (ParameterizedType) t; Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型 Type firstType = types[0]; // 取第一个泛型类型 Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType; System.out.println(typeClass); // Integer } } } class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; } } class IntPair extends Pair&lt;Integer&gt; { public IntPair(Integer first, Integer last) { super(first, last); } } 小结Java的泛型是采用擦拭法实现的； 擦拭法决定了泛型&lt;T&gt;： 不能是基本类型，例如：int； 不能获取带泛型类型的Class，例如：Pair&lt;String&gt;.class； 不能判断带泛型类型的类型，例如：x instanceof Pair&lt;String&gt;； 不能实例化T类型，例如：new T()。 泛型方法要防止重复定义方法，例如：public boolean equals(T obj)； 子类可以获取父类的泛型类型&lt;T&gt;。 extends通配符假设我们定义了Pair&lt;T&gt;： public class Pair&lt;T&gt;{...} 然后，我们又针对Pair&lt;Number&gt;类型写了一个静态方法，它接收的参数类型是Pair&lt;Number&gt;： public class PairHelper{ static int add(Pair&lt;Number&gt; p){ Number first = p.getFirst(); Number last = p.getLast(); return first.intValue()+last.intValue(); } } 我们传入： int sum = PairHelper.add(new Pair&lt;Number&gt;(1,2)); 可以正常编译。 注意：传入的类型是Pair&lt;Number&gt;，实际参数类型是(Integer, Integer)。 既然实际参数是Integer类型，试试传入Pair&lt;Integer&gt;： int sum = add(new Pair&lt;Integer&gt;(1,2)); 编译器直接报错。因为Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类，因此，add(Pair&lt;Number&gt;)不接受参数类型Pair&lt;Integer&gt;。 实际类型是Integer，引用类型是Number，没有问题。问题在于方法参数类型定死了只能传入Pair&lt;Number&gt;。 有没有办法使得方法参数接受Pair&lt;Integer&gt;？办法是有的，这就是使用Pair&lt;? extends Number&gt;使得方法接收所有泛型类型为Number或Number子类的Pair类型。 代码修改如下： public class Main { public static void main(String[] args) { int sum = add(new Pair&lt;Integer&gt;(1,2)); System.out.println(sum); } static int add(Pair&lt;? extends Number&gt; p){ Number first = p.getFirst(); Number last = p.getLast(); return first.intValue()+last.intValue(); } } class Pair&lt;T&gt;{ private T first; private T last; public Pair(T first,T last){ this.first = first; this.last = last; } public T getFirst(){ return first; } public T getLast(){ return last; } } 这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。 除了可以传入Pair&lt;Integer&gt;类型，我们还可以传入Pair&lt;Double&gt;类型，Pair&lt;BigDecimal&gt;类型等等，因为Double和BigDecimal都是Number的子类。 通配符的一个重要限制: public class Main { public static void main(String[] args) { Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456); int n = add(p); System.out.println(n); } static int add(Pair&lt;? extends Number&gt; p) { Number first = p.getFirst(); Number last = p.getLast(); p.setFirst(new Integer(first.intValue() + 100)); p.setLast(new Integer(last.intValue() + 100)); return p.getFirst().intValue() + p.getFirst().intValue(); } } class Pair&lt;T&gt;{ ... public void setFirst(T first) { this.first = first; } public void setLast(T last) { this.last = last; } } 报错：编译错误发生在p.setFirst()传入的参数是Integer类型。既然p的定义是Pair，那么setFirst(? extends Number)为什么不能传入Integer？原因还在于擦拭法。如果我们传入的p是Pair&lt;Double&gt;，显然它满足参数定义Pair&lt;? extends Number&gt;，然而，Pair&lt;Double&gt;的setFirst()显然无法接受Integer类型。 这就是&lt;? extends Number&gt;通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number类型给setFirst(? extends Number)。 这里唯一的例外是可以给方法参数传入null： p.setFirst(null); // ok, 但是后面会抛出NullPointerException p.getFirst().intValue(); // NullPointerException extends通配符的作用如果我们考察Java标准库的java.util.List接口，它实现的是一个类似“可变数组”的列表，主要功能包括： public interface List&lt;T&gt;{ int size(); // 获取个数 T get(int index); // 根据索引获取指定元素 void add(T t); // 添加一个新元素 void remove(T t); // 删除一个已有元素 } 现在，让我们定义一个方法来处理列表的每个元素： int sumOfList(List&lt;? extends Integer&gt; list) { int sum = 0; for (int i=0; i&lt;list.size(); i++) { Integer n = list.get(i); sum = sum + n; } return sum; } 为什么我们定义的方法参数类型是List&lt;? extends Integer&gt;而不是List&lt;Integer&gt;？从方法内部代码看，传入List&lt;? extends Integer&gt;或者List&lt;Integer&gt;是完全一样的，但是，注意到List的限制： 允许调用get()方法获取Integer的引用； 不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。 因此，方法参数类型List&lt;? extends Integer&gt;表明了该方法内部只会读取List&lt;Integer&gt;的元素，不会修改List的元素（因为无法调用add(? extends Integer)、remove(? extends Integer)这些方法。换句话说，这是一个对参数List进行只读的方法（恶意调用set(null)除外）。 使用extends限定T类型在定义泛型类型Pair的时候，也可以使用extends通配符来限定T的类型： public class Pair&lt;T extends Number&gt; { ... } 现在，我们只能定义： Pair&lt;Number&gt; p1 = null; Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(1, 2); Pair&lt;Double&gt; p3 = null; 因为Number、Integer和Double都符合&lt;T extends Number&gt;。 非Number类型将无法通过编译： Pair&lt;String&gt; p1 = null; // compile error! Pair&lt;Object&gt; p2 = null; // compile error! 因为String、Object都不符合&lt;T extends Number&gt;，因为它们不是Number类型或Number的子类。 小结使用类似&lt;? extends Number&gt;通配符作为方法参数时表示： 方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();； 方法内部无法调用传入Number引用的方法（null除外），例如：obj.setFirst(Number n);。 即一句话总结：使用extends通配符表示可以读，不能写。 使用类似&lt;T extends Number&gt;定义泛型类时表示： 泛型类型限定为Number以及Number的子类。 super通配符考察下面的set方法： void set(Pair&lt;Integer&gt; p, Integer first, Integer last) { p.setFirst(first); p.setLast(last); } 传入Pair&lt;Integer&gt;是允许的，但是传入Pair&lt;Number&gt;是不允许的。 和extends通配符相反，这次，我们希望接受Pair&lt;Integer&gt;类型，以及Pair&lt;Number&gt;、Pair&lt;Object&gt;，因为Number和Object是Integer的父类，setFirst(Number)和setFirst(Object)实际上允许接受Integer类型。 我们使用super通配符来改写这个方法： void set(Pair&lt;? super Integer&gt; p, Integer first, Integer last) { p.setFirst(first); p.setLast(last); } 注意到Pair&lt;? super Integer&gt;表示，方法参数接受所有泛型类型为Integer或Integer父类的Pair类型。 考察Pair&lt;? super Integer&gt;的setFirst()方法，它的方法签名实际上是： void setFirst(? super Integer); 因此，可以安全地传入Integer类型。 再考察Pair的getFirst()方法，它的方法签名实际上是： ? super Integer getFirst(); 这里注意到我们无法使用Integer类型来接收getFirst()的返回值， Integer x = p.getFirst(); 因为如果传入的实际类型是Pair&lt;Number&gt;，编译器无法将Number类型转型为Integer。 唯一可以接收getFirst()方法返回值的是Object类型： Object obj = p.getFirst(); 因此，使用&lt;? super Integer&gt;通配符表示： 允许调用set(? super Integer)方法传入Integer的引用； 不允许调用get()方法获得Integer的引用。 唯一例外是可以获取Object的引用：Object o = p.getFirst()。 换句话说，使用? super Integer通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。 对比extends和super通配符我们再回顾一下extends通配符。作为方法参数，&lt;? extends T&gt;类型和&lt;? super T&gt;类型的区别在于： &lt;? extends T&gt;允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）； ? super T允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。 一个是允许读不允许写，另一个是允许写不允许读。 先记住上面的结论，我们来看Java标准库的Collections类定义的copy()方法： public class Collections { // 把src的每个元素复制到dest中: public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); dest.add(t); } } } 它的作用是把一个List的每个元素依次添加到另一个List中。它的第一个参数是List，表示目标List，第二个参数List，表示要复制的List。我们可以简单地用for循环实现复制。在for循环中，我们可以看到，对于类型的变量`src`，我们可以安全地获取类型`T`的引用，而对于类型的变量dest，我们可以安全地传入T的引用。 这个copy()方法的定义就完美地展示了extends和super的意图： copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用； copy()方法内部也不会修改src，因为不能调用src.add(T)。 这是由编译器检查来实现的。如果在方法代码中意外修改了src，或者意外读取了dest，就会导致一个编译错误： public class Collections { // 把src的每个元素复制到dest中: public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { ... T t = dest.get(0); // compile error! src.add(t); // compile error! } } 这个copy()方法的另一个好处是可以安全地把一个List&lt;Integer&gt;添加到List&lt;Number&gt;，但是无法反过来添加： // copy List&lt;Integer&gt; to List&lt;Number&gt; ok: List&lt;Number&gt; numList = ...; List&lt;Integer&gt; intList = ...; Collections.copy(numList, intList); // ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;: Collections.copy(intList, numList); 而这些都是通过super和extends通配符，并由编译器强制检查来实现的。 PECS原则何时使用extends，何时使用super？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。 即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。 还是以Collections的copy()方法为例： public class Collections { public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); // src是producer dest.add(t); // dest是consumer } } } 需要返回T的src是生产者，因此声明为List&lt;? extends T&gt;，需要写入T的dest是消费者，因此声明为List&lt;? super T&gt;。 无限定通配符Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个?： void sample(Pair&lt;?&gt; p) { } 因为?通配符既没有extends，也没有super，因此： 不允许调用set(T)方法并传入引用（null除外）； 不允许调用T get()方法并获取T引用（只能获取Object引用）。 换句话说，既不能读，也不能写，那只能做一些null判断： static boolean isNull(Pair&lt;?&gt; p) { return p.getFirst() == null || p.getLast() == null; 大多数情况下，可以引入泛型参数&lt;T&gt;消除&lt;?&gt;通配符： static &lt;T&gt; boolean isNull(Pair&lt;T&gt; p) { return p.getFirst() == null || p.getLast() == null; } &lt;?&gt;通配符有一个独特的特点，就是：Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类： public static void main(String[] args) { Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456); Pair&lt;?&gt; p2 = p; // 安全地向上转型 System.out.println(p2.getFirst() + &quot;, &quot; + p2.getLast()); } 小结使用类似&lt;? super Integer&gt;通配符作为方法参数时表示： 方法内部可以调用传入Integer引用的方法，例如：obj.setFirst(Integer n);； 方法内部无法调用获取Integer引用的方法（Object除外），例如：Integer n = obj.getFirst();。 即使用super通配符表示只能写不能读。 使用extends和super通配符要遵循PECS原则。 无限定通配符&lt;?&gt;很少使用，可以用&lt;T&gt;替换，同时它是所有&lt;T&gt;类型的超类。 *泛型和反射Java的部分反射API也是泛型。例如：Class就是泛型： // compile warning: Class clazz = String.class; String str = (String) clazz.newInstance(); // no warning: Class&lt;String&gt; clazz = String.class; String str = clazz.newInstance(); 调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;： Class&lt;? super String&gt; sup = String.class.getSuperclass(); 构造方法Constructor&lt;T&gt;也是泛型： Class&lt;Integer&gt; clazz = Integer.class; Constructor&lt;Integer&gt; cons = clazz.getConstructor(int.class); Integer i = cons.newInstance(123); 我们可以声明带泛型的数组，但不能用new操作符创建带泛型的数组： Pair&lt;String&gt;[] ps = null; // ok Pair&lt;String&gt;[] ps = new Pair&lt;String&gt;[2]; // compile error! 必须通过强制转型实现带泛型的数组： @SuppressWarnings(&quot;unchecked&quot;) Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2]; 使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量ps，因为它的类型是泛型数组。但是，编译器不会检查变量arr，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作arr可能导致从ps获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组： Pair[] arr = new Pair[2]; Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr; ps[0] = new Pair&lt;String&gt;(&quot;a&quot;, &quot;b&quot;); arr[1] = new Pair&lt;Integer&gt;(1, 2); // ClassCastException: Pair&lt;String&gt; p = ps[1]; String s = p.getFirst(); 要安全地使用泛型数组，必须扔掉arr的引用： @SuppressWarnings(&quot;unchecked&quot;) Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2]; 上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组ps进行操作，这种操作就是安全的。 带泛型的数组实际上是编译器的类型擦除： Pair[] arr = new Pair[2]; Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr; System.out.println(ps.getClass() == Pair[].class); // true String s1 = (String) arr[0].getFirst(); String s2 = ps[0].getFirst(); 所以我们不能直接创建泛型数组T[]，因为擦拭后代码变为Object[]： // compile error: public class Abc&lt;T&gt; { T[] createArray() { return new T[5]; } } 必须借助Class来创建泛型数组：j们还可以利用可变参数创建泛型数组T[]： public class ArrayHelper { @SafeVarargs static &lt;T&gt; T[] asArray(T... objs) { return objs; } } String[] ss = ArrayHelper.asArray(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); Integer[] ns = ArrayHelper.asArray(1, 2, 3); 谨慎使用泛型可变参数在上面的例子中，我们看到，通过： static &lt;T&gt; T[] asArray(T... objs) { return objs; } 似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例： public static void main(String[] args) { String[] arr = asArray(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;); System.out.println(Arrays.toString(arr)); // ClassCastException: String[] firstTwo = pickTwo(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;); System.out.println(Arrays.toString(firstTwo)); } static &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) { return asArray(k1, k2); } static &lt;T&gt; T[] asArray(T... objs) { return objs; } 直接调用asArray(T...)似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生ClassCastException，原因还是因为擦拭法，在pickTwo()方法内部，编译器无法检测K[]的正确类型，因此返回了Object[]。 如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用@SafeVarargs消除警告。 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。 小结部分反射API是泛型，例如：Class，Constructor； 可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型； 可以通过Array.newInstance(Class, int)创建T[]数组，需要强制转型； 同时使用泛型和可变参数时需要特别小心。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"/tags/java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Java教程笔记之注解","slug":"Java教程笔记之注解","date":"2020-06-29T14:24:27.000Z","updated":"2020-06-29T15:46:43.461Z","comments":true,"path":"2020/06/29/Java教程笔记之注解/","link":"","permalink":"/2020/06/29/Java教程笔记之注解/","excerpt":"","text":"注解本节我们将介绍Java程序的一种特殊“注释”——注解（Annotation）。 使用注解注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”： // this is a component: @Resource(&quot;hello&quot;) public class Hello { @Inject int n; @PostConstruct public void hello(@Param String name) { System.out.println(name); } @Override public String toString() { return &quot;Hello&quot;; } } 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 注解的作用从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。 第一类是由编译器使用的注解，例如： @Override：让编译器检查该方法是否正确地实现了覆写； @SuppressWarnings：告诉编译器忽略此处代码产生的警告。 这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。 定义一个注解时，还可以定义配置参数。配置参数可以包括： 所有基本类型； String； 枚举类型； 基本类型、String、Class以及枚举的数组。 因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。 注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。 大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。 如果只写注解，相当于全部使用默认值。 示例： public class Hello { @Check(min=0, max=100, value=55) public int n; @Check(value=99) public int p; @Check(99) // @Check(value=99) public int x; @Check public int y; } @Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。 小结注解（Annotation）是Java语言用于工具处理的标注： 注解可以配置参数，没有指定配置的参数使用默认值； 如果参数名称是value，且只有一个参数，那么可以省略参数名称。 定义注解Java语言使用@interface语法来定义注解（Annotation)，格式如下： public @interface Report{ int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; } 注解的参数类似无参数方法，可以用default设定一个默认值。最常用的参数应该命名为value。 元注解元注解（meta annotation）是修饰其他注解的注解。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 @Target最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置： 类或接口：ElementType.TYPE； 字段：ElementType.FIELD； 方法：ElementType.METHOD； 构造方法：ElementType.CONSTRUCTOR； 方法参数：ElementType.PARAMETER。 例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)： @Target(ElementType.METHOD) public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; } 定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }： @Target({ ElementType.METHOD, ElementType.FIELD }) public @interface Report { ... } 实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。 @Retention另一个重要的元注解@Retention定义了Annotation的生命周期： 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期：RetentionPolicy.RUNTIME。 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解： @Retention(RetentionPolicy.RUNTIME) public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; } @Repeatable使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。 @Repeatable(Reports.class) @Target(ElementType.TYPE) public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; } @Target(ElementType.TYPE) public @interface Reports { Report[] value(); } 经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解： @Report(type=1, level=&quot;debug&quot;) @Report(type=2, level=&quot;warning&quot;) public class Hello { } @Inherited使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效： @Inherited @Target(ElementType.TYPE) public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; } 在使用的时候，如果一个类用到了@Report： @Report(type=1) public class Person { } 则它的子类默认也定义了该注解： public class Student extends Person { } 如何定义Annotation我们总结一下定义Annotation的步骤： 第一步，用@interface定义注解： public @interface Report { } 第二步，添加参数、默认值： public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; } 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。 第三步，用元注解配置注解： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; } 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 小结Java使用@interface定义注解： 可定义多个参数和默认值，核心参数使用value名称； 必须设置@Target来指定Annotation可以应用的范围； 应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。 处理注解Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置： SOURCE类型的注解在编译期就被丢掉了； CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM； RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。 如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。 因此，我们只讨论如何读取RUNTIME类型的注解。 因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。 Java提供的使用反射API读取Annotation的方法包括： 判断某个注解是否存在于Class、Field、Method或Constructor： Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 例如： // 判断@Report是否存在于Person类: Person.class.isAnnotationPresent(Report.class); 使用反射API读取Annotation： Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 例如： // 获取Person定义的@Report注解: Report report = Person.class.getAnnotation(Report.class); int type = report.type(); String level = report.level(); 使用反射API读取Annotation有两种方法。方法一是先判断Annotation是否存在，如果存在，就直接读取： Class cls = Person.class; if (cls.isAnnotationPresent(Report.class)) { Report report = cls.getAnnotation(Report.class); ... } 第二种方法是直接读取Annotation，如果Annotation不存在，将返回null： Class cls = Person.class; Report report = cls.getAnnotation(Report.class); if (report != null) { ... } 读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解： public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) { } 要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解： // 获取Method实例: Method m = ... // 获取所有参数的Annotation: Annotation[][] annos = m.getParameterAnnotations(); // 第一个参数（索引为0）的所有Annotation: Annotation[] annosOfName = annos[0]; for (Annotation anno : annosOfName) { if (anno instanceof Range) { // @Range注解 Range r = (Range) anno; } if (anno instanceof NotNull) { // @NotNull注解 NotNull n = (NotNull) anno; } } 使用注解注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。 我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义： @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface Range { int min() default 0; int max() default 255; } 在某个JavaBean中，我们可以使用该注解： public class Person { @Range(min=1, max=20) public String name; @Range(max=10) public String city; } 但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义： void check(Person person) throws IllegalArgumentException, ReflectiveOperationException { // 遍历所有Field: for (Field field : person.getClass().getFields()) { // 获取Field定义的@Range: Range range = field.getAnnotation(Range.class); // 如果@Range存在: if (range != null) { // 获取Field的值: Object value = field.get(person); // 如果值是String: if (value instanceof String) { String s = (String) value; // 判断值是否满足@Range的min/max: if (s.length() &lt; range.min() || s.length() &gt; range.max()) { throw new IllegalArgumentException(&quot;Invalid field: &quot; + field.getName()); } } } } } 这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。 小结可以在运行期通过反射读取RUNTIME类型的注解，注意千万不要漏写@Retention(RetentionPolicy.RUNTIME)，否则运行期无法读取到该注解。 可以通过程序处理注解来实现相应的功能： 对JavaBean的属性值按规则进行检查； JUnit会自动运行@Test标记的测试方法。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Java教程笔记之反射","slug":"Java教程笔记之反射","date":"2020-06-26T14:24:27.000Z","updated":"2020-06-26T13:40:55.319Z","comments":true,"path":"2020/06/26/Java教程笔记之反射/","link":"","permalink":"/2020/06/26/Java教程笔记之反射/","excerpt":"","text":"反射Java的反射是指程序在运行期间可以拿到一个对象的所有信息。 正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例： // Main.java import com.itranswarp.learnjava.Person; public class Main { String getFullName(Person p) { return p.getFirstName() + &quot; &quot; + p.getLastName(); } } 但是，如果不能获得Person类，只有一个Object实例，如何访问？ String getFullName(Object obj) { return ??? } String getFullName(Object obj) { Person p = (Person) obj; return p.getFirstName() + &quot; &quot; + p.getLastName(); } 强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用Person类。不然，去掉import语句，编译报错。 所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。 Class类除了int等基本类型外，Java的其他类型全部都是class（包括interface）。class（包括interface）的本质是数据类型（Type）。class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样： public final class Class { private Class() {} } 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来： Class cls = new Class(String); 这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 JVM持有的每个Class实例都指向一个数据类型（class或interface）： ┌───────────────────────────┐ │ Class Instance │──────&gt; String ├───────────────────────────┤ │name = &quot;java.lang.String&quot; │ └───────────────────────────┘ ┌───────────────────────────┐ │ Class Instance │──────&gt; Random ├───────────────────────────┤ │name = &quot;java.util.Random&quot; │ 一个Class实例包含了该class的所有完整信息： ┌───────────────────────────┐ │ Class Instance │──────&gt; String ├───────────────────────────┤ │name = &quot;java.lang.String&quot; │ ├───────────────────────────┤ │package = &quot;java.lang&quot; │ ├───────────────────────────┤ │super = &quot;java.lang.Object&quot; │ ├───────────────────────────┤ │interface = CharSequence...│ ├───────────────────────────┤ │field = value[],hash,... │ ├───────────────────────────┤ │method = indexOf()... │ └───────────────────────────┘ 由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 这种通过Class实例获取class信息的方法称为反射（Reflection）。 如何获取一个class的Class实例？有三个方法： 方法一：直接通过一个class的静态变量class获取： Class cls = String.class; 方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： String s = &quot;Hello&quot;; Class cls = s.getClass(); 方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： Class cls = Class.forName(&quot;java.lang.String&quot;); 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。 Integer n = new Integer(123); boolean b1 = n instanceof Integer; // true，因为n是Integer类型 boolean b2 = n instanceof Number; // true，因为n是Number类型的子类 boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class 用instanceof不但匹配指定类型，还匹配指定类型的子类。而用==判断class实例可以精确地判断数据类型，但不能作子类型比较。 通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。 如果获取到了一个Class实例，我们就可以通过该Class实例来创建对应类型的实例 // 获取String的Class实例: Class cls = String.class; // 创建一个String实例: String s = (String) cls.newInstance(); 上述代码相当于new String()。通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用。 动态加载JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如： // Main.java public class Main { public static void main(String[] args) { if (args.length &gt; 0) { create(args[0]); } } static void create(String name) { Person p = new Person(name); } } 当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。 这就是JVM动态加载class的特性。利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。 小结JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息； 获取一个class对应的Class实例后，就可以获取该class的所有信息； 通过Class实例获取class信息的方法称为反射（Reflection）； JVM总是动态加载class，可以在运行期根据条件来控制加载class。 访问字段对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。 通过Class实例获取字段信息。Class类提供了以下几个方法来获取字段： Field getField(name)：根据字段名获取某个public的field（包括父类） Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） Field[] getFields()：获取所有public的field（包括父类） Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取public字段&quot;score&quot;: System.out.println(stdClass.getField(&quot;score&quot;)); // 获取继承的public字段&quot;name&quot;: System.out.println(stdClass.getField(&quot;name&quot;)); // 获取private字段&quot;grade&quot;: System.out.println(stdClass.getDeclaredField(&quot;grade&quot;)); } } class Student extends Person { public int score; private int grade; } class Person { public String name; } 上述代码首先获取Student的Class实例，然后，分别获取public字段、继承的public字段以及private字段，打印出的Field类似： public int Student.score public java.lang.String Person.name private int Student.grade 一个Field对象包含了一个字段的所有信息： getName()：返回字段名称，例如，&quot;name&quot;； getType()：返回字段类型，也是一个Class实例，例如，String.class； getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。 以String类的value字段为例，它的定义是： public final class String { private final byte[] value; } 我们用反射获取该字段的信息，代码如下： Field f = String.class.getDeclaredField(&quot;value&quot;); f.getName(); // &quot;value&quot; f.getType(); // class [B 表示byte[]类型 int m = f.getModifiers(); Modifier.isFinal(m); // true Modifier.isPublic(m); // false Modifier.isProtected(m); // false Modifier.isPrivate(m); // true Modifier.isStatic(m); // false 获取字段值利用反射拿到字段的一个Field实例只是第一步，我们还可以拿到一个实例对应的该字段的值。 例如，对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值： public class Main { public static void main(String[] args) throws Exception { Object p = new Person(&quot;Xiao Ming&quot;); Class c = p.getClass(); Field f = c.getDeclaredField(&quot;name&quot;);//会报异常 Object value = f.get(p); System.out.println(value); // &quot;Xiao Ming&quot; } } class Person { private String name; public Person(String name) { this.name = name; } } 上述代码先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值 运行代码，如果不出意外，会得到一个IllegalAccessException，这是因为name被定义为一个private字段，正常情况下，Main类无法访问Person类的private字段。要修复错误，可以将private改为public，或者，在调用Object value = f.get(p);前，先写一句： f.setAccessible(true); 调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。 设置字段值通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。 设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值。示例代码如下： public class Main { public static void main(String[] args) throws Exception { Person p = new Person(&quot;Xiao Ming&quot;); System.out.println(p.getName()); // &quot;Xiao Ming&quot; Class c = p.getClass(); Field f = c.getDeclaredField(&quot;name&quot;); f.setAccessible(true); f.set(p, &quot;Xiao Hong&quot;); System.out.println(p.getName()); // &quot;Xiao Hong&quot; } } class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return this.name; } } 运行上述代码，打印的name字段从Xiao Ming变成了Xiao Hong，说明通过反射可以直接修改字段的值。 同样的，修改非public字段，需要首先调用setAccessible(true)。 小结Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。 调用方法可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取public方法getScore，参数为String: System.out.println(stdClass.getMethod(&quot;getScore&quot;, String.class)); // 获取继承的public方法getName，无参数: System.out.println(stdClass.getMethod(&quot;getName&quot;)); // 获取private方法getGrade，参数为int: System.out.println(stdClass.getDeclaredMethod(&quot;getGrade&quot;, int.class)); } } class Student extends Person { public int getScore(String type) { return 99; } private int getGrade(int year) { return 1; } } class Person { public String getName() { return &quot;Person&quot;; } } public int Student.getScore(java.lang.String) public java.lang.String Person.getName() private int Student.getGrade(int) 一个Method对象包含一个方法的所有信息： getName()：返回方法名称，例如：&quot;getScore&quot;； getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class； getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}； getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。 调用方法当我们获取到一个Method对象时，就可以对它进行调用。我们以下面的代码为例： String s = &quot;Hello world&quot;; String r = s.substring(6); // &quot;world&quot; 如果用反射来调用substring方法，需要以下代码： public class Main { public static void main(String[] args) throws Exception { // String对象: String s = &quot;Hello world&quot;; // 获取String substring(int)方法，参数为int: Method m = String.class.getMethod(&quot;substring&quot;, int.class); // 在s对象上调用该方法并获取结果: String r = (String) m.invoke(s, 6); // 打印调用结果: System.out.println(r); } } 对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。 调用静态方法如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。我们以Integer.parseInt(String)为例： public class Main { public static void main(String[] args) throws Exception { // 获取Integer.parseInt(String)方法，参数为String: Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class); // 调用该静态方法并获取结果: Integer n = (Integer) m.invoke(null, &quot;12345&quot;); // 打印调用结果: System.out.println(n); } } 调用非public方法和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用： public class Main { public static void main(String[] args) throws Exception { Person p = new Person(); Method m = p.getClass().getDeclaredMethod(&quot;setName&quot;, String.class); m.setAccessible(true); m.invoke(p, &quot;Bob&quot;); System.out.println(p.name); } } class Person { String name; private void setName(String name) { this.name = name; } } 多态我们来考察这样一种情况：一个Person类定义了hello()方法，并且它的子类Student也覆写了hello()方法，那么，从Person.class获取的Method，作用于Student实例时，调用的方法到底是哪个？ public class Main { public static void main(String[] args) throws Exception { // 获取Person的hello方法: Method h = Person.class.getMethod(&quot;hello&quot;); // 对Student实例调用hello方法: h.invoke(new Student()); } } class Person { public void hello() { System.out.println(&quot;Person:hello&quot;); } } class Student extends Person { public void hello() { System.out.println(&quot;Student:hello&quot;); } } 运行上述代码，发现打印出的是Student:hello，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。 小结Java的反射API提供的Method对象封装了方法的所有信息： 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()； 通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 通过设置setAccessible(true)来访问非public方法； 通过反射调用方法时，仍然遵循多态原则。 调用构造方法我们通常使用new操作符创建新的实例： Person p = new Person(); 如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： Person p = Person.class.newInstance(); 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 我们通常使用new操作符创建新的实例： Person p = new Person(); 如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： Person p = Person.class.newInstance(); 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： public class Main { public static void main(String[] args) throws Exception { // 获取构造方法Integer(int): Constructor cons1 = Integer.class.getConstructor(int.class); // 调用构造方法: Integer n1 = (Integer) cons1.newInstance(123); System.out.println(n1); // 获取构造方法Integer(String) Constructor cons2 = Integer.class.getConstructor(String.class); Integer n2 = (Integer) cons2.newInstance(&quot;456&quot;); System.out.println(n2); } } 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 小结Constructor对象封装了构造方法的所有信息； 通过Class实例的方法可以获取Constructor实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 通过Constructor实例可以创建一个实例对象：newInstance(Object... parameters)； 通过设置setAccessible(true)来访问非public构造方法。 获取继承关系当我们获取到某个Class对象时，实际上就获取到了一个类的类型： Class cls = String.class; // 获取到String的Class 还可以用实例的getClass()方法获取： String s = &quot;&quot;; Class cls = s.getClass(); // s是String，因此获取到String的Class 最后一种获取Class的方法是通过Class.forName(&quot;&quot;)，传入Class的完整类名获取： Class s = Class.forName(&quot;java.lang.String&quot;); 这三种方式获取的Class实例都是同一个实例，因为JVM对每个加载的Class只创建一个Class实例来表示它的类型。 获取父类的Class有了Class实例，我们还可以获取它的父类的Class：getSuperclass() public class Main { public static void main(String[] args) throws Exception { Class i = Integer.class; Class n = i.getSuperclass(); System.out.println(n);//class java.lang.Number Class o = n.getSuperclass(); System.out.println(o);//class java.lang.Object System.out.println(o.getSuperclass());//null } } 运行上述代码，可以看到，Integer的父类类型是Number，Number的父类是Object，Object的父类是null。除Object外，其他任何非interface的Class都必定存在一个父类类型。 获取interface由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型。例如，查询Integer实现的接口：getInterfaces() public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class; Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } } } 运行上述代码可知，Integer实现的接口有： java.lang.Comparable java.lang.constant.Constable java.lang.constant.ConstantDesc 要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型 public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class.getSuperclass(); Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i);//interface java.io.Serializable } } } Integer的父类是Number，Number实现的接口是java.io.Serializable。 此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()： System.out.println(java.io.DataInputStream.class.getSuperclass()); // java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream System.out.println(java.io.Closeable.class.getSuperclass()); // null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces() 如果一个类没有实现任何interface，那么getInterfaces()返回空数组。 继承关系当我们判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符： Object n = Integer.valueOf(123); boolean isDouble = n instanceof Double; // false boolean isInteger = n instanceof Integer; // true 如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()： // Integer i = ? Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer // Number n = ? Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number // Object o = ? Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object // Integer i = ? Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer 小结通过Class对象可以获取继承关系： Class getSuperclass()：获取父类类型； Class[] getInterfaces()：获取当前类实现的所有接口。 通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。 *动态代理我们来比较Java的class和interface的区别： 可以实例化class（非abstract）； 不能实例化interface。 所有interface类型的变量总是通过向上转型并指向某个实例的： CharSequence cs = new StringBuilder(); 有没有可能不编写实现类(如上StringBuilder())，直接在运行期创建某个interface的实例呢？ 这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 所谓动态代理，是和静态相对应的。我们来看静态代码怎么写： 1.定义接口： public interface Hello { void morning(String name); } 2.编写实现类： public class HelloWorld implements Hello { public void morning(String name) { System.out.println(&quot;Good morning, &quot; + name); } } 3.创建实例，转型为接口并调用： Hello hello = new HelloWorld(); hello.morning(&quot;Bob&quot;); 这种方式就是我们通常编写代码的方式。 还有一种方式是动态代码，我们仍然先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。 public class Main { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); //public abstract void Hello.morning(java.lang.String) if (method.getName().equals(&quot;morning&quot;)) { System.out.println(&quot;Good morning, &quot; + args[0]); //Good morning, Bob } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance( Hello.class.getClassLoader(), // 传入ClassLoader new Class[] { Hello.class }, // 传入要实现的接口 handler); // 传入处理调用方法的InvocationHandler hello.morning(&quot;Bob&quot;); } } interface Hello { void morning(String name); } 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 动态代理实际上是JDK在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样： public class HelloDynamicProxy implements Hello { InvocationHandler handler; public HelloDynamicProxy(InvocationHandler handler) { this.handler = handler; } public void morning(String name) { handler.invoke( this, Hello.class.getMethod(&quot;morning&quot;), new Object[] { name }); } } 其实就是JDK帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。 小结Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例； 动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Java教程笔记之异常处理","slug":"Java教程笔记之异常处理","date":"2020-06-18T15:12:25.000Z","updated":"2020-06-18T15:13:51.953Z","comments":true,"path":"2020/06/18/Java教程笔记之异常处理/","link":"","permalink":"/2020/06/18/Java教程笔记之异常处理/","excerpt":"","text":"异常处理Java的异常一个健壮的程序必须处理各种各样的错误。Java内置了一套异常处理机制，总是使用异常来表示错误。 异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了 try { String s = processFile(“C:\\\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 因为Java的异常是class，它的继承关系如下： 从继承关系可知：Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力，例如： OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 而Exception则是运行时的错误，它可以被捕获并处理。 某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如： NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如： NullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Exception又分为两大类： RuntimeException（（运行时异常））以及它的子类； 非RuntimeException（包括IOException、ReflectiveOperationException等等） Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常编译器要求强制处置，要么try-cathch,要么在方法名后面抛出。不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。 捕获异常捕获异常使用try...catch语句，把可能发生异常的代码放到try {...}中，然后使用catch捕获对应的Exception及其子类： public class Main { public static void main(String[] args) { byte[] bs = toGBK(&quot;中文&quot;); //在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的异常,因此会报错 System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) { try { // 用指定编码转换String为byte[]: return s.getBytes(&quot;GBK&quot;); } catch (UnsupportedEncodingException e) { // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e); // 打印异常信息 return s.getBytes(); // 尝试使用用默认编码 } } } //method_2 static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(&quot;GBK&quot;); } 如果我们不捕获UnsupportedEncodingException，会出现编译失败的问题这样的Checked Exception，必须被捕获。 这是因为String.getBytes(String)方法定义是： public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { ... } 在方法定义的时候，使用throws xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。 在toGBK()方法中，因为调用了String.getBytes(String)方法，就必须捕获UnsupportedEncodingException。我们也可以不捕获它，而是在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查。 上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用return s.getBytes(&quot;GBK&quot;);的问题，而是byte[] bs = toGBK(&quot;中文&quot;);。因为在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的UnsupportedEncodingException。 修复方法是在main()方法中捕获异常并处理。 public class Main { public static void main(String[] args) { try { byte[] bs = toGBK(&quot;中文&quot;); System.out.println(Arrays.toString(bs)); } catch (UnsupportedEncodingException e) { System.out.println(e); } } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(&quot;GBK&quot;); } } 可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在main()方法中捕获，不会出现漏写try的情况。这是由编译器保证的。main()方法也是最后捕获Exception的机会。 如果是测试代码，上面的写法就略显麻烦。如果不想写任何try代码，可以直接把main()方法定义为throws Exception public class Main { public static void main(String[] args) throws Exception { byte[] bs = toGBK(&quot;中文&quot;); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(&quot;GBK&quot;); } } 因为main()方法声明了可能抛出Exception，也就声明了可能抛出所有的Exception，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。 还有一些童鞋喜欢在toGBK()内部“消化”异常： static byte[] toGBK(String s) { try { return s.getBytes(&quot;GBK&quot;); } catch (UnsupportedEncodingException e) { // 什么也不干 } return null; 这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来： static byte[] toGBK(String s) { try { return s.getBytes(&quot;GBK&quot;); } catch (UnsupportedEncodingException e) { // 先记下来再说: e.printStackTrace(); } return null; 所有异常都可以调用printStackTrace()方法打印异常栈，这是一个简单有用的快速打印异常的方法。 小结Java使用异常来表示错误，并通过try ... catch捕获异常； Java的异常是class，并且从Throwable继承； Error是无需捕获的严重错误，Exception是应该捕获的可处理的错误； RuntimeException无需强制捕获，非RuntimeException（Checked Exception）需强制捕获，或者用throws声明； 不推荐捕获了异常但不进行任何处理。 捕获异常在Java中，凡是可能抛出异常的语句，都可以用try ... catch捕获。把可能发生异常的语句放在try { ... }中，然后使用catch捕获对应的Exception及其子类。 多catch语句可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 简单地说就是：多个catch语句只有一个能被执行。例如： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(e); } catch (NumberFormatException e) { System.out.println(e); } } 存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。例如： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(&quot;IO error&quot;); } catch (UnsupportedEncodingException e) { // 永远捕获不到 System.out.println(&quot;Bad encoding&quot;); } } 对于上面的代码，UnsupportedEncodingException异常是永远捕获不到的，因为它是IOException的子类。当抛出UnsupportedEncodingException异常时，会被catch (IOException e) { ... }捕获并执行。 因此，正确的写法是把子类放到前面。 finally语句无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？ 可以把执行语句写若干遍：正常执行的放到try中，每个catch再写一遍。例如： public static void main(String[] args) { try { process1(); process2(); process3(); System.out.println(&quot;END&quot;); } catch (UnsupportedEncodingException e) { System.out.println(&quot;Bad encoding&quot;); System.out.println(&quot;END&quot;); } catch (IOException e) { System.out.println(&quot;IO error&quot;); System.out.println(&quot;END&quot;); } } 上述代码无论是否发生异常，都会执行System.out.println(&quot;END&quot;);这条语句。 那么如何消除这些重复的代码？Java的try ... catch机制还提供了finally语句，finally语句块保证有无错误都会执行。上述代码可以改写如下： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(&quot;Bad encoding&quot;); } catch (IOException e) { System.out.println(&quot;IO error&quot;); } finally { System.out.println(&quot;END&quot;); } } 注意finally有几个特点： finally语句不是必须的，可写可不写； finally总是最后执行。 如果没有发生异常，就正常执行try { ... }语句块，然后执行finally。如果发生了异常，就中断执行try { ... }语句块，然后跳转执行匹配的catch语句块，最后执行finally。 可见，finally是用来保证一些代码必须执行的。 某些情况下，可以没有catch，只使用try ... finally结构。例如： void process(String file) throws IOException { try { ... } finally { System.out.println(&quot;END&quot;); } } 因为方法声明了可能抛出的异常，所以可以不写catch。 捕获多种异常如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条catch子句： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(&quot;Bad input&quot;); } catch (NumberFormatException e) { System.out.println(&quot;Bad input&quot;); } catch (Exception e) { System.out.println(&quot;Unknown error&quot;); } } 因为处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException System.out.println(&quot;Bad input&quot;); } catch (Exception e) { System.out.println(&quot;Unknown error&quot;); } } 小结使用try ... catch ... finally时： 多个catch语句的匹配顺序非常重要，子类必须放在前面； finally语句保证了有无异常都会执行，它是可选的； 一个catch语句也可以匹配多个非继承关系的异常。 抛出异常异常的传播当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止 public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { process2(); } static void process2() { Integer.parseInt(null); // 会抛出NumberFormatException } } 通过printStackTrace()可以打印出方法的调用栈，类似： java.lang.NumberFormatException: null at java.base/java.lang.Integer.parseInt(Integer.java:614) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.process2(Main.java:16) at Main.process1(Main.java:12) at Main.main(Main.java:5) printStackTrace()对于调试错误非常有用，上述信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的，从下往上看，调用层次依次是： 1. `main()`调用`process1()`； 2. `process1()`调用`process2()`； 3. `process2()`调用`Integer.parseInt(String)`； 4. `Integer.parseInt(String)`调用`Integer.parseInt(String, int)`。 查看Integer.java源码可知，抛出异常的方法代码如下： public static int parseInt(String s, int radix) throws NumberFormatException { if (s == null) { throw new NumberFormatException(&quot;null&quot;); } ... } 并且，每层调用均给出了源代码的行号，可直接定位。 抛出异常当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。 如何抛出异常？参考Integer.parseInt()方法，抛出异常分两步： 创建某个Exception的实例； 用throw语句抛出。 下面是一个例子： void process2(String s) { if (s==null) { NullPointerException e = new NullPointerException(); throw e; } } 实际上，绝大部分抛出异常的代码都会合并写成一行： void process2(String s) { if (s==null) { throw new NullPointerException(); } } 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： void process1(String s) { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } void process2(String s) { if (s==null) { throw new NullPointerException(); } } 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 如果在main()中捕获IllegalArgumentException，我们看看打印的异常栈： public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); // } } static void process2() { throw new NullPointerException(); } } 打印出的异常栈类似： java.lang.IllegalArgumentException at Main.process1(Main.java:15) at Main.main(Main.java:5) 这说明新的异常丢失了原始异常信息，我们已经看不到原始异常NullPointerException的信息了。 为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。对上述代码改进如下： public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(e);\\\\把原始的`Exception`实例传进去 } } static void process2() { throw new NullPointerException(); } } 运行上述代码，打印出的异常栈类似： java.lang.IllegalArgumentException: java.lang.NullPointerException at Main.process1(Main.java:15) at Main.main(Main.java:5) Caused by: java.lang.NullPointerException at Main.process2(Main.java:20) at Main.process1(Main.java:13) 注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的。 在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。 异常屏蔽如果在执行finally语句时抛出异常，那么，catch语句的异常还能否继续抛出？例如： public class Main { public static void main(String[] args) { try { Integer.parseInt(&quot;abc&quot;); } catch (Exception e) { System.out.println(&quot;catched&quot;); throw new RuntimeException(e); } finally { System.out.println(&quot;finally&quot;); throw new IllegalArgumentException(); } } } 执行上述代码，发现异常信息如下： catched finally Exception in thread &quot;main&quot; java.lang.IllegalArgumentException at Main.main(Main.java:11) 这说明finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。 在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出： public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(&quot;abc&quot;)); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } } 当catch和finally都抛出了异常时，虽然catch的异常被屏蔽了，但是，finally抛出的异常仍然包含了它： Exception in thread &quot;main&quot; java.lang.IllegalArgumentException at Main.main(Main.java:11) Suppressed: java.lang.NumberFormatException: For input string: &quot;abc&quot; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.main(Main.java:6) 通过Throwable.getSuppressed()可以获取所有的Suppressed Exception。 绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception。 小结调用printStackTrace()可以打印异常的传播栈，对于调试非常有用； 捕获异常并再次抛出新的异常时，应该持有原始异常信息； 通常不要在finally中抛出异常。如果在finally中抛出异常，应该原始异常加入到原有异常中。调用方可通过Throwable.getSuppressed()获取所有添加的Suppressed Exception。 自定义异常Java标准库定义的常用异常包括： 当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出IllegalArgumentException： static void process1(int age) { if (age &lt;= 0) { throw new IllegalArgumentException(); } } 在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： public class BaseException extends RuntimeException { } 其他业务类型的异常就可以从BaseException派生： public class UserNotFoundException extends BaseException { } public class LoginFailedException extends BaseException { } ... 自定义的BaseException应该提供多个构造方法： public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); } } 上述构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。 NullPointerException在所有的RuntimeException异常中，Java程序员最熟悉的恐怕就是NullPointerException了。 NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的。 public class Main { public static void main(String[] args) { String s = null; System.out.println(s.toLowerCase());//NullPointerException } } 处理NullPointerException如果遇到NullPointerException，我们应该如何处理？首先，必须明确，NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误。即调试发现有错后直接修改程序。 好的编码习惯可以极大地降低NullPointerException的产生： 1.成员变量在定义时初始化：使用空字符串&quot;&quot;而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串&quot;&quot;表示未填写比null安全得多。 public class Person { private String name = &quot;&quot;; } 2.返回空字符串&quot;&quot;、空数组而不是null： public String[] readLinesFromFile(String file) { if (getFileSize(file) == 0) { // 返回空数组而不是null: return new String[0]; } ... } 如果调用方一定要根据null判断，比如返回null表示文件不存在，那么考虑返回Optional： public Optional&lt;String&gt; readFromFile(String file) { if (!fileExist(file)) { return Optional.empty(); } ... } 这样调用方必须通过Optional.isPresent()判断是否有结果。 定位NullPointerException如果产生了NullPointerException，例如，调用a.b.c.x()时产生了NullPointerException，原因可能是： a是null； a.b是null； a.b.c是null； 确定到底是哪个对象是null以前只能打印这样的日志： System.out.println(a); System.out.println(a.b); System.out.println(a.b.c); 从Java 14开始，如果产生了NullPointerException，JVM可以给出详细的信息告诉我们null对象到底是谁,详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个-XX:+ShowCodeDetailsInExceptionMessages参数启用它： java -XX:+ShowCodeDetailsInExceptionMessages Main.java *使用断言断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。 我们先看一个例子： public static void main(String[] args) { double x = Math.abs(-123.45); assert x &gt;= 0; System.out.println(x); } 语句assert x &gt;= 0;即为断言，断言条件x &gt;= 0预期为true。如果计算结果为false，则断言失败，抛出AssertionError。 使用assert语句时，还可以添加一个可选的断言消息： assert x &gt;= 0 : &quot;x must &gt;= 0&quot;; 这样，断言失败的时候，AssertionError会带上消息x must &gt;= 0，更加便于调试。 Java断言的特点是：断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。 对于可恢复的程序错误，不应该使用断言。例如： void sort(int[] arr) { assert arr != null; } 应该抛出异常并在上层捕获： void sort(int[] arr) { if (x == null) { throw new IllegalArgumentException(&quot;array cannot be null&quot;); } } 当我们在程序中使用assert时，例如，一个简单的断言： // assert public class Main { public static void main(String[] args) { int x = -1; assert x &gt; 0; System.out.println(x); } } 断言x必须大于0，实际上x为-1，断言肯定失败。执行上述代码，发现程序并未抛出AssertionError，而是正常打印了x的值。 为什么assert语句不起作用？ 这是因为JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。 要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果： $ java -ea Main.java Exception in thread &quot;main&quot; java.lang.AssertionError at Main.main(Main.java:5) 还可以有选择地对特定地类启用断言，命令行参数是：-ea:com.itranswarp.sample.Main，表示只对com.itranswarp.sample.Main这个类启用断言。 或者对特定地包启用断言，命令行参数是：-ea:com.itranswarp.sample...（注意结尾有3个.），表示对com.itranswarp.sample这个包启动断言。 实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解JUnit的使用。 小结断言是一种调试方式，断言失败会抛出AssertionError，只能在开发和测试阶段启用断言； 对可恢复的错误不能使用断言，而应该抛出异常； 断言很少被使用，更好的方法是编写单元测试。 *使用JDK Logging在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用System.out.println()打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。 代码改好了怎么办？当然是删除没有用的System.out.println()语句了。 如果改代码又改出问题怎么办？再加上System.out.println()。 反复这么搞几次，很快大家就发现使用System.out.println()非常麻烦。 怎么办？ 解决方法是使用日志。 那什么是日志？日志就是Logging，它的目的是为了取代System.out.println()。 输出日志，而不是用System.out.println()，有以下几个好处： 可以设置输出样式，避免自己每次都写&quot;ERROR: &quot; + var； 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志； 可以被重定向到文件，这样可以在程序运行结束后查看日志； 可以按包名控制日志级别，只输出某些包打的日志； …… 如何使用日志？ 因为Java标准库内置了日志包java.util.logging，我们可以直接用。 public class Hello { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(&quot;start process...&quot;); logger.warning(&quot;memory is running out...&quot;); logger.fine(&quot;ignored.&quot;); logger.severe(&quot;process will be terminated...&quot;); } } 使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。 4条日志，只打印了3条，logger.fine()没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通： SEVERE WARNING INFO CONFIG FINE FINER FINEST 因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。 使用Java标准库内置的Logging有以下局限： Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置； 配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=。 因此，Java标准库内置的Logging使用并不是非常广泛。更方便的日志系统我们稍后介绍。 使用Commons Logging和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。 Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。 使用Commons Logging只需要和两个类打交道，并且只有两步： 第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打日志。 import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class Main { public static void main(String[] args) { Log log = LogFactory.getLog(Main.class); log.info(&quot;start...&quot;); log.warn(&quot;end.&quot;); } } 运行上述代码，肯定会得到编译错误，。因为Commons Logging是一个第三方提供的库，所以，必须先把它下载下来。下载后，解压，找到commons-logging-1.2.jar这个文件，再把Java源码Main.java放到一个目录下，例如work目录： work │ ├─ commons-logging-1.2.jar │ └─ Main.java 运行结果如下： Mar 02, 2019 7:15:31 PM Main main INFO: start... Mar 02, 2019 7:15:31 PM Main main WARNING: end. Commons Logging定义了6个日志级别： FATAL ERROR WARNING INFO DEBUG TRACE 默认级别是INFO。 在实例方法中引用Log，通常定义一个实例变量： // 在实例方法中引用Log: public class Person { protected final Log log = LogFactory.getLog(getClass()); void foo() { log.info(&quot;foo&quot;); } } 注意到实例变量log的获取方式是LogFactory.getLog(getClass())，虽然也可以用LogFactory.getLog(Person.class)，但是前一种方式有个非常大的好处，就是子类可以直接使用该log实例。 // 在子类中使用父类实例化的log: public class Student extends Person { void bar() { log.info(&quot;bar&quot;); } } 此外，Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单： try { ... } catch (Exception e) { log.error(&quot;got exception!&quot;, e); } 小结Commons Logging是使用最广泛的日志模块； Commons Logging的API非常简单； Commons Logging可以自动检测并使用其他日志模块。 使用Log4jCommons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。 Log4j是一种非常流行的日志框架，最新版本是2.x。 Log4j是一个组件化设计的日志系统，它的架构大致如下： log.info(&quot;User signed in.&quot;); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如： console：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。 上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。 以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Configuration&gt; &lt;Properties&gt; &lt;!-- 定义日志格式 --&gt; &lt;Property name=&quot;log.pattern&quot;&gt;%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n&lt;/Property&gt; &lt;!-- 定义文件名变量 --&gt; &lt;Property name=&quot;file.err.filename&quot;&gt;log/err.log&lt;/Property&gt; &lt;Property name=&quot;file.err.pattern&quot;&gt;log/err.%i.log.gz&lt;/Property&gt; &lt;/Properties&gt; &lt;!-- 定义Appender，即目的地 --&gt; &lt;Appenders&gt; &lt;!-- 定义输出到屏幕 --&gt; &lt;Console name=&quot;console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!-- 日志格式引用上面定义的log.pattern --&gt; &lt;PatternLayout pattern=&quot;${log.pattern}&quot; /&gt; &lt;/Console&gt; &lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt; &lt;RollingFile name=&quot;err&quot; bufferedIO=&quot;true&quot; fileName=&quot;${file.err.filename}&quot; filePattern=&quot;${file.err.pattern}&quot;&gt; &lt;PatternLayout pattern=&quot;${log.pattern}&quot; /&gt; &lt;Policies&gt; &lt;!-- 根据文件大小自动切割日志 --&gt; &lt;SizeBasedTriggeringPolicy size=&quot;1 MB&quot; /&gt; &lt;/Policies&gt; &lt;!-- 保留最近10份 --&gt; &lt;DefaultRolloverStrategy max=&quot;10&quot; /&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;info&quot;&gt; &lt;!-- 对info级别的日志，输出到console --&gt; &lt;AppenderRef ref=&quot;console&quot; level=&quot;info&quot; /&gt; &lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt; &lt;AppenderRef ref=&quot;err&quot; level=&quot;error&quot; /&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;/Configuration&gt; 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从这里下载Log4j，解压后，把以下3个jar包放到classpath中： log4j-api-2.x.jar log4j-core-2.x.jar log4j-jcl-2.x.jar 因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的commons-logging-1.2.jar也放到classpath中。 要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出 最佳实践在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入classpath，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。 小结通过Commons Logging实现日志，不需要修改代码即可使用Log4j； 使用Log4j只需要把log4j2.xml和相关jar放入classpath； 如果要更换Log4j，只需要移除log4j2.xml和相关jar； 只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。","categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"java","slug":"java","permalink":"/categories/java/"}]},{"title":"Java教程笔记之Maven基础","slug":"Java教程笔记之Maven基础","date":"2020-06-10T16:28:11.000Z","updated":"2020-07-22T15:37:48.895Z","comments":true,"path":"2020/06/11/Java教程笔记之Maven基础/","link":"","permalink":"/2020/06/11/Java教程笔记之Maven基础/","excerpt":"","text":"maven学习结合maven教程,廖雪峰的官方网站以及慕课的学习资料总结。 Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建。 基于工程对象模型（POM）的概念，通过一个中央信息管理模块，Maven 能够管理项目的构建、报告和文档。 Maven介绍先来看看一个Java项目需要的东西。 首先，确定引入哪些依赖包。如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j，就需要把log4j相关的jar包都放到classpath中。这些是依赖包的管理。 其次，确定项目的目录结构。例如，src目录存放Java源码，resources目录存放配置文件，bin目录存放编译生成的.class文件。 此外，配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。 最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。 这些工作非常琐碎耗时,我们需要一个标准化的Java项目管理和构建工具。 Maven就是专门为Java项目打造的管理和构建工具，它的主要功能有： 提供了一套标准化的项目结构； 提供了一套标准化的构建流程（编译，测试，打包，发布……）； 提供了一套依赖管理机制。 Maven项目结构一个使用Maven管理的普通Java项目，它的目录结构默认如下： 项目的根目录a-maven-project是项目名，它有一个项目核心配置文件pom.xml。 存放Java源码的目录是src/main/java，存放项目资源文件(如spring, hibernate配置文件)的目录是src/main/resources 存放测试源码的目录是src/test/java，存放测试资源的目录是src/test/resources 所有编译、打包生成的文件都放在target目录，如.class、.jar、.war文件 所有的目录结构都是约定好的标准结构，不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。 我们再来看最关键的一个项目描述文件pom.xml，它的内容长得像下面： &lt;project ...&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; ... &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。 使用&lt;dependency&gt;声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。 安装Maven要安装Maven，可以从Maven官网下载最新的Maven 3.6.x，然后在本地解压，设置几个环境变量，可参考Maven 环境配置 然后，打开命令行窗口，输入mvn -version，应该看到Maven的版本信息： 如果提示命令未找到，说明系统PATH路径有误，需要修复后再运行。 小结Maven是一个Java项目的管理和构建工具： Maven使用pom.xml定义项目内容，并使用预设的目录结构； 在Maven中声明一个依赖项可以自动下载并导入classpath； Maven使用groupId，artifactId和version唯一定位一个依赖。 依赖管理Maven解决了依赖管理问题。例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包： 当我们声明了abc的依赖时，Maven自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。 因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的jar包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。我们来看一个复杂依赖示例： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 当我们声明一个spring-boot-starter-web依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖： spring-boot-starter-web spring-boot-starter spring-boot sprint-boot-autoconfigure spring-boot-starter-logging logback-classic logback-core slf4j-api jcl-over-slf4j slf4j-api jul-to-slf4j slf4j-api log4j-over-slf4j slf4j-api spring-core snakeyaml spring-boot-starter-tomcat tomcat-embed-core tomcat-embed-el tomcat-embed-websocket tomcat-embed-core jackson-databind ... 如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。 依赖关系Maven定义了几种依赖关系，分别是compile、test、runtime和provided： scope 说明 示例 compile 编译时需要用到该jar包（默认） commons-logging test 编译Test时需要用到该jar包 junit runtime 编译时不需要，但运行时需要用到 mysql provided 编译时需要用到，但运行时由JDK或某个服务器提供 servlet-api 默认的compile是最常用的，Maven会把这种类型的依赖直接放入classpath。 test依赖表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是JUnit： &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; runtime依赖表示编译时不需要，但运行时需要。最典型的runtime依赖是JDBC驱动，例如MySQL驱动： &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; provided依赖表示编译时需要，但运行时不需要。最典型的provided依赖是Servlet-API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要： &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。 Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。 唯一ID对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包： groupId：属于组织名称，类似Java包名； artifactId：该jar包自身的名称，类似Java类名； version：该jar包的版本。 通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。 因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。 注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。 Maven镜像除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步： 中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录(Window : C:\\Users\\xxx.m2)下进入.m2目录，创建一个settings.xml配置文件，内容如下： &lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 国内推荐阿里云的Maven镜像 --&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt; 配置镜像仓库后，Maven的下载速度就会非常快。 搜索第三方组件最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制 构建流程Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。 Lifecycle和Phase使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。 Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase： validateinitializegenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resourcescompileprocess-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resourcestest-compileprocess-test-classestestprepare-packagepackagepre-integration-testintegration-testpost-integration-testverifyinstalldeploy 如果我们运行mvn package，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止： validate … package 如果我们运行mvn compile，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase： validate … compile Maven另一个常用的生命周期是clean，它会执行3个phase： pre-clean 执行清理前的工作 clean （注意这个clean不是lifecycle而是phase）清理上一次构建生成的所有文件 post-clean 执行清理后的文件 所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。 更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下： pre-clean clean （注意这个clean是phase） validate … package 在实际开发过程中，经常使用的命令有： mvn clean：清理所有生成的class和jar； mvn clean compile：先清理，再执行到compile； mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile； mvn clean package：先清理，再执行到package。 大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。 经常用到的phase其实只有几个： clean：清理删除target compile：编译 test：运行测试 package：打包 complie 编译 install 安装jar包到本地仓库中 Goal执行一个phase又会触发一个或多个goal： 执行的Phase 对应执行的Goal compile compiler:compile test compiler:testCompile surefire:test goal的命名总是abc:xyz这种形式。 lifecycle相当于Java的package，它包含一个或多个phase； phase相当于Java的class，它包含一个或多个goal； goal相当于class的method，它其实才是真正干活的。 大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器： mvn tomcat:run pom常用标签pom.xml：maven项目的核心管理文件，用于项目描述、组织管理、依赖管理、构建信息的管理，Pom中包含了许多的标签。 &lt;project&gt;：是pom.xml的根元素，包含了pom的一些约束信息。 &lt;modelVersion&gt;：是一个固定的版本，也是必须的元素，指定了当前pom的版本。 坐标的信息由以下标签组成： &lt;groupId&gt;：主项目的标识，用来定义当前的maven属于哪个实际的项目，和我们为项目创建的包是一样的，是由反写的公司网址+项目名组成 注意：maven的项目和实际的项目不是一一对应关系，maven项目体现的是模块化的概念，因此一个实际项目往往会划分成很多的模块。 &lt;artifactId&gt;：表示一个模块的标识,实际项目中的一个模块，一般会使用项目名+模块名进行标识，比如struts2项目，它下面可能分为struts2demo01、struts2demo02，struts2是项目名，而demo01和demo02是模块名 &lt;version&gt;标识当前项目的版本号，版本号一般都是由三个数字来组成的，第一个0标识大版本号，第二个0表示分支版本号，第三个0表示小版本号，一般形式可以写为0.0.1snapshot，snapshot为快照的版本，版本除了snapshot，还有内测的测试版本alpha，以及公测版beta,比如在网上玩新出的游戏，经常会有公测不删档，对应的就是该版本,还有Release版本，它是一个稳定的版本，以及GA版本是一个正式的发布版本。 &lt;packaging&gt;：maven项目打包的方式,不指定默认打包是jar，还可以打包成其他类型，比如war、zip、pom等 其他的标签： &lt;name&gt;：项目的描述名，一般是在产生对象文档时候才会使用 &lt;url&gt;：项目的地址 &lt;description&gt;：项目的描述 &lt;developers&gt;：开发人员的列表,项目发布的时候，可以把开发人员的信息填写进去 &lt;licenses&gt;：许可证的信息,比如经常用到的开源框架，它都会有一些许可证的信息 &lt;organization&gt;：组织信息 &lt;dependencies&gt;依赖列表：依赖列表下可以包含多个依赖项&lt;dependency&gt;，依赖项通过制定它的坐标来确定依赖所在的位置，也就是&lt;groupId&gt;&lt;artifactId&gt;&lt;version&gt;，还可以指定它的&lt;type&gt;,还可以使用&lt;scope&gt;指定依赖的范围（之前写的junit的测试范围是test，test表示junit，这个构件（junit的jar包），只在测试的依赖范围内有用，比如在主代码中引用junit这个类，它就会报错）,&lt;optional&gt;该标签有两个值，分别是true和false，它的作用是设置依赖是否可选，默认是false，子项目默认是false时，子项目默认是继承的，如果为true，子项目必须显示的引入该依赖， &lt;exclusions&gt;是一个排除依赖传递的列表，该标签下可以排除多个依赖通过&lt;exclusion&gt;,作用是：比如Ajar包依赖Bjar包，Bjar包又依赖Cjar包，C对于A来说就是传递依赖，如果A不想依赖C，就可以使用这个标签，比如我们使用的Spirng除了核心的jar包之外，它的jar包还引用其它很多相关的jar包，但对于我们而言只需要使用Spring的jar包，而其他的一些相关的jar包我们并不需要使用 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifacrId&gt;&lt;/artifacrId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;scope&gt;&lt;/scope&gt; &lt;optional&gt;&lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt;&lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt;:依赖的管理,也可以通过&lt;dependencies&gt;声明依赖列表,通过&lt;dependency&gt;包含多个依赖，但是它并不会被运行，也就是说它不会被引入到实际的依赖当中，该标签一般主要用于定义在父模块中，供子模块继承用的。比如之前多个maven项目中，都使用到junit，我们就可以抽象出一个父类的模块，然后在父类模块中对junit进行一个定义，其他子模块直接继承该父模块即可。 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagemant&gt; &lt;bulid&gt;通常为我们构建的行为来提供相应的支持，我们经常在这里使用到&lt;plugins&gt;表示插件的列表，在该标签下可以有多个&lt;plugins&gt;标签，（我们之前使用到source插件对项目进行打包），在&lt;plugins&gt;中依旧是要指出插件的坐标通过&lt;groupId&gt;&lt;artifactId&gt;&lt;version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;parent&gt;以及&lt;modules&gt;:经常使用到的：&lt;parent&gt;通常用于在子模块中对父模块的pom的一个继承，&lt;modules&gt;用来聚合运行多个maven的项目，如果有很多的maven模块是要编译的话呢，我们之前的办法是一个一个的编译，而使用&lt;modules&gt;就可以指定多个的模块，然后在一起进行编译。 小结Maven通过lifecycle、phase和goal来提供标准的构建流程。 最常用的构建命令是指定phase，然后让Maven执行到指定的phase： mvn clean mvn clean compile mvn clean test mvn clean package 通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。 maven核心知识生命周期完整的项目构建过程包括： 清理、编译、测试、打包、集成测试、验证、部署 maven中定义了三套相互独立的生命周期，每个生命周期包含若干阶段 clean 清理项目 default 构建项目 见前文 site 生成项目站点 ​ pre-site 在生成项目站点前要完成的工作 ​ site 生成项目的站点文档 ​ post-site 在生成项目站点后要完成的工作 ​ site-deploy 发布生成的站点到服务器 使用插件我们在前面介绍了Maven的lifecycle，phase和goal： ​ 使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。每个phase会执行自己默认的一个或多个goal。goal是最小任务单元。 我们以compile这个phase为例，如果执行： mvn compile Maven将执行compile这个phase，这个phase会调用compiler插件执行关联的compiler:compile这个goal。 实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行compile，它只是负责找到对应的compiler插件，然后执行默认的compiler:compile这个goal来完成编译。 所以，使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。 Maven已经内置了一些常用的标准插件： 插件名称 对应执行的phase clean clean compiler compile surefire test jar package 如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用maven-shade-plugin可以创建一个可执行的jar，要使用这个插件，需要在pom.xml中声明它： &lt;project&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; ... &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定Java程序的入口，它的配置是： &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;com.itranswarp.learnjava.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; 注意，Maven自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明。 下面列举了一些常用的插件： maven-shade-plugin：打包所有依赖包并生成可执行jar； cobertura-maven-plugin：生成单元测试覆盖率报告； findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。 模块管理在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法： 对于Maven工程来说，原来是一个大项目： 现在可以分拆成3个模块： Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; //包名 &lt;artifactId&gt;module-a&lt;/artifactId&gt; //类名 &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-a&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 模块B的pom.xml： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-b&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-b&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; // &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; // &lt;name&gt;parent&lt;/name&gt; // &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 注意到parent的&lt;packing&gt;是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。 现在我们的整个工程结构如下： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;module-a&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-a&lt;/name&gt; &lt;/project&gt; 模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。 如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B： ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-b&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 最后，在编译的时候，需要在根目录创建一个pom.xml统一编译： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;build&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;build&lt;/name&gt; &lt;modules&gt; &lt;module&gt;parent&lt;/module&gt; &lt;module&gt;module-a&lt;/module&gt; &lt;module&gt;module-b&lt;/module&gt; &lt;module&gt;module-c&lt;/module&gt; &lt;/modules&gt; &lt;/project&gt; 这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个``，一次性全部编译。 中央仓库​ 其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。 私有仓库​ 私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。 本地仓库​ 本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。 配置maven在eclipse中配置maven参考回答https://zhuanlan.zhihu.com/p/38762466 https://blog.csdn.net/wcc27857285/article/details/81812304 创建maven项目eclipse使用maven教程 问题解决 Eclipse创建的项目中没有Deployment Descriptor:XXX怎么办 https://blog.csdn.net/qq_23689053/article/details/89493879 使用maven构建web项目视频参考https://www.imooc.com/video/8684 Eclipse使用Maven搭建Java Web项目并部署Tomcat idea搭建SSM的maven项目（tomcat容器）","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Java教程笔记之面向对象编程","slug":"Java教程笔记之面向对象编程","date":"2020-06-09T14:24:27.000Z","updated":"2020-06-10T04:35:55.843Z","comments":true,"path":"2020/06/09/Java教程笔记之面向对象编程/","link":"","permalink":"/2020/06/09/Java教程笔记之面向对象编程/","excerpt":"","text":"重新学一遍Java,结合以前的笔记，内容主要摘自廖雪峰的官方网站,感谢分享。 Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。 和面向对象编程不同的，是面向过程编程。面向过程编程，是把模型分解成一步一步的过程。而面向对象编程，顾名思义，你得首先有个对象,有了对象后，就可以和对象进行互动： GirlFriend gf = new GirlFriend(); gf.name = &quot;Alice&quot;; gf.send(&quot;flowers&quot;); 面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。 面向对象基础class和instanceclass是一种对象模版，它定义了如何创建实例。class本身就是一种数据类型 instance是对象实例，instance是根据class创建的实例。可以创建多个instance，每个instance类型相同，但各自属性可能不相同 定义class在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： class Person { public String name; public int age; } 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 创建实例定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： Person ming = new Person(); 注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。我们可以通过这个指向实例的变量来操作实例。访问实例变量可以用变量.字段，例如： Person ming = new Person(); ming.name = &quot;Xiao Ming&quot;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = &quot;Xiao Hong&quot;; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： ┌──────────────────┐ ming ──────&gt;│Person instance │ ├──────────────────┤ │name = &quot;Xiao Ming&quot;│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────&gt;│Person instance │ ├──────────────────┤ │name = &quot;Xiao Hong&quot;│ │age = 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 小结在OOP中，class和instance是“模版”和“实例”的关系； 定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例； class定义的field，在每个instance都会拥有各自的field，且互不干扰； 通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance； 访问实例字段的方法是变量名.字段名；指向instance的变量都是引用变量。 方法一个class可以包含多个field，为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问。外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？ 我们需要使用方法（method）来让外部代码可以间接修改field public class Main { public static void main(String[] args) { Person ming =new Person(); ming.setName(&quot;zhang san&quot;); ming.setAge(12); System.out.print(ming.getName()+&quot;: &quot;+ming.getAge()); } } class Person{ private String name; private int age; public String getName() { return name; } public void setName(String name) { if (name == null || name.isBlank()){//不允许传入null和空字符串 throw new IllegalArgumentException(&quot;invalid name&quot;); } this.name = name.strip();//去掉首尾空格 } public int getAge() { return age; } public void setAge(int age) { if (age &lt; 0 || age &gt; 100) { throw new IllegalArgumentException(&quot;invalid age value&quot;); } this.age = age; } } 虽然外部代码不能直接修改private字段，但是，外部代码可以调用方法setName()和setAge()来间接修改private字段。在方法内部，我们就有机会检查参数对不对。 所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。 调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加; 定义方法定义方法的语法是： 修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法private方法不允许外部调用，内部方法可以调用。 this变量在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。通过this.field就可以访问当前实例的字段。 如果没有命名冲突，可以省略this。 class Person { private String name; public String getName() { return name; // 相当于this.name } } 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this： class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 } } 方法参数方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如： class Person { ... public void setNameAndAge(String name, int age) { ... } } 用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int： Person ming = new Person(); ming.setNameAndAge(&quot;Xiao Ming&quot;); // 编译错误：参数个数不对 ming.setNameAndAge(12, &quot;Xiao Ming&quot;); // 编译错误：参数类型不对 可变参数可变参数用类型...定义，可变参数相当于数组类型： class Group { private String[] names; public void setNames(String... names) { this.names = names; } } 调用时，可以这么写： Group g = new Group(); g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个String g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个String g.setNames(&quot;Xiao Ming&quot;); // 传入1个String g.setNames(); // 传入0个String 完全可以把可变参数改写为String[]类型： class Group { private String[] names; public void setNames(String[] names) { this.names = names; } } 但是，调用方需要自己先构造String[]，比较麻烦。例如： Group g = new Group(); g.setNames(new String[] {&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;}); // 传入1个String[] 另一个问题是，调用方可以传入null,而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。 参数绑定基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 // 基本类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15还是20?15 } } class Person { private int age; public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } } 引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。 // 引用类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { &quot;Homer&quot;, &quot;Simpson&quot; }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // &quot;Homer Simpson&quot; fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot; System.out.println(p.getName()); // &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;? } } class Person { private String[] name; public String getName() { return this.name[0] + &quot; &quot; + this.name[1]; } public void setName(String[] name) { this.name = name; } } 构造方法创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化： public class Main { public static void main(String[] args) { Person p = new Person(&quot;Xiao Ming&quot;, 15); System.out.println(p.getName()); System.out.println(p.getAge()); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。 默认构造方法如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样： class Person { public Person() { } } 如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法： public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来： public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： class Person { private String name; // 默认初始化为null private int age; // 默认初始化为0 public Person() { } } 在Java中，创建对象实例的时候，按照如下顺序进行初始化： 先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null； 执行构造方法的代码进行初始化。 因此，构造方法的代码由于后运行，所以，new Person(&quot;Xiao Ming&quot;, 12)的字段值最终由构造方法的代码确定。 多构造方法可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { } } 如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person()。 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(&quot;Unnamed&quot;); // 调用另一个构造方法Person(String) } } 方法重载方法名相同，但各自的参数不同，称为方法重载（Overload）。 注意：方法重载的返回值类型通常都是相同的。 方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 举个例子，String类提供了多个重载方法indexOf()，可以查找子串： int indexOf(int ch)：根据字符的Unicode码查找； int indexOf(String str)：根据字符串查找； int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置； int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置。 继承在前面的章节中，我们已经定义了Person类： class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } 现在，假设需要定义一个Student类，字段如下： class Student { private String name; private int age; private int score; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} public int getScore() { … } public void setScore(int score) { … } } 仔细观察，发现Student类包含了Person类已有的字段和方法，只是多出了一个score字段和相应的getScore()、setScore()方法。 能不能在Student中不要写重复的代码？ 这个时候，继承就派上用场了。 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 Java使用extends关键字来实现继承： class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … } } 通过继承，Student只需要编写额外的功能，不再需要重复代码。 注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！ 在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 继承树注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ │ ┌───────────┐ │ Student │ └───────────┘ Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ ▲ │ │ │ │ ┌───────────┐ ┌───────────┐ │ Student │ │ Teacher │ └───────────┘ └───────────┘ protected继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段： class Person { private String name; private int age; } class Student extends Person { public String hello() { return &quot;Hello, &quot; + name; // 编译错误：无法访问name字段 } } 这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问。 因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。 supersuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如： class Student extends Person { public String hello() { return &quot;Hello, &quot; + super.name; } } 在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super(); public class Main { public static void main(String[] args) { Student s = new Student(&quot;Xiao Ming&quot;, 12, 89); } } class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; } } class Student extends Person { protected int score; public Student(String name, int age, int score) { this.score = score; } } 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。 Student类的构造方法实际上是这样： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(); // 自动调用父类的构造方法 this.score = score; } } 但是，Person类并没有无参数的构造方法，因此，编译失败。 解决方法是调用Person类存在的某个构造方法。例如： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 调用父类的构造方法Person(String, int) this.score = score; } } 这样就可以正常编译了！ 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 向上转型如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例： Student s = new Student(); 如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例： Person p = new Person(); 现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？ Person p = new Student(); // ??? 测试一下就可以发现，这种指向是允许的！ 这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 Student s = new Student(); Person p = s; // upcasting, ok Object o1 = p; // upcasting, ok Object o2 = s; // upcasting, ok 注意到继承树是Student &gt; Person &gt; Object，所以，可以把Student类型转型为Person，或者更高层次的Object。 向下转型和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如： Person p1 = new Student(); // upcasting, ok Person p2 = new Person(); Student s1 = (Student) p1; // ok Student s2 = (Student) p2; // runtime error! ClassCastException! 不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。 为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型。 instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。 利用instanceof，在向下转型前可以先判断： Person p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 } 区分继承和组合在使用继承时，我们要注意逻辑一致性。继承是is关系，组合是has关系。 具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例： class Student extends Person { protected Book book; protected int score; } 多态在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 例如，在Person类中，我们定义了run()方法： class Person { public void run() { System.out.println(&quot;Person.run&quot;); } } 在子类Student中，覆写这个run()方法： class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } Override和Overload不同的是，方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。 class Person { public void run() { … } } class Student extends Person { // 不是Override，因为参数不同: public void run(String s) { … } // 不是Override，因为返回值不同: public int run() { … } } 加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错，但是@Override不是必需的。 已经知道，引用变量的声明类型可能与其实际类型不符，例如： Person p = new Student(); 如果子类覆写了父类的方法,例如student复写了person的方法，那么，一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？： public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); // 应该打印Person.run还是Student.run? } } class Person { public void run() { System.out.println(&quot;Person.run&quot;); } } class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } 运行一下上面的代码就可以知道，实际上调用的方法是Student的run()方法。因此可得出结论： Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。 这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： public void runTwice(Person p) { p.run(); p.run(); } 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。 多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。 这种不确定性的方法调用，究竟有什么作用？ 假设我们定义一种收入，需要给它报税，那么先定义一个Income类： class Income { protected double income; public double getTax() { return income * 0.1; // 税率10% } } 对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()： class Salary extends Income { @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; } } 如果你享受国务院特殊津贴，那么按照规定，可以全部免税： class StateCouncilSpecialAllowance extends Income { @Override public double getTax() { return 0; } } 现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写： public double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } 来试一下（给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税）： public class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } } class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% } } class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; } } class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; } } 利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 覆写Object方法因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 在必要的情况下，我们可以覆写Object的这几个方法。例如： class Person { ... // 显示更有意义的字符串: @Override public String toString() { return &quot;Person:name=&quot; + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); } } 调用super在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。 class Person { protected String name; public String hello() { return &quot;Hello, &quot; + name; } } Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + &quot;!&quot;; } } final继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： class Person { protected String name; public final String hello() { return &quot;Hello, &quot; + name; } } 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： final class Person { protected String name; } // compile error: 不允许继承自Person Student extends Person { } 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。例如： class Person { public final String name = &quot;Unamed&quot;; //对final字段重新赋值会报错 } 可以在构造方法中初始化final字段： class Person { public final String name; public Person(String name) { this.name = name; } } 这种方法更为常用，因为可以保证实例一旦创建，其final字段就不可修改。 小结： 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为； Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态； final修饰符有多种作用： final修饰的方法可以阻止被覆写； final修饰的class可以阻止被继承； final修饰的field必须在创建对象时初始化，随后不可修改。 抽象类由于多态的存在，每个子类都可以覆写父类的方法，如果父类的方法没有实际意义，能否去掉方法的执行语句？答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。能不能去掉父类的方法？答案还是不行，因为去掉父类的方法，就失去了多态的特性。 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： class Person {//无法编译 public abstract void run(); } 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： abstract class Person { public abstract void run(); } 抽象类如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： Person p = new Person(); // 编译错误 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); } } abstract class Person { public abstract void run(); } class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } 抽象类的使用要点: 有抽象方法的类只能定义成抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承， 抽象方法必须被子类实现。 面向抽象编程当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： Person s = new Student(); Person t = new Teacher(); 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： // 不关心Person变量的具体子类型: s.run(); t.run(); 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： // 同样不关心新的子类是如何实现run()方法的： Person e = new Employee(); e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 小结 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范； 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法； 如果不实现抽象方法，则该子类仍是一个抽象类； 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。 接口在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： abstract class Person { public abstract void run(); public abstract String getName(); } 就可以把该抽象类改写为接口：interface。在Java中，使用interface可以声明一个接口： interface Person { void run(); String getName(); } 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + &quot; run&quot;); } @Override public String getName() { return this.name; } } 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： class Student implements Person, Hello { // 实现了两个interface ... } 术语Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 抽象类和接口的对比如下： abstract class interface 继承 只能extends一个class 可以implements多个interface 字段 可以定义实例字段 不能定义实例字段 抽象方法 可以定义抽象方法 可以定义抽象方法 非抽象方法 可以定义非抽象方法 可以定义default方法 接口继承一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： interface Hello { void hello(); } interface Person extends Hello { void run(); String getName(); } 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 继承关系合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。 可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系： 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象： List list = new ArrayList(); // 用List接口引用具体子类的实例 Collection coll = list; // 向上转型为Collection接口 Iterable it = coll; // 向上转型为Iterable接口 default方法实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 public class Main { public static void main(String[] args) { Person p = new Student(&quot;Xiao Ming&quot;); p.run(); } } interface Person { String getName(); default void run() { System.out.println(getName() + &quot; run&quot;); } } class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; } } 静态字段和静态方法在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子： class Person { public String name; public int age; // 定义静态字段number: public static int number; } 我们来看看下面的代码： public class Main { public static void main(String[] args) { Person ming = new Person(&quot;Xiao Ming&quot;, 12); Person hong = new Person(&quot;Xiao Hong&quot;, 15); ming.number = 88; System.out.println(hong.number); //88 hong.number = 99; System.out.println(ming.number); //99 } } class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; } } 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例： 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： Person.number = 99; System.out.println(Person.number); 静态方法有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如： public class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); } } class Person { public static int number; public static void setNumber(int value) { number = value; } } 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 静态方法经常用于工具类。例如： Arrays.sort() Math.random() 静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。 接口的静态字段因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： public interface Person { public static final int MALE = 1; public static final int FEMALE = 2; } 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2; } 编译器会自动把该字段变为public static final类型。 小结 静态字段属于所有实例“共享”的字段，实际上是属于class的字段； 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法； 静态方法常用于工具类和辅助方法。 包在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 例如： 小明的Person类存放在包ming下面，因此，完整类名是ming.Person； 小红的Person类存放在包hong下面，因此，完整类名是hong.Person； 小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays； JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays。 在定义class的时候，我们需要在第一行声明这个class属于哪个包。 小明的Person.java文件： package ming; // 申明包名ming public class Person { } 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。 包可以是多层结构，用.隔开。例如：java.util。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是: package_sample └─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致。 包作用域位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： package hello; public class Person { // 包作用域: void hello() { System.out.println(&quot;Hello!&quot;); } } Main类也定义在hello包下面： package hello; public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 } } import在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法： 第一种，直接写出完整类名mr.jun.Arrays arrays = new mr.jun.Arrays(); 第二种写法是用import语句，导入小军的Arrays，然后写简单类名： package ming; // 导入完整类名: import mr.jun.Arrays; public class Person { public void run() { Arrays arrays = new Arrays(); } } 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）：import mr.jun.*;我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 还有一种import static的语法，它可以导入一个类的静态字段和静态方法： ackage main; // 导入System类的所有静态字段和静态方法: import static java.lang.System.*; public class Main { public static void main(String[] args) { // 相当于调用System.out.println(…) out.println(&quot;Hello, world!&quot;); } } import static很少使用。 Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 // Main.java package test; import java.text.Format; public class Main { public static void main(String[] args) { java.util.List list; // ok，使用完整类名 -&gt; java.util.List Format format = null; // ok，使用import的类 -&gt; java.text.Format String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type } } 编写class的时候，编译器会自动帮我们做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。 如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 最佳实践为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。 子包可以根据功能自行命名，如org.apache. commons.log 要注意不要和java.lang包的类重名,注意也不要和JDK常用类重名 小结Java内建的package机制是为了避免class命名冲突； JDK的核心类使用java.lang包，编译器会自动导入； JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，……； 包名推荐使用倒置的域名，例如org.apache。 作用域 定义为public的class、interface可以被其他任何类访问 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限 定义为private的field、method无法被其他类访问,确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法.由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限。 public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(&quot;private hello!&quot;); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } } } protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 default只要在同一个包，就可以访问package(default)权限的class、field和method 小结Java内建的访问权限包括public、protected、private和package(default)权限； Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束； final修饰符不是访问权限，它可以修饰class、field和method； 一个.java文件只能包含一个public类，但可以包含多个非public类。 面向对象的内存分析Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。 栈的特点如下： 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 堆的特点如下： 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点如下： JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 垃圾回收机制垃圾回收机制（Garbage Collection） 针对内存管理问题，Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配：使用new关键字创建对象即可 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情： 发现无用的对象 无用的对象指的就是没有任何变量引用该对象 回收无用对象占用的内存空间 Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理 垃圾回收相关算法引用计数法 堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。 public class Student { String name; Student friend; public static void main(String[] args) { Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; } } s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。 引用可达法(根搜索算法) 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 通用的分代垃圾回收机制将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。 Minor GC:用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) Major GC：用于清理老年代区域。 Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 清理过程 创建新对象，大多数放在Eden区 Eden满了（或达到一定比例），触发Minor GC, 把有用的复制到Survivor1, 同时清空Eden区。 Eden区再次满了，出发Minor GC, 把Eden和Survivor1中有用的，复制到Survivor2, 同时清空Eden，Survivor1。 Eden区第三次满了，出发Minor GC, 把Eden和Survivor2中有用的，复制到Survivor1, 同时清空Eden，Survivor2。形成循环，Survoivor1和Survivor2中来回清空、复制，过程中有一个Survivor处于空的状态用于下次复制的。 重复多次（默认15），没有被Survivor清理的对象，复制到Old（Tenuerd）区。 当Old达到一定比例，触发Major GC，清理老年代。 当Old满了，触发Full 。注意，Full GC清理代价大，系统资源消耗高。 Java核心类本节我们将介绍Java的核心类，包括：字符串、StringBuilder、StringJoiner、包装类型、JavaBean、枚举、常用工具类 字符串和编码String在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用&quot;...&quot;来表示一个字符串： String s1 = &quot;Hello!&quot;; 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的： String s2 = new String(new char[] {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;}); 因为String太常用了，所以Java提供了&quot;...&quot;这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 public class Main { public static void main(String[] args) { String s = &quot;Hello&quot;; System.out.println(s); //Hello s = s.toUpperCase(); System.out.println(s); //HELLO,S重新指向了新的字符串 } } 字符串比较当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。 public class Main { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; System.out.println(s1 == s2); \\\\true System.out.println(s1.equals(s2)); \\\\true } } 表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 所以，这种==比较返回true纯属巧合。换一种写法，==比较就会失败：String s2 = &quot;HELLO&quot;.toLowerCase(); 结论：两个字符串比较，必须总是使用equals()方法。要忽略大小写比较，使用equalsIgnoreCase()方法。 String类还提供了多种方法来搜索子串、提取子串。常用的方法有： // 搜索子串: &quot;Hello&quot;.contains(&quot;ll&quot;); // true &quot;Hello&quot;.indexOf(&quot;l&quot;); // 2 &quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3 &quot;Hello&quot;.startsWith(&quot;He&quot;); // true &quot;Hello&quot;.endsWith(&quot;lo&quot;); // true //提取子串： &quot;Hello&quot;.substring(2); // &quot;llo&quot; &quot;Hello&quot;.substring(2, 4);// &quot;ll&quot; [)的关系 去除首尾空白字符使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n： &quot; \\tHello\\r\\n &quot;.trim(); // &quot;Hello&quot; 注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。 另一个strip()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除： &quot;\\u3000Hello\\u3000&quot;.strip(); // &quot;Hello&quot; &quot; Hello &quot;.stripLeading(); // &quot;Hello &quot; &quot; Hello &quot;.stripTrailing(); // &quot; Hello&quot; String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串： &quot;&quot;.isEmpty(); // true，因为字符串长度为0 &quot; &quot;.isEmpty(); // false，因为字符串长度不为0 &quot; \\n&quot;.isBlank(); // true，因为只包含空白字符 &quot; Hello &quot;.isBlank(); // false，因为包含非空白字符 替换子串要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换： String s = &quot;hello&quot;; s.replace(&#39;l&#39;, &#39;w&#39;); // &quot;hewwo&quot;，所有字符&#39;l&#39;被替换为&#39;w&#39; s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot; 另一种是通过正则表达式替换： String s = &quot;A,,B;C ,D&quot;; s.replaceAll(&quot;[\\\\,\\\\;\\\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot; 上面的代码通过正则表达式，把匹配的子串统一替换为&quot;,&quot;。关于正则表达式的用法我们会在后面详细讲解。 分割字符串要分割字符串，使用split()方法，并且传入的也是正则表达式： String s = &quot;A,B,C,D&quot;; String[] ss = s.split(&quot;\\\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;} 拼接字符串拼接字符串使用静态方法join()，它用指定的字符串连接字符串数组： String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}; String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; 格式化字符串字符串提供了formatted()方法和format()静态方法，可以传入其他参数，替换占位符，然后生成新的字符串： public class Main { public static void main(String[] args) { String s = &quot;Hi %s, your score is %d!&quot;; System.out.println(s.formatted(&quot;Alice&quot;, 80)); System.out.println(String.format(&quot;Hi %s, your score is %.2f!&quot;, &quot;Bob&quot;, 59.5)); } } 有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有： %s：显示字符串； %d：显示整数； %x：显示十六进制整数； %f：显示浮点数。 占位符还可以带格式，例如%.2f表示显示两位小数。如果你不确定用啥占位符，那就始终用%s，因为%s可以显示任何数据类型。 类型转换要把任意基本类型或引用类型转换为字符串，可以使用静态方法valueOf()。这是一个重载方法，编译器会根据参数自动选择合适的方法： String.valueOf(123); // &quot;123&quot; String.valueOf(45.67); // &quot;45.67&quot; String.valueOf(true); // &quot;true&quot; String.valueOf(new Object()); // 类似java.lang.Object@636be97c 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为int类型： int n1 = Integer.parseInt(&quot;123&quot;); // 123 int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255 把字符串转换为boolean类型： boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false 转换为char[]String和char[]类型可以互相转换，方法是： char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[] String s = new String(cs); // char[] -&gt; String 如果修改了char[]数组，String并不会改变 public class Main { public static void main(String[] args) { char[] cs = &quot;Hello&quot;.toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = &#39;X&#39;; System.out.println(s); } } 这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。 字符编码ASCII编码占用一个字节，编码范围从0到127，最高位始终为0。例如，字符&#39;A&#39;的编码是0x41，字符&#39;1&#39;的编码是0x31。 把汉字也纳入计算机编码，很显然一个字节不够。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字&#39;中&#39;的GB2312编码是0xd6d0。 类似的，日文有Shift_JIS编码，这些编码因为标准不统一，同时使用，就会产生冲突。为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。 Unicode编码需要两个或者更多字节表示，我们可以比较中英文字符在ASCII、GB2312和Unicode的编码： 英文字符&#39;A&#39;的ASCII编码和Unicode编码： ┌────┐ ASCII: │ 41 │ └────┘ ┌────┬────┐ Unicode: │ 00 │ 41 │ └────┴────┘ 英文字符的Unicode编码就是简单地在前面添加一个00字节。 中文字符&#39;中&#39;的GB2312编码和Unicode编码： ┌────┬────┐ GB2312: │ d6 │ d0 │ └────┴────┘ ┌────┬────┐ Unicode: │ 4e │ 2d │ └────┴────┘ 因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符&#39;A&#39;的UTF-8编码变为0x41，正好和ASCII码一致，而中文&#39;中&#39;的UTF-8编码为3字节0xe4b8ad。 UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。 在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做： byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐 byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换 byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换 byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 注意：转换编码后，就不再是char类型，而是byte类型表示的数组。 如果要把已知编码的byte[]转换为String，可以这样做： byte[] b = ... String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换 String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 始终牢记：Java的String和char在内存中总是以Unicode编码表示。 小结 Java字符串String是不可变对象； 字符串操作不改变原字符串内容，而是返回新字符串； 常用的字符串操作：提取子串、查找、替换、大小写转换等； Java使用Unicode编码表示String和char； 转换编码就是将String和byte[]转换，需要指定编码； 转换为byte[]时，始终优先考虑UTF-8编码。 StringBuilderJava编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。 考察下面的循环代码： String s = &quot;&quot;; for (int i = 0; i &lt; 1000; i++) { s = s + &quot;,&quot; + i; } 虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： StringBuilder sb = new StringBuilder(1024); for (int i = 0; i &lt; 1000; i++) { sb.append(&#39;,&#39;); sb.append(i); } String s = sb.toString(); StringBuilder还可以进行链式操作： public class Main { public static void main(String[] args) { var sb = new StringBuilder(1024);//类型的名字太长，写起来比较麻烦,如果想省略变量类型，可以使用var关键字,编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder sb.append(&quot;Mr &quot;) .append(&quot;Bob&quot;) .append(&quot;!&quot;) .insert(0, &quot;Hello, &quot;); System.out.println(sb.toString()); //Hello, Mr Bob! } } 如果我们查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。 仿照StringBuilder，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器： public class Main { public static void main(String[] args) { Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value());//19 } } class Adder { private int sum = 0; public Adder add(int n) { sum += n; return this; } public Adder inc() { sum ++; return this; } public int value() { return sum; } } 注意：对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。 StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。 StringJoiner用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事： public class Main { public static void main(String[] args) { String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; var sj = new StringJoiner(&quot;, &quot;); //需要给StringJoiner指定“开头”和“结尾”： var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;); for (String name : names) { sj.add(name); } System.out.println(sj.toString());//Bob, Alice, Grace System.out.println(sj.toString());//Hello Bob, Alice, Grace! } } 查看源码，可以发现，StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。 String.join()String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便： String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; var s = String.join(&quot;, &quot;, names); 包装类型Java的数据类型分两种： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： String s = null; int n = null; // compile error! 如何把一个基本类型视为对象（引用类型）？ 比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）： public class Integer { private int value; public Integer(int value) { this.value = value; } public int intValue() { return this.value; } } 定义好了Integer类，我们就可以把int和Integer互相转换： Integer n = null; Integer n2 = new Integer(99); int n3 = n2.intValue(); 实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 我们可以直接使用，并不需要自己去定义： public class Main { public static void main(String[] args) { int i = 100; // 通过new操作符创建Integer实例(不推荐使用,会有编译警告): Integer n1 = new Integer(i); // 通过静态方法valueOf(int)创建Integer实例: Integer n2 = Integer.valueOf(i); // 通过静态方法valueOf(String)创建Integer实例: Integer n3 = Integer.valueOf(&quot;100&quot;); System.out.println(n3.intValue()); } } Auto BoxingJava编译器可以帮助我们自动在int和Integer之间转型： Integer n = 100; // 编译器自动使用Integer.valueOf(int) int x = n; // 编译器自动使用Integer.intValue() 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException。 不变类所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下： public final class Integer { private final int value; } 因此，一旦创建了Integer对象，该对象就是不变的。 对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较 public class Main { public static void main(String[] args) { Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(&quot;x == y: &quot; + (x==y)); // true System.out.println(&quot;m == n: &quot; + (m==n)); // false System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true } } 较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 进制转换最常用的静态方法parseInt()可以把字符串解析成一个整数： int x1 = Integer.parseInt(&quot;100&quot;); // 100 int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析 Integer还可以把整数格式化为指定进制的字符串： public class Main { public static void main(String[] args) { System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制 System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制 System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制 System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制 System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制 } } 注意：上述方法的输出都是String 我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。 这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。 Java的包装类型还定义了一些有用的静态变量 // boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段: Boolean t = Boolean.TRUE; Boolean f = Boolean.FALSE; // int可表示的最大/最小值: int max = Integer.MAX_VALUE; // 2147483647 int min = Integer.MIN_VALUE; // -2147483648 // long类型占用的bit和byte数量: int sizeOfLong = Long.SIZE; // 64 (bits) int bytesOfLong = Long.BYTES; // 8 (bytes) 最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： // 向上转型为Number: Number num = new Integer(999); // 获取byte, int, long, float, double: byte b = num.byteValue(); int n = num.intValue(); long ln = num.longValue(); float f = num.floatValue(); double d = num.doubleValue(); 处理无符号整型在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。 例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int： public class Main { public static void main(String[] args) { byte x = -1; byte y = 127; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(y)); // 127 } } 类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。 JavaBean在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 如果读写方法符合以下这种命名规范： // 读方法: public Type getXyz() // 写方法: public void setXyz(Type value) 那么这种class被称为JavaBean 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz()。 boolean字段比较特殊，它的读方法一般命名为isXyz()： // 读方法: public boolean isChild() // 写方法: public void setChild(boolean value) 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 属性只需要定义getter和setter方法，不一定需要对应的字段。例如，child只读属性定义如下： public class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } public boolean isChild() { return age &lt;= 6; } } 可以看出，getter和setter也是一种数据封装的方法。 枚举类在Java中，我们可以通过static final来定义常量。使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。 enum为了让编译器能自动检查某个值在枚举的集合内，并且不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(&quot;Work at home!&quot;); } else { System.out.println(&quot;Work at office!&quot;); } } } enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT; } 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过： int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator &#39;==&#39; } 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值： Weekday x = Weekday.SUN; // ok! Weekday y = Color.RED; // Compile error: incompatible types 这就使得编译器可以在编译期自动检查出所有可能的潜在错误。 enum的比较使用enum定义的枚举类是一种引用类型。引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： if (day == Weekday.FRI) { // ok! } if (day.equals(Weekday.SUN)) { // ok, but more code! } enum类型通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 例如，我们定义的Color枚举类： public enum Color { RED, GREEN, BLUE; } 编译器编译出的class大概就像这样： public final class Color extends Enum { // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() {} } 因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法： name():返回常量名，例如： String s = Weekday.SUN.name(); // &quot;SUN&quot; ordinal():返回定义的常量的顺序，从0开始计数，例如： int n = Weekday.MON.ordinal(); // 1 改变枚举常量定义的顺序就会导致ordinal()返回值发生变化。如果在代码中编写了类似if(x.ordinal()==1)这样的语句，就要保证enum的枚举顺序不能变。新增的常量必须放在最后。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且给每个枚举常量添加字段： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { System.out.println(&quot;Work at home!&quot;); } else { System.out.println(&quot;Work at office!&quot;); } } } enum Weekday { MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);//每个枚举值都是class实例 public final int dayValue; private Weekday(int dayValue) { this.dayValue = dayValue; } } 注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！ 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); } else { System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); } } } enum Weekday { MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) { this.dayValue = dayValue; this.chinese = chinese; } @Override public String toString() { return this.chinese; } } 覆写toString()的目的是在输出时更有可读性。 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！ switch最后，枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比int、String类型更适合用在switch语句中： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); break; case SAT: case SUN: System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); break; default: throw new RuntimeException(&quot;cannot process &quot; + day); //加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。 } } } enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN; } 小结Java使用enum定义枚举类型，它被编译器编译为final class Xxx extends Enum { … }； 通过name()获取常量定义的字符串，注意不要使用toString()； 通过ordinal()返回常量定义的顺序（无实质意义）； 可以为enum编写构造方法、字段和方法 enum的构造方法要声明为private，字段强烈建议声明为final； enum适合用在switch语句中。 BigInteger在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。 如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数,对BigInteger做运算的时候，只能使用实例方法，例如，加法运算： BigInteger i1 = new BigInteger(&quot;1234567890&quot;); BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;); BigInteger sum = i1.add(i2); // 12345678902469135780 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。也可以把BigInteger转换成long型: BigInteger i = new BigInteger(&quot;123456789000&quot;); System.out.println(i.longValue()); // 123456789000 System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range 使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException。 可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。如果BigInteger的值甚至超过了float的最大范围（3.4*10^38),那么返回的float是Infinity 。 BigDecimalBigDecimal可以表示一个任意大小且精度完全准确的浮点数。 BigDecimal bd = new BigDecimal(&quot;123.4567&quot;); System.out.println(bd.multiply(bd)); // 15241.55677489 BigDecimal用scale()表示小数位数，例如 BigDecimal d1 = new BigDecimal(&quot;123.45&quot;); System.out.println(d1.scale()); // 2,两位小数 通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal： BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;); BigDecimal d2 = d1.stripTrailingZeros(); System.out.println(d1.scale()); // 4 System.out.println(d2.scale()); // 2,因为去掉了00 BigDecimal d3 = new BigDecimal(&quot;1234500&quot;); BigDecimal d4 = d3.stripTrailingZeros(); System.out.println(d3.scale()); // 0 System.out.println(d4.scale()); // -2，表示这个数是个整数，并且末尾有2个0 可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断： public class Main { public static void main(String[] args) { BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); } } 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： BigDecimal d1 = new BigDecimal(&quot;123.456&quot;); BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;); BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入 BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 还可以对BigDecimal做除法的同时求余数： public class Main { public static void main(String[] args) { BigDecimal n = new BigDecimal(&quot;12.345&quot;); BigDecimal m = new BigDecimal(&quot;0.12&quot;); BigDecimal[] dr = n.divideAndRemainder(m); System.out.println(dr[0]); // 102 System.out.println(dr[1]); // 0.105 } } 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： BigDecimal n = new BigDecimal(&quot;12.75&quot;); BigDecimal m = new BigDecimal(&quot;0.15&quot;); BigDecimal[] dr = n.divideAndRemainder(m); if (dr[1].signum() == 0) { // n是m的整数倍 } 比较BigDecimal比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等。 必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！ BigDecimal d1 = new BigDecimal(&quot;123.456&quot;); BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;); System.out.println(d1.equals(d2)); // false,因为scale不同 System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2 System.out.println(d1.compareTo(d2)); // 0 常用工具类MathMath类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算 生成一个随机数x，x的范围是0 &lt;= x &lt; 1： Math.random(); // 0.53907... 每次都不一样 如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下： // 区间在[MIN, MAX)的随机数 public class Main { public static void main(String[] args) { double x = Math.random(); // x的范围是[0,1) double min = 10; double max = 50; double y = x * (max - min) + min; // y的范围是[10,50) long n = (long) y; // n的范围是[10,50)的整数 System.out.println(y); System.out.println(n); } } Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 RandomRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： Random r = new Random(); r.nextInt(); // 2071575453,每次都不一样 r.nextInt(10); // 5,生成一个[0,10)之间的int ...... 每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。 这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列 Random r = new Random(12345); 前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。 SecureRandomSecureRandom就是用来创建安全的随机数的： SecureRandom sr = new SecureRandom(); System.out.println(sr.nextInt(100)); 实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： public static void main(String[] args) { SecureRandom sr = null; try { sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 } catch (NoSuchAlgorithmException e) { sr = new SecureRandom(); // 获取普通的安全随机数生成器 } byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); } SecureRandom`的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶","slug":"Python入门与进阶","date":"2020-05-25T17:04:11.000Z","updated":"2020-06-12T05:45:11.373Z","comments":true,"path":"2020/05/26/Python入门与进阶/","link":"","permalink":"/2020/05/26/Python入门与进阶/","excerpt":"","text":"Python特点1.Python是一门编程语言，它只是众多编程语言中的一种。 2.语言简洁、优雅，编写的程序容易阅读。 3.跨平台，可以运行在Windows、Linux以及MacOS 4.易于学习。如果把编程语言当作解决问题的工具，python确实比C++、Java、JavaScript等语言要易于学习和掌握。 5.极为强大而丰富的标准库与第三方库，比如电子邮件，比如GUI界面。 6.Python是面向对象的语言。面向对象是一种思想。 个人理解（供参考）：面向对象理解成代码的体制和构建的方式。由面向对象来组织代码，让整个工程或项目更佳清晰，组织方式合理，源代码更易阅读和管理。项目足够庞大时，面向过程的思想不易于代码的管理。 个人喜欢Python原因1.简洁，灵活，优雅，哲学 简洁胜于复杂。 做也许好过不做，但不假思索就动手还不如不做。 2.易于上手难于精通 3.Python既有动态脚本的特性，又有面向对象的特性，非常具有自己的特点。 Python的缺点相较于C、C++、Java，运行效率较慢 主流语言分两大类，编译型语言（C、C++）、解释型语言（JavaScript、Python）。 编译型语言在程序执行前会预先编译，将源代码编译成机器码，执行效率高。 解释型语言没有编译过程，执行时解释。 Java和C #没有严格的划分。有编译过程，编译成中间代码（非机器码） 运行效率与开发效率，鱼与熊掌不可兼得。适合的才是最好的。 一个学习编程的经典误区不要把思维局限在web编程，这只是编程的一个应用方向。 用途爬虫、大数据与数据分析（Spark）、自动化运维与测试、web开发(Flask、Django等)、机器学习(Tensor Flow)、胶水语言（混合其他语言来编程，能够把其他语言制作的各种模块很轻松的连接在一起）。 Python环境安装1.Windows下一键环境安装包【Python官网】—-【downloads】—-【Windows】 2.安装Python1.打开安装包，按下图方式安装。推荐自定义安装 2.默认勾选，pip一定要选 3.下一步，选择安装位置 4.完成安装，阅读官方使用说明文档documentation 3.IDLE与第一段Python代码 代码与写代码代码是现实世界事物在计算机世界中的映射 写代码是将现实世界中的事物用计算机语言来描述 计算机语言的基本数据类型是构成代码的基础。 基本数据类型 Number:数字整数：int 浮点数：float 布尔类型：bool 表示真、假 True、False 复数：complex 其他语言：浮点数有单精度float,双精度double的分别。python中只有float代表浮点数 ​ 整数有short,int,long的分别，python只有int 数值运算 在加减乘计算时，如果有浮点数参与运算，Python会把结果转换成为浮点数。 除法中， / 返回浮点数，// 返回整数(只保留整数部分)。 进制二进制0b开头，八进制0o开头，十六进制0x开头 不同进制间的转换 bin(10) #十进制转二进制 bin(0o7) #八进制转二进制 int(0b111) #二进制转十进制 int(0o77) #八进制转十进制 hex(888) #十进制转十六进制 oct(0x777) #十六进制转八进制 ······ 只要是非0的数都表示布尔真，只有0、空值表示布尔假 bool(2) #True bool(2.2) #True bool(-1.1) #True bool(&#39;abc&#39;) #True bool(0) #False bool(&#39;&#39;) #False bool([]) #False bool(None) #False 函数 描述 int() 转十进制 bin() 转二进制 oct() 转八进制 hex() 转十六进制 ord() 转ascii bool() 转bool（非空、非0、非None，则为True） String字符串单引号、双引号、多行字符串注意引号必须成对出现 &#39;hello world&#39; &quot;hello world&quot; &quot;let&#39;s go&quot; #单双引号是为了在引号中引用引号 &#39;&#39;&#39; hello world &#39;&#39;&#39; #三（单双）引号可以显示多行字符串，print(&quot;hello\\nworld&quot;)有同样效果 &#39;1&#39; #str类型 转移字符特殊的字符：表示无法“看见”的字符、与语言本身语法有冲突的字符 \\n #换行 \\r #回车 \\&#39; #单引号 \\t #横向制表符 print(&#39;c:\\northwind\\northwest&#39;) #输出结果会换行 print(&#39;c:\\\\northwind\\\\northwest&#39;) 或print(r&#39;c:\\northwind\\northwest&#39;) #输出结果c:\\northwind\\northwest #加上r后不是一个普通的字符串，而是一个原始字符串（所见即所得） ······ 字符串运算字符串拼接 &quot;hello&quot;+&quot;world&quot; #输出helloworld 字符串复制 &quot;hello&quot;*n #hello拼接n次 字符串访问 &quot;hello world&quot;[下标a:下标b] #从左往右以0开始，从右往左以-1开始,截取序列的[a,b) &quot;hello world&quot;[n] #从左往右以0开始，反之以-1开始,访问单个字符 #输出world的方法 &quot;hello world&quot;[6:] &quot;hello world&quot;[-5:] 组列表list[1,2,3,4] [&quot;hello&quot;,1.9,True,[1,2]] #列表内部元素的类型不是固定的 列表的基本操作 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;][n] #方法同string [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;][a:b] #方法同上 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]+[&quot;pear&quot;,&quot;lemon&quot;] #两个列表合并 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]*3 #重复3次 元组tuple(1,2,3,4) (&quot;hello&quot;,1.9,True,(1,2)) #元组内部元素的类型不是固定的 元组的基本操作 (1,2,3,4)[0] #方法同上 (1,2,3,4)[0:2] (1,2,3)+(4,5,6) (1,2,3)*3 元组和列表的区别元组的元素不能修改，列表的元素可以修改。 注意：当元组内只有一个元素时，其类型是单个元素对应的类型。如（1）为int，（‘asd’）为str。而当列表内只有一个元素时，仍然是list类型。 type((1)) 只有一个元素时，内部的（）做成运算符号处理。若要定义一个只有一个元素的元组，（1，） Python中，str,list,typle都是序列 序列共有特征 #根据序号找值 #根据切片（范围）找值 # *复制 # a not in [序列] 判断元素a是否（不）在序列中 #len(序列) 序列的元素长度 #max(序列) 集合set① 格式{元素1，元素2...}或set(&#39;元素1元素2元素3...&#39;) ② 特性集合是无序的，且元素不重复。 注意：创建空集合必须用 set()而不是 { }，因为 { } 是用来创建一个空字典。 {1,1,1,2,2,3} #最后显示{1,2,3} ③ 操作集合 运算符 功能 - 差集 \\ 并集 &amp; 交集 a ^ b a和b不同时存在的元素 {1,2,3,4,5,6}-{3,4} #{1,2,5,6} {1,2,3,4,5,6}&amp;{3,4} #{3,4} {1,2,3,4,5,6}|{3,4} #{1,2,3,4,5,6,7} 字典Dictionary① 格式{‘键1’:’值1’,’键2’:’值2’…} {&#39;w&#39;:&#39;上&#39;,&#39;a&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;} ② 特性 键名不可以重复，若重复，后面的值会替换前面相同的键名；键名为不可变类型，可以为number、string、tuple类型。 ③ 操作字典 操作 功能 字典[键名] 访问字典中的某个元素值 {&#39;w&#39;:&#39;上&#39;,&#39;a&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[&#39;w&#39;] #访问得到上 {1:&#39;上&#39;,&#39;1&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[1] #显示上 {1:&#39;上&#39;,&#39;1&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[&#39;1&#39;] #显示左 变量变量命名规则 系统关键字不能用在变量名中。 Python中的变量名区分大小写。 变量名由字母，数字，下划线构成，开头不能是数字。 python中不存在变量的定义，变量本身没有类型，一般说把X赋值给变量，不说定义变量为X（动态性语言的特性体现） a = 1 a = &#39;1&#39; a = [1,2,3] 值类型和引用类型a = 1; b = a; a = 3; print(b) #b=1,b的值并没有改变 ********************************** a = [1,2,3] b = a a[0] = &#39;1&#39; print(a) #[&#39;1&#39;,2,3,4,5] print(b) #[&#39;1&#39;,2,3,4,5],此时b改变了 引用类型是可变的，值类型是不可变的 int str tuple值类型(不可改变) list set dict引用类型(可变) a = &#39;hello&#39; id(a) # a = a + &#39;python&#39; id(a) # ******a有不同的id，说明相加后得到的a是新的变量python****** &#39;python&#39;[0] #显示p &#39;python&#39;[0] = a #报错，值类型不可改变 列表和元组的对比元组定义好后就无法改变，列表可更改。 建议用元组 。避免合作开发过程中对方更改造成的报错。 a = (1,2,3,[1,2,4]) #如何访问4 a[3][2] a = (1,2,3,[1,2,[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]]) #访问c a[3][2][2] 运算符算术运算符python中算符运算符并不是只能对数字做运算 +加、-减、*乘、/除、//取整除、%取余、**幂 赋值运算符= +=、-=、*=、/=、//=、%=、**=注意：python中没有自增/自减运算符 c=1 c=c+1等效于c+=1 用法同其他语言 逻辑运算符and与、or或、 not非 主要操作布尔类型 非布尔类型参与运算的结果要根据计算机的运算流程判断 1 and 2 #返回2 ，计算机的运算流程，需要2才能给出结果 1 or 0 #返回1 到1即可给出结果 比较（关系）运算符== != &gt; &lt; &gt;= &lt;= 产生布尔值的运算结果 字符串、列表等均可进行比较 身份运算符 运算符 用法 功能 is 元素 is 序列 检测两个变量身份(内存地址)是否全等 not is 元素 not is 序列 检测两个变量身份(内存地址)是否不等 == 比较值，is 比较身份，类型 type判断 对象三个特征 id 、value、type ******is和==的区别******** a = 1 b = 1.0 a == b #true a is b #false ==比较值是否相等，is比较两个变量的身份（内存地址）是否相等 id(a)和id(b)不等 a = {1,2,3} b = {2,1,3} a == b #True 集合是无序的，所以不会影响最终取值 a is b #False 地址不同 ---------------- c = (1,2,3) d = (2,1,3) c == d #False 元组是序列，有序 c is d #False 内存地址不同 ---------------- 判断变量的类型 isinstance(a,str) #判断a是否是str类型 isinstance(a,(int,str,float)) #判断a是否是下面的三种类型之一 注意：python中没有===运算符 成员运算符 运算符 用法 功能 in 元素 in 序列 检测序列中是否包含指定元素 not in 元素 not in 序列 检测序列中是否不包含指定元素 注意：字典的成员运算符是针对键 b = &#39;c&#39; b in {&#39;c&#39;:1} #true 位运算符&amp;按位与 |按位与 ^按位异或 -按位取反 &lt;&lt; 左移动&gt;&gt;右移动 都是把数字当做二进制数进行运算 表达式运算符优先级 运算符 用法 { } 括号（分组） f(args…) 函数调用 x[index:index] 切片 x[index] 索引值 x.attribute 属性 ** 指数 ~x 取反 +x,-x 正、负值 *、/、% 乘、除、求余 +、- 加、减 &lt;&lt;、&gt;&gt; 左移、右移 &amp; 按位 AND ^ 按位 XOR \\ 按位 OR in、is、is not、&lt; 、&lt;=、&gt;、&gt;=、&lt;&gt;、!=、== 比较、算数、身份 not x 布尔 NOT and 布尔 AND or 布尔 OR lambda lambda 表达式 ******可以通过括号使先后顺序更清楚或强行改变顺序******** not a or b + 2 == c #(not a) or ((b+2) == c) a or b and c #a or (b and c) 语句python中语句不用括号，依据空格和换行分隔。 python没有switch 条件控制if 条件1: 语句 elif 条件2: 语句 else: 语句 pass空语句/占位语句，保持代码结构域的完整性 while循环while 条件： 语句 else: 语句 说明：在条件语句为 false 时，执行 else 的语句块 for循环# 第一种情况 #主要用来遍历/循环 for 元素 in 序列/集合/字典: 语句 else: 语句 # 第二种情况 for 变量 in range(范围): 语句 else: 语句 break跳出循环（内循环），continue停止当前操作，直接继续下面的循环 说明：在for语句遍历完毕时，执行 else 的语句块，并不要求强行使用elserange()的参数说明： range(x)：从0遍历到x，默认偏移量为1（遍历到x之前的数，取不到x,下同） range(x,y)：从x遍历到y，默认偏移量为1 range(x,y,z)：从x遍历到y，偏移量为z。若x&gt;y，则为递减，反之递增 a = [1,2,3,4,5,6,7,8] for i in range(1,len(a),2) print(a[i],end=&#39;|&#39;) *******等效于*********** b = a[0:len(a):2] print(b) 包、模块python项目的组织结构 Python包与模块的名字包的名字就是文件夹的名字，模块的名字就是文件的名字 不同包下两个同名的模块区分：包名.模块名 包下面可以包含子包 python如何区分一个普通的文件夹和包：在文件夹下面有一个特殊的文件_init_.py _init_.py这个模块的名字就是包名。 模块导入import模块导入的意义是引用别的模块的组织资源import module_name python导入一个模块时，会执行该模块的代码 语句 功能 import 模块 引入模块 from 包 import 模块/* 引入指定/全部模块 from 模块 import 部分/* 引入模块的指定/全部部分 说明：可以设置星号*所涵盖的内容，在被导入的文件中，设置__all__=[&#39;name1&#39;,&#39;name2&#39;...] import t.c7 #需要引用不同包（t包）下C7模块的a变量 print(t.c7.a) ****************** import c7 #需要同包下C7模块的a变量 print(c7.a) ****************** import t.t1.t2.c7 as m #如果命名空间过长，可以用m（自定义）代替命名，简化引用名 print(m.a) ************************************ from t.c7 import a print(a) #不需要加全部的命名空间 ****************** from t import c7 print(c7.a) ****************** from t.c7 import * #*引入全部部分或指定部分(在被导入的文件中，设置了`__all__=[&#39;name1&#39;,&#39;name2&#39;...]`) print(a) print(b) __init__.py 的用法Python杂谈: init.py的作用 包和模块是不会被重复导入的 避免循环导入（互相导入（形成环）对方的内容） 函数 功能性 隐藏细节 避免编写重复的代码 函数定义 def 函数名(参数列表): ... return 返回值1,返回值2.... 参数列表可以没有 若没写return，则返回None 若return返回多个值，则返回类型为元组 推荐使用变量1,变量2...=函数()的形式获取返回值（序列解包），不推荐使用元组[索引]获取，会降低代码可读性 序列解包a = 1 b = 2 c = 3 #等价于 a,b,c = 1,2,3 d = 1,2,3 #d是tuple类型 a,b,c = d #序列解包。需要注意的是元素的个数要相等 函数参数 类型 格式 说明 必须参数 调用时函数(实参) 形参和实参顺序要求一致 关键字参数 调用时函数(形参=实参) 形参和实参顺序可以不一致 默认参数 函数定义时def 函数名(形参=值) 实参可覆盖默认参数。注意：默认参数需写在形参列表的最后 def add(x, y): #x,y是形参 ······ add(3,2) #3,2是实参 x=3,y=2 add(y=3,x=2) #关键字参数 内置函数 函数 功能 len() 返回元素个数 id() 查看变量内存地址 type() 类型判断 isinstance(变量名,(类型1，类型2..)) 变量是否属于其中的一个类型 input([‘提示语’]) 接收用户输入的信息，返回为 string 类型 round(数值,保留位数) 四舍五入 字符串.index(子串,起始位置,结束位置) 返回开始的索引值，没找到则抛出异常。 主串.replace(‘旧子串’,’新子串’,匹配次数) 替换 字典.get(键名, 默认值) 返回指定键的值，如果不存在则返回默认值 其他 None不是False、&#39;&#39;、0、[]，尤其在判空时需要注意 对象存在不代表其一定为True，对象的bool值由__bool__或__len__内置函数决定 使用\\或()可实现跨行书写 讲解面向对象的概念。包括面向对象的三大特性（继承、封装、多态）、类的基本构成元素、python的内置类属性、方法重写、运算符重载、静态方法等 类的定义class 类名: #类命名建议第一个字母大写，驼峰命名 pass class Student(): name = &#39;&#39; age = 0 def print_file(self): #加固定的参数self，否则会报错,后面会解释 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) 类实例化对象名=类名([实参]) # 形参写在类的构造函数中 演示（在另外一个模块中引用类）： from c1 import Student student1 = Student() #类的实例化 student1.print_file() #调用类下面的方法 note:类的基本作用是封装代码。 方法要加参数self,访问实例变量方式是self.变量 类内部只做定义，不推荐在类内部实例化和调用方法 类中的变量称谓数据成员 方法：设计层面来讲 函数：程序运行，过程式的一种称谓 变量： 变量 访问 实例变量 通过self.变量名访问 类变量 通过cls.变量访问 如果在实例化对象中找不到变量，则会去相应的类中寻找，若也没有，则去所在类的父类中寻找… 在构造函数内，直接通过变量名访问的是形参，而非实例对象。 类与对象类的定义 类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起 对象的定义 对象是实例化的类 构造函数def __init__(self): #构造函数 pass 作用:生成不同的对象 构造函数__init__在实例化类时，将自动调用 构造函数是个实例方法 构造函数只能返回None 对象的参数由构造函数接收，构造函数的第一个参数为self 在构造函数内部，通常初始化类的特征值 class Student(): name = &#39;&#39; age = 0 def __init__(self,name,age): #构造函数 #初始化对象的属性 name = name #wrong age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 #行为与特征 def print_file(self): #加固定的参数，否则会报错 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) student1 = Student(&#39;石敢当&#39;，18) print(student1.name) #这里输出结果是空值，说明构造函数里的赋值并没有改变变量name的取值 释疑： student1 = Student(&#39;石敢当&#39;，18) #print(student1.name) print(student1.__dict__) #__dict__作用保存对象下的所有变量 #输出结果是空子典{}，说明不存在实例变量 类变量和实例变量实例变量和对象相关联。 class Student(): name = &#39;yuyu&#39; #类变量 age = 0 def __init__(self,name,age): #注意是两条下划线 #构造函数 #初始化对象的属性 self.name = name #定义实例变量，和对象相关，与类无关 self.age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 print(self.name) #实例对象的name student1 = Student(&#39;yanglin&#39;, 18) student2 = Student(&#39;yu&#39;, 20) print(student1.name) #此时输出正确结果 yanglin print(student2.name) #yu print(Student.name) #yuyu 类与对象的变量查找顺序 机制：访问一个实例变量，先在对象的实例列表里查找有没有该变量，没有则会去相应的类中寻找，若也没有，则去类的父类中查找…… self与实例方法定义实例方法时，需要参数,调用实例方法时，不需要传参 def __init__(self,name,age): #self可以自己更改，python中建议使用self #构造方法 #初始化对象的属性 self.name = name self.age = age #行为与特征 def print_file(self): #加固定的参数，否则会报错 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) self就是当前调用方法的对象,self代表的是实例不是类 如：sutdent1.print_file() self代表student1 实例方法 # 定义 def funcname(self): pass # 调用 实例.方法() 在实例方法中访问实例变量与类变量方法代表类的行为，变量代表刻画类的特征。方法需要对变量对运算和逻辑上的操作，改变类的特征。 实例方法操作实例变量 self.变量名访问 def __init__(self,name,age): #注意是两条下划线 #构造函数 #初始化对象的属性 self.name = name #定义实例变量，和对象相关，与类无关 self.age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 print(self.name) #实例对象的name 实例方法访问类变量： class Student(): total = 0 def __init__(self): #注意是两条下划线 print(total) #访问错误 ******正确访问类变量的方式1******* print(Student.total) #访问成功 ******正确访问类变量的方式2******* print(self.__class__.total) #访问成功 类方法下面是实例方法改变类变量的例子 class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.__class__.sum += 1 print(&quot;当前班级学生总数为：&quot;+ str(self.__class__.sum)) #每当创建一个学生对象，班级学生总数加一 student1 = Student(&quot;yu&quot;, 18) student2 = Student(&quot;yu1&quot;, 18) student3 = Student(&quot;yu2&quot;, 18) print(Student.sum) 类方法的定义： @classmethod def plus_sum(cls): pass # 调用 类.方法() 上述方法用类方法操作改进: class Student(): sum = 0 name = &#39;&#39; age = 0 def __init__(self, name, age): self.name = name self.age = age @classmethod #类方法 def plus_sum(cls): cls.sum += 1 print(cls.sum) student1 = Student(&quot;yu&quot;, 18) Student.plus_sum() student2 = Student(&quot;yu1&quot;, 18) Student.plus_sum() student3 = Student(&quot;yu2&quot;, 18) Student.plus_sum() 类方法和实例方法的区别：关联的对象不同，一个是类，一个是对象 类方法不能访问实例变量 静态方法 @staticmethod def funcname(parameter_list): pass # 调用 类.方法()或实例.方法() 静态方法可以被对象和类调用 静态方法的内部可以访问类变量 静态方法不能访问实例变量 建议不要经常使用静态方法，和普通的函数基本没有区别 和C#，java中的静态方法有区别 成员可见性：公开与私有 在变量或方法名前加__，则变为私有 细节理解：在创建私有的实例变量时，实际python会把变量名改为_类名__变量名，所以在外部访问私有变量__变量名时，实际是创建了新变量__变量名。但是通过_类名__变量名可以修改和访问！ 建议：对类变量，建议不要直接修改，而是通过方法来修改，这样有利于保护变量 内建属性 内建属性 说明 __class__ 表示实例所在的类 __dict__ 查看类或实例的自定义属性 继承继承from 文件 import 父类 # 子类的定义 class 子类(父类): pass 建议：一个文件夹只写一个类，那么只需在子类文件上写from 文件 import 父类* 多继承：一个子类继承多个父类。python支持多继承 调用父类构造函数 父类： class Human(): sum = 0 def __init__(self, name, age): self.name = name self.age = age def get_name(self): print(self.name) 子类： from c2 import Human class Student(Human): def __init__(self, school, name, age): #注意：这里包含了子类形参和父类形参 self.school = school #self.子类变量=值 # Human.__init__(self, name, age) #子类构造函数中调用父类的构造函数 #父类.__init__(self[,父类形参]) # 注意：这里包含了父类的self及父类形参 #为什么要传self: #上面语句是一个类调用一个实例方法(不合规的)。对象实例化中调用构造函数时，python会自己 #帮我们补全，而普通方法的调用，需要传去全部的参数 super(Student,self).__init__(name,age) #推荐使用 student1 = Student(&#39;china&#39;,&#39;yuyu&#39;, 18) print(student1.name) print(student1.age) print(student1.sum) print(Student.sum) student1.get_name() 细节理解：为什么在上述代码中，父类的构造函数调用需要写self形参，但是实例化父类时，参数中却不需要写self？原因：实例化父类过程中，对于self的指向，会由python帮我们自动完成。而上述代码，并没有实例化父类，python不会帮我们自动完成，而需要我们显式地写出self。 推荐 class 子类(父类): def __init__(self[,子类及父类形参]): self.子类成员变量=值 super(子类,self).__init__(父类形参) 父子方法同名问题若父类和子类具有同名的实例方法，则在调用的是子类的。如果想调用父类同名实例方法，需要在定义子类方法时，加上super(子类,self).方法() 正则表达式也是文本解析中非常重要的知识点。本章我们将讲解什如何在Python中编写正则表达式与常见的正则表达式。此外，JSON作为非常重要的数据格式，我们会重点讲解，包括JSON对象，JSON字符串，Python类型与JSON的转换。 正则表达式初识正则表达式是一个特殊的字符序列，检测一个字符串是否与我们所设定的这样的字符序列相匹配。如果匹配，帮助我们快速检索文本，实现一些替换文本的操作。可以用正则表达式来1.检测一串数字是否是电话号码2.检测一个字符串是都符合email3.把一个文本里指定的单词替换为另一个单词等等 例：判断A中是否含python A = &#39;C|C++|Java|Python|Javascript&#39; #我们可以采用python中的内置函数,优先考虑内置函数 print(A.index(&#39;Python&#39;)&gt;-1) #True print(&#39;Python&#39; in A) #True 采用正则表达式 import re A = &#39;C|C++|Java|Python|Javascript&#39; #re.findall(&#39;正则表达式&#39;, A) #A是要匹配的字符串 r = re.findall(&#39;Python&#39;, A) #A是要匹配的字符串,r是列表 #print(r) #返回结果是一个列表 if len(r) &gt; 0 print(&#39;字符串中包含Python&#39;) 元字符与普通字符普通字符：正常文本字符，如上例中的’python’ 元字符：在正则表达式中具有特殊意义的专用字符,如‘\\d’。 示例： #找出A中的所有数字 import re A = &#39;C0C++34Java5Python56Javascript&#39; r = re.findall(&#39;\\d&#39;, A) #A是要匹配的字符串 print(r) #返回结果是一个列表 正则表达式全集 字符集#找出中间字母是c到f的单词 import re S = &#39;abc,acc,adc,aec,afc,ahc&#39; r = re.findall(&#39;a[c-f]c&#39;, S) #A是要匹配的字符串 print(r) #返回结果是一个列表 字符 含义 [] 或 () 分组，且 [^] 非 ^ 开头 $ 结尾 [a-b] 数字或字母范围 概括字符集 字符 含义 . 除换行之外的所有字符 \\d 数字 \\D 非数字 \\s 空白字符 \\S 非空白字符 \\w 下划线、字母、数字 \\W 非下划线、字母、数字 \\w即[0-9A-Za-z_]，\\W匹配任何非单词字符。等价于[^A-Za-z0-9_]。概括字符集表述更加简洁 数量词import re S = &#39;python 1111java6784php&#39; #提取3个单词 #r = re.findall(&#39;[a-z]{3}&#39;, S) #匹配a-z的数量是固定的3个 r = re.findall(&#39;[a-z]{3,6}&#39;, S) print(r) #返回结果是一个列表，[&#39;python&#39;, &#39;java&#39;, &#39;php&#39;] #问题：为什么匹配到3字符的时候不输出pyt,而是到python? #解：贪婪 贪婪与非贪婪数量词有贪婪和非贪婪之分，默认情况下是贪婪的方式 贪婪：数量词限定在一个区间之内，python倾向于尽可能多的取最大的值，一直到某个字符不满足条件时停止 非贪婪：[a-z]{3,6}? 匹配0次1次或者无限多次import re S = &#39;pytho1python6pythonn&#39; #*匹配0次或者无限多次 [&#39;pytho&#39;, &#39;python&#39;, &#39;pythonn&#39;] #+匹配1次或者无限多次 [&#39;python&#39;, &#39;pythonn&#39;] #？匹配0次或者1次 [&#39;pytho&#39;, &#39;python&#39;, &#39;python&#39;] 会把正确的匹配结果纳入（可用来去重） r = re.findall(&#39;python*&#39;, S) print(r) #返回结果是一个列表 字符 含义 {a,b} 指定前一个字符的出现次数(贪婪) * 前面的一个字符出现0到n次 + 前面的一个字符出现1到n次 ? 前面的一个字符出现0到1次 边界匹配符^ $ import re qq = &#39;10000013332&#39; #要求qq在4-8位 r = re.findall(&#39;^\\d{4,8}$&#39;, qq) #^从字符串的开始匹配，$从字符串的末尾开始匹配 print(r) #返回结果是一个列表 组import re A = &#39;PythonPythonPythonPythonPython&#39; #要求判断字符串里是否包含3个python r = re.findall(&#39;(Python){3}&#39;, A) #括号括起来成为组，一组的字符重复3次 print(r) #返回结果是一个列表 [abc]或关系，（ABC）组关系 匹配模式参数r = re.findall(&#39;正则表达式&#39;, 字符串，模式1|模式2)多个模式用|连在一起 匹配 findall 格式：re.findall(子串,主串[,模式|模式2...])功能：匹配返回：以列表形式，返回匹配到的子串说明：模式中\\|表示且 字符 含义 re.I 忽视大小写 re.S 使 . 匹配包括换行在内的所有字符，改变.号的行为 re模块下的其他正则表达式re.sub格式：re.sub(原内容，新内容/函数，主串，替换次数)功能：替换返回：返回新的主串说明：替换次数为0表全体换，为n表示替换n个 #示例 import re language = &#39;PythonC#JavaPHPC#&#39; r = re.sub(&#39;C#&#39;,&#39;Go&#39;,language,1) print(r) #PythonGoJavaPHPC# 进阶： 动态替换，根据不同的匹配结果进行不同的替换 返回的第一个C#之前有6个字符，自己占7,8 import re def convert(value): #print(value) matched = value.group() return &#39;!!&#39; + matched + &#39;!!&#39; language = &#39;PythonC#JavaPHPC#&#39; r = re.sub(&#39;C#&#39;,convert,language) print(r) #Python!!C#!!JavaPHP!!C#!! 把函数作为参数传递的作用import re a = &#39;A8C3721D86&#39; #找出所有数字，&gt;=6的统一替换成9,&lt;6替换成0 def convert(value): matched = value.group() if int(matched) &gt;= 6: #默认字符串形式存储 return &#39;9&#39; else: return &#39;0&#39; r = re.sub(&#39;\\d&#39;, convert, a) print(r) # A9C0900D99 search与match函数match、search、findall用法区别 match 格式：re.match(子串,主串)功能：匹配（仅匹配一个）说明：从首字符开始匹配，若没找到对应的结果返回空,若想获取返回Match对象转为值，则用group()方法 search 格式：re.search(子串,主串)功能：匹配到一个结果（仅匹配一个），就返回结果.若想获取返回Match对象转为值，则用group()方法 match、search的比较示例代码： import re a = &#39;A8C3721D86&#39; r1 = re.match(&#39;\\d&#39;, a) print(r1) r2 = re.search(&#39;\\d&#39;, a) print(r2) # 输出结果 None &lt;re.Match object; span=(1, 2), match=&#39;8&#39;&gt; match、search、findall的比较示例代码： import re a = &#39;8C3721D86&#39; r1 = re.match(&#39;\\d&#39;, a) print(r1) r2 = re.search(&#39;\\d&#39;, a) print(r2) r3 = re.findall(&#39;\\d&#39;, a) print(r3) # 输出结果 &lt;re.Match object; span=(0, 1), match=&#39;8&#39;&gt; &lt;re.Match object; span=(0, 1), match=&#39;8&#39;&gt; [&#39;8&#39;, &#39;3&#39;, &#39;7&#39;, &#39;2&#39;, &#39;1&#39;, &#39;8&#39;, &#39;6&#39;] group分组 函数 功能 .group() 用来提取出分组截获的字符串 .span() 返回匹配到的子串在主串中的位置 import re s = &#39;life is short,i use python&#39; r = re.search(&#39;life(.*)python&#39;,s) print(r.group(1)) #获取分组的匹配 #0永远记录正则表达式的完整匹配结果 用findall import re s = &#39;life is short,i use python&#39; r = re.findall(&#39;life(.*)python&#39;,s) print(r) #获取分组的匹配 理解JSONJavaScript Object Notation JavaScript对象标记 JSON是一种轻量级的数据交换格式。 JSON载体：JSON字符串，字符串是json的表现形式 JSON优势：易于阅读、易于解析、网络传输效率高，适合跨语言交换数据 JSON字符串：是指符合JSON格式的字符串 注意：JSON中只能使用双引号，轻量相对于xml而言，符合JSON格式的字符串叫做JSON字符串 json是一种数据格式，适合跨语言交换数据 反序列化和序列化由字符串到语言下的某一数据结构叫反序列化 python字典转化为字符串 JSON函数 函数 功能 json.loads(json字符串) 反序列化，JSON字符串转Python对象 json.dumps(python对象) 序列化，Python对象转JSON字符串 JSON与Python类型的对照 JSON Python object dict array list string str number(int) int number(real) float true True flase False null None #反序列化 import json json_str = &#39;{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39; #数字不用加引号 #json有很多数据类型，如数组&#39;[{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18，“},{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}]&#39; #把json字符串转换成python自己的数据类型(字典) student = json.loads(json_str) print(type(student)) #dict字典类型 print(student) print(student[&quot;name&quot;]) print(student[&quot;age&quot;]) ******************** json_str = &#39;[{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39;,{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39;] #序列化 import json student = [ {&#39;name&#39;:&#39;qiyue&#39;, &#39;age&#39;:18 ,&#39;flag&#39;:False}, {&#39;name&#39;:&#39;qiyue&#39;, &#39;age&#39;:18} ] #把json字符串转换成对应的python结构(字典) json_str = json.dumps(student) print(type(json_str)) print(json_str) JSON对象，JSON，JSON字符串？ JSON对象在JavaScript中概念成立 JSON有自己的数据类型，虽然它和JavaScript的数据类型有些相似 REST服务的标准格式：JSON 本章节我们揭开Python进阶部分的高级特性，详细讲解枚举、闭包，并对函数式编程做出介绍 枚举枚举是一个类from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 print(VIP.YELLOW) #VIP.YELLOW 打印出的是名字，类型是enum VIP VIP.YELLOW = 6 #会报错 ，不可更改 for v in VIP #for v in VIP.__members__: 把标签的别名也遍历得到 print(v) #枚举的遍历 枚举和普通类相比的优势 如果没有枚举类,在模块中通过变量表示枚举类型 yellow = 1 #法一 green = 2 {&#39;yellow&#39;:1,&#39;green:2&#39;} #法二 class TypeDiamond(): #法三 yellow = 1 green = 2 字典和类都是可变的。没有防止相同值的功能 枚举类型、枚举名称与枚举值print(VIP.YELLOW.value)获取枚举值 #6 print(VIP.YELLOW.name) 获取枚举名字 #YELLOW print(VIP[&#39;GREEN&#39;]) 获取枚举类型 #VIP.GREEN 枚举 比较运算from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 result = VIP.GREEN == VIP.BLACK #False result = VIP.GREEN == 2 #虽然不报错，但显示False 枚举类型直接不能做大小比较 枚举注意事项 其标签值不可修改 其不允许相同标签 其标签不支持大于小于比较符 其若有多个标签是同值的，则后续的都看做第一个标签的别名。在遍历枚举类时，别名不会被打印出来 其不允许实例化 @unique 装饰器，则不允许标签同值 枚举转换数据库中存储枚举类型最好采用值（数字） 代码中不建议用数值，建议用枚举类if a == VIP.YELLOW from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 把数字转为枚举数据类型 a = 1 print(VIP(a)) from enum import Enum, unique # 如果枚举类继承的是IntEnum，则标签值只允许为int类型 from enum import IntEnum # @unique 加上这个，则不允许标签同值 class VIP(Enum): Yellow = 1 Yellow_ALIAS = 1 # Yellow = 2 # 报错，枚举类不允许相同标签 Green = 2 Black = 3 class VIP1(Enum): Yellow = 1 Yellow_ALIAS = 1 Green = 2 Black = 3 class Common: Yellow = 1 Black = 3 Red = 4 print(&#39;-------枚举类型及值-------&#39;) print(VIP.Yellow) print(VIP[&#39;Yellow&#39;]) print(VIP.Yellow.name) print(type(VIP.Yellow)) print(type(VIP[&#39;Yellow&#39;])) print(type(VIP.Yellow.name)) print(&#39;-------枚举类型与普通类对比-------&#39;) print(VIP.Yellow.value) print(Common.Yellow) Common.Yellow = 2 # VIP.Yellow=2 # 报错，枚举类不可修改 # 遍历枚举类——Yellow_ALIAS不会被打印 print(&#39;-------for v in VIP-------&#39;) for v in VIP: print(v) # Yellow_ALIAS会被打印 print(&#39;-------for v in VIP.__members__-------&#39;) for v in VIP.__members__: print(v) print(&#39;-------for v in VIP.__members__.items()-------&#39;) for v in VIP.__members__.items(): print(v) print(&#39;-------成员变量的别名及比较运算符-------&#39;) print(VIP.Yellow_ALIAS) print(VIP.Yellow is VIP.Yellow_ALIAS) print(VIP.Yellow == VIP.Yellow_ALIAS) print(VIP.Yellow == VIP1.Yellow_ALIAS) # print(VIP.Yellow&lt;VIP.Black) # 报错，枚举类不支持大于小于运算符 print(&#39;-------枚举转换-------&#39;) a = 1 print(VIP(a)) # 输出结果 -------枚举类型及值------- VIP.Yellow VIP.Yellow Yellow &lt;enum &#39;VIP&#39;&gt; &lt;enum &#39;VIP&#39;&gt; &lt;class &#39;str&#39;&gt; -------枚举类型与普通类对比------- 1 1 -------for v in VIP------- VIP.Yellow VIP.Green VIP.Black -------for v in VIP.__members__------- Yellow Yellow_ALIAS Green Black -------for v in VIP.__members__.items()------- (&#39;Yellow&#39;, &lt;VIP.Yellow: 1&gt;) (&#39;Yellow_ALIAS&#39;, &lt;VIP.Yellow: 1&gt;) (&#39;Green&#39;, &lt;VIP.Green: 2&gt;) (&#39;Black&#39;, &lt;VIP.Black: 3&gt;) -------成员变量的别名及比较运算符------- VIP.Yellow True True False -------枚举转换------- VIP.Yellow 扩展： from enum import IntEnum，unique #强制要求值是数字,限制值不能相同 加强设计模式的学习,进阶学习 闭包函数：其他语言中，函数只是一段可执行的代码，并不是对象，不能实例化。 在python中，一切皆对象。可以把函数赋给一个变量，可以把一个函数当做另一个函数的参数 示例： def curve_pre(): #调用curve_pre函数，拿到的是一个函数结果 a = 25 def curve(x): return a*x*x return curve #把curve函数作为结果返回给curve_pre f = curve_pre() print(f(2)) #100 def curve_pre(): #调用curve_pre函数，拿到的是一个函数结果 a = 25 def curve(x): return a*x*x return curve #把curve函数作为结果返回给curve_pre实际是返回了闭包 a = 10 f = curve_pre() print(f(2)) #100 没有取a=10来运算（闭包的取值） 闭包定义 闭包 = 函数 + 环境变量 （环境变量必须函数定义时的外部变量，且不为全局变量） 闭包的意义：把函数调用的现场保护起来了，不受外部变量的影响 闭包的经典误区def f1(): a = 10 def f2(): a = 20 #a被ptython认为是一个局部变量，此时并不引用外面的环境变量，因此不是闭包 print(a) #20 print(a) #10 第一次打印 f2() #执行f2,a=20 print(a) #10内部的a(局部变量)不会影响外部的a f1() #1.执行 f1,开始调用f1函数 结论：如果没有在函数中引用全局变量，或者仅引用局部变量，都不会形成闭包 练习： 编写函数，得到旅行者的位置（关键需要保存上一次函数调用的结果状态） 非闭包方法 代码质量不高，在函数内部定义全局变量，代码自封性不强（因为可能其他代码段也会改变全局变量） #编写函数，得到旅行者的位置 #关键需要保存上一次函数调用的结果状态 origin = 0 def go(step): global origin #声明origin是全局变量 new_pos = origin + step origin = new_pos #python认为等号左边origin此时是局部变量，是存在的， #不会在外面引用,解决方法：增加global origin return new_pos print(go(2)) print(go(3)) print(go(6)) 闭包方法： origin = 0 #这是工厂模式 def factory(pos): #参数是当前旅行者正处于的位置,pos是环境变量，有保存现场功能 def go(step): nonlocal pos #强制让pos不是局部变量 new_pos = pos +step pos = new_pos #pos此时会认为是局部变量 return new_pos return go tourist = factory(origin) print(tourist(2)) print(tourist(3)) print(tourist(5)) 函数式编程本章节进一步介绍函数式编程的lambda、mapeduce、filter以及装饰器 匿名函数：lambda表达式 def add(x, y): return x+y ---------用匿名函数实现-------------- #lambda parameter_list: expression #不能再表达式中用代码块（如赋值语句等） f = lambda x,y: x+y f(1,2) #匿名函数的调用 --------配合正则表达式使用会更方便------ 三元表达式其他语言：a &gt; y ? x : y 判断条件？结果1：结果2 python:条件为真时返回的结果 if 条件判断 else 条件为假时返回的结果 x if x&gt;y else y map闭包不建议在业务代码使用，在架构编写方面可以推荐。 map推荐在python中多使用 list_x = [1,2,3,4,5,6,7,8] def square(x): return x*x -------使用for循环------ for x in list_x: square(x) --------使用map------ r = map(square,list_x) print(r) #map对象 print(list(r)) map函数映射，把原来集合元素通过函数关系映射到另一个集合。 --------使用map和lambda精简-------- r = map(lambda x: x*x,list_x) #map多参数的传入， #x,y参数个数要相等，否则结果有缺失 list_x = [1,2,3,4,5,6,7,8] list_y = [1,2,3,4,5,6,7,8] r = map(lambda x,y: x*x+y,list_x,list_y) reducefrom functools import reduce #连续计算，连续调用lambda 每一次lamnda的计算结果将作为下一次表达式的参数作为运算，直至遍历结果 list_x = [1,2,3,4,5,6,7,8] r = reduce(lambda x,y: x+y,list_x) print(r) 1+2 3（上一次表达式的结果）+3 6+4 ((((1+2)+3)+4)+5) ... lambda是联系计算，计算操作表达式内定义 扩展：大数据计算模型（map/reduce） 映射 规约 并行计算 filter#filter list_x = [1, 0, 1, 0, 0, 1] r = filter(lambda x:True if x == 1 else False, list_x) print(list(r)) 命令式编程vs函数式编程命令式编程关键点： def if else for 函数式编程： map reduce filter lambda算子 lisp 函数式编程的鼻祖 装饰器import time def f1(): print(time.time()) #结果是unix时间戳，1591168510.2112603 print(&#39;This is a function&#39;) #如果有100个函数，都需要自带打印时间的功能。 #原则：当需求产生变更的时候，尽量不改变函数、对象或类下面的具体实现 #对修改是封闭的，对扩展是开放的 f1() 解决方案： import time def f1(): print(&#39;This is a function&#39;) #如果有100个函数，都需要自带打印时间的功能。 #原则：当需求产生变更的时候，尽量不改变函数、对象或类下面的具体实现 #对修改是封闭的，对扩展是开放的 def f2(): print(&#39;This is a function&#39;) def print_current_time(func): print(time.time()) func() print_current_time(f1) print_current_time(f2) 上述缺点：新增的功能是属于每个函数的，最好能和原来的函数绑定 改进： import time #装饰器结构 def decorator(func): def wrapper(): print(time.time()) func() return wrapper def f1(): print(&#39;this is a function&#39;) f = decorator(f1) #改变了调用方式 f() 改进： import time #装饰器结构 def decorator(func): def wrapper(): print(time.time()) func() return wrapper @decorator #语法糖，不改变原来的调用方式 def f1(): print(&#39;this is a function&#39;) f1() #不改变原来的调用方式 体现了AOP的设计思想 支持不同参数： import time #装饰器结构 def decorator(func): def wrapper(*args): #支持不同参数的个数 print(time.time()) func(*args) return wrapper @decorator #不改变原来的调用方式 def f1(func_name): print(&#39;this is a function&#39;+func_name) @decorator #不改变原来的调用方式 def f2(func_name1,func_name2): print(&#39;this is a function&#39;+func_name1) f1(&#39;test func&#39;) f2(&#39;test func1&#39;,&#39;test func2&#39;)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"SOURCETREE 3.1.3 版本跳过BITBUCKET注册方法（亲测好用）","slug":"SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）","date":"2020-05-21T14:25:21.000Z","updated":"2020-05-21T14:34:00.962Z","comments":true,"path":"2020/05/21/SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）/","link":"","permalink":"/2020/05/21/SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）/","excerpt":"","text":"1.首先下载并安装好git程序。 2.接着下载并执行SourceTreeSetup-3.1.3.exe，会进入登录或注册bitbucket的界面，我只是想用软件，并不想去注册账号。怎么办？请往下看。 3.打开 %LocalAppData%\\Atlassian目录，接着进入SourceTree目录，创建accounts.json文件，并修改accounts.json内容如下： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot;&quot;, &quot;Email&quot;: null }, &quot;IsDefault&quot;: false } ] 4.打开 %LocalAppData%\\Atlassian，进入“SourceTree.exe_Url_iayhtc13zv3obzuz5vchezjs1az2q5ef”（注该目录可能和版本相关，不同版本的路径可能不完全一样。） 接着进入”3.1.3.3158“目录，打开user.config文件，在里面加入六行代码。 &lt;setting name=&quot;AgreedToEULA&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;True&lt;/value&gt; &lt;/setting&gt; &lt;setting name=&quot;AgreedToEULAVersion&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;20160201&lt;/value&gt; &lt;/setting&gt; 5.再次执行SourceTreeSetup-3.1.3.exe，即可跳过注册，完成安装。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"git教程","slug":"git教程","date":"2020-05-21T11:44:51.000Z","updated":"2020-06-12T05:26:39.082Z","comments":true,"path":"2020/05/21/git教程/","link":"","permalink":"/2020/05/21/git教程/","excerpt":"","text":"Git简介Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是Linus Torvalds为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是现在很多其他自由软件项目中也使用了 Git。 SVN与Git的区别SVN是集中式版本控制系统，版本库集中放在中央服务器，干活的时候，用的都是自己的电脑，所以首先要从中央服务器那里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 Windows 平台上安装下载打开Git 官网 ，点击自己需要的版本，按照提示根据自己电脑系统版本下载相应Git,Mysysgitt是 windows版的Git。 安装打开下载好的Git安装包后，一直点击Next，保持默认选项，直到出现Install，点击Install，安装完成后点击Finish 使用安装好后，在电脑桌面或者打开某一本地磁盘，在空白位置右击鼠标会发现多了两个选项Git GUI Here和Git Bash Here，如图所示，点击Git Bash Here即可从当前位置打开并使用使用Git。 自己遇到的问题：git bash/gui here找不到应用程序 由于移动过git的安装目录，因此选择git bash here 时windows无法访问指定设备路径或文件报错解决办法：https://blog.csdn.net/weixin_39643135/article/details/79440222 配置Git环境1.打开GitHub官网，注册一个账号，注册好后，双击桌面上的Git Bash快捷图标，进行环境配置。 2.配置用户名git config --global user.name &quot;username&quot; ##username是自己的账户名，global表示所有仓库都会使用这种配置，可针对某个仓库进行配置 3.配置邮箱git config --global user.email &quot;username@email.com&quot; ##username@email.com注册账号时用的邮箱 因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。注意：git config —global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。 4.命令查看之前的配置是否成功 键入git config --global --list 5.生成ssh秘钥 键入ssh-keygen -t rsa生成ssh，连敲三次回车键，结束后去系统盘目录下（一般在 C:\\用户\\当前用户\\ .ssh）查看是否生成 .ssh 文件夹，此文件夹中包含以下两个文件：id_rsa、id_rsa.pub ssh-keygen -t rsa -C &quot;你的邮箱&quot; #邮箱是github的注册邮箱 Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 6.在 GitHub 账户中添加你的公钥 运行下面命令，将公钥的内容复制到剪切板clip &lt; ~/.ssh/id_rsa.pub 打开【github】—-【settings】—-【SSH and GPG keys】—-【new ssh key】—-【把内容粘到key区域】—-【add SSH key】 7.测试配置是否成功 在Git Bash命令框中键入ssh -T git@github.com命令，回车后若出现下面情况，则说明环境配置成功。(连网状态下) $ ssh -T git@github.com Hi sunshine98yy! You&#39;ve successfully authenticated, but GitHub does not provide shell access. git的图形化界面操作软件选择sourcetree作为git的图形化操作软件，可以根据自己的需要选择不同的图形化操作软件。 安装过程很简单。本人安装完后碰到需要注册的问题，由于是外国网站，访问可能会有问题，提供下面绕过注册的方法。 SOURCETREE 3.1.3 版本跳过BITBUCKET注册方法（亲测好用）) git操作创建版本库版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 下面演示创建本地版本库，提交文件到本地版本库 示例在【D盘】 下新建一个demo1版本库，创建demo1文件夹，文件夹为空。 1.通过命令 git init 把这个目录变成git可以管理的仓库这时候你当前demo1目录下会多了一个.git的目录（.表示此文件隐藏），这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。 2.把文件添加到版本库中。在版本库中新建test.txt文件，文件内容git repo1。 echo &quot;git repo1&quot; &gt;&gt; test.txt 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 ​ 第一步：使用命令 git add readme.txt添加到暂存区里面去。git add test.txt ​ 第二步：用命令 git commit告诉Git，把文件提交到仓库。git commit -m &quot;repo1 first commit&quot; git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；1 insertions：插入了一行内容（readme.txt有一行内容）。 现在我们已经提交了一个test.txt文件，我们下面可以通过命令git status来查看是否还有文件未提交。显示working tree clean ,说明没有任何文件未提交。 现在继续来改下test.txt内容，比如我在下面添加一行change内容，继续使用git status来查看下结果，如下： git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交修改。 查看test.txt文件改了什么内容？可以使用命令git diff test.txt： 如上可以看到，test.txt文件内容从一行git repo改成 二行 添加了一行change内容。知道了对test.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。 小结初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add，注意，可反复多次使用，添加多个文件； 使用命令git commit -m，完成。 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退你已经学会了修改文件，然后把修改提交到Git版本库，现在我继续对test.txt文件进行修改，再增加一行内容为second change，并提交到本地仓库。 示例现在我已经对test.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？ 使用命令git log ，命令显示从最近到最远的提交日志。我们也可以使用命令 git log --pretty=oneline来精简显示信息 注：commit id（版本号）需要用这么一大串数字？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，可以使用如下命令： git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可。 文本中的内容会回退到对应版本的内容。此时git log显示的最新的版本是回退的版本。后面新的版本不会显示。如下图，最新的second add 不会显示 此时我又想回退到最新的版本second add。内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：git reset —hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者second add内容的版本号我并不知道呢？要如何知道增加second add内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下： 通过上面的显示我们可以知道，增加内容second add的版本号是 b65c2d7。我们现在可以命令git reset --hard b65c2d7来恢复了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是改变了HEAD的指向。 小结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区与暂存区工作区(Working Directory)工作区：就是你在电脑上看到的目录，比如目录下demo1里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)工作区有一个隐藏目录.git,这个不属于工作区，这是git的版本库。 版本库里面存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步：第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 管理修改Git跟踪并管理的是修改，而非文件。 如果我们的操作流程是第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit，会发现第二次的修改没有被提交 Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 撤销修改情景一工作区做了改动并添加到暂存区，未提交，此时需要恢复到改动前的版本: 一：如果知道要删掉哪那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 二：用命令git reset HEAD可以把暂存区的修改撤销掉（unstage），重新放回工作区，丢弃工作区的修改。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 情景二只是工作区做了改动，此时需要恢复到改动前的版本： git checkout -- file 可以丢弃工作区的修改，如下命令：git checkout -- test.txt, 把test.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：1.test.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。2.另外一种是test.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。对于第二种情况，我想我们继续做demo来看下，假如现在我对test.txt添加一行 内容为1111，我git add 增加到暂存区后，接着添加内容2222，我想通过撤销命令让其回到暂存区后的状态。如下所示： 注意：命令git checkout — test.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。 情景三现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？使用版本回退可以回退到上一个版本，git reset --hard HEAD^ 。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。 删除文件在版本库demo1目录添加一个文件b.txt,提交,然后直接在文件管理器中把没用的文件删了，或者用rm命令删除 git add b.txt git commit -m &#39;添加b.txt文件&#39; rm b.txt #可以直接在目录下删除b.txt文件或者使用命令rm b.txt 执行完上述步骤后，此时有两个选择: 1.彻底从版本库中删掉此文件，那就用命令git rm删掉，并且git commit $ git rm b.txt rm &#39;test.txt&#39; $ git commit -m &quot;remove test.txt&quot; [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 2.删错了,想在版本库中恢复此文件，使用命令git checkout -- b.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 远程仓库目前使用的git命令都是在本地执行，如果想通过git分享我们的代码，或者想与其他开发人员合作，就需要将数据放到一台其他人员能连接的服务器上。 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要先设置SSH。 添加远程仓库我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以让其他人通过该仓库来协作。 新建一个名为testgit的仓库，效果如下 GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 运行如下命令 git remote add origin https://github.com/sunshine98yy/testgit.git #本地仓库与远程仓库关联命令 git push -u origin master #推到远程仓库上命令 执行git remote就是先将本地仓库与远程仓库建立一个连接，origin是你为远端仓库所起的名字，一般都叫orign,后接远端仓库真实地址。 下一步，就可以把本地库的所有内容推送到远程库上。由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 注意master是你要上传的分支的名字，如果当前所在的分支不叫master，会提示错误git show-ref显示远端的相关分支 从现在起，只要本地作了提交，就可以通过如下命令：git push origin master把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 克隆远程仓库实际开发中需要多人合作，所以需要将远程仓库的代码克隆到本地，然后在本地进行开发，开发完成后需要推送到远程仓库中，方便协作。（远程代码拷贝一份到本地，基于本地的代码进行开发） git clone git@github.com:sunshine98yy/clone_demo.git #（远程代码拷贝到本地）—&gt;提交改动到本地仓库—&gt;本地仓库push到远程仓库克隆仓库默认跟远程仓库分支绑定！！直接命令git push到远程仓库 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改; 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但ssh协议速度最快。 分支管理创建与合并分支Git把每次的提交串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 首先，我们来创建dev分支，然后切换到dev分支上。如下操作： git checkout -b dev #创建并切换分支 Switched to a new branch &#39;dev&#39; git branch #查看当前的分支 git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令 git branch dev git checkout dev git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。 我们在dev分支上继续做demo，比如我们现在在test.txt再增加一行3333，以下为dev分支未添加内容之前和添加内容之后 现在dev分支工作已完成，现在我们切换到主分支master上，继续查看test.txt内容如下 因为不是分支demo，所以3333不显示 我们把dev分支上的内容合并到分支master上，可以在master分支上，使用如下命令git merge dev : git merge命令用于合并指定分支到当前分支上，合并后，再查看test.txt内容，可以看到，和dev分支最新提交的是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。合并完成后，我们可以接着删除dev分支了:git branch -d dev switch我们注意到切换分支使用git checkout，而前面讲过的撤销修改则是git checkout --，同一个命令，有两种作用，确实有点令人迷惑。 实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支： 创建并切换到新的dev分支，可以使用： $ git switch -c dev 直接切换到已有的master分支，可以使用： $ git switch master 使用新的git switch命令，比git checkout要更容易理解。 小结Git鼓励大量使用分支 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 或者git switch name 创建+切换分支：git checkout -b或者git switch -c 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突合并分支往往也不是一帆风顺的 准备新建一个分支，比如名字叫fenzhi1，在test.txt添加一行内容8888，然后提交 同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为5555。如下左图： 现在，master分支和feature1分支各自都分别有新的提交，变成了如下右图： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突 现在我们需要在master分支上来合并fenzhi1，果然冲突了！Git告诉我们，test.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改成和主干代码上一样（fenzhi1删除8888，改5555和master保持一致）再保存。可参考git处理冲突合并 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 分支管理策略通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。如git merge –no-ff -m “注释” dev。将dev分支删除后，用git log还能查看被删除的分支信息。 首先，仍然创建并切换dev分支： $ git switch -c dev Switched to a new branch &#39;dev&#39; 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m &quot;add merge&quot; [dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： $ git switch master Switched to branch &#39;master&#39; 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev Merge made by the &#39;recursive&#39; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit * e1e9c68 (HEAD -&gt; master) merge with no-ff |\\ | * f52c633 (dev) add merge |/ * cf810e4 conflict fixed ... 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活； 干活一般情况下在新建的dev分支上干活，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 小结Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 bug分支在开发中，会经常碰到bug问题，有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号404的bug的任务时，很自然地，你想创建一个分支issue-404来修复它，但是，当前正在dev上进行的工作还没有提交。并不是不想提交，而是工作进行到一半时候，我们还无法提交，预计完成还需1天时间，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。git stash git checkout dev git stash #将当前的工作现场隐藏起来 git status #查看状态是干净的 用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 现在可以通过创建issue-404分支来修复bug了。首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下： git checkout -b issue-404 #创建临时分支 *****修改test文件bug******** git add test.txt git commit -m &#39;fix bug 404&#39; git checkout master #切换到master分支 git merge --no-ff -m &quot;merge bug 404&quot; issue-404 #合并分支issue-404内容 ****合并分支后查看内容，和issue-404内容一致**** git branch -d issue-404 #在master分支上删除临时分支 现在回到dev分支上干活 git checkout dev #从master分支切换到dev分支 git status 工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令git stash list来查看下。工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。2.另一种方式是直接使用git stash pop,恢复的同时把stash内容也删除了。再用git stash list查看，就看不到任何stash内容了。 在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。 那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？ 有木有更简单的方法？ 有！Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支，用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git switch -c feature-vulcan Switched to a new branch &#39;feature-vulcan&#39; 5分钟后，开发完毕： $ git add vulcan.py $ git status On branch feature-vulcan Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: vulcan.py $ git commit -m &quot;add feature vulcan&quot; [feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： $ git switch dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： $ git branch -d feature-vulcan error: The branch &#39;feature-vulcan&#39; is not fully merged. If you are sure you want to delete it, run &#39;git branch -D feature-vulcan&#39;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 287773e). 终于删除成功！ 实际工作中，策划经常改需求的说，怕需求变更太频繁，用上一节的stash隐藏就行了。 多人协作当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。要查看远程库的信息 使用 git remote要查看远程库的详细信息 使用 git remote –v 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： git push origin master 要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev那么一般情况下，那些分支要推送呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫demo2，接着进入testgit2目录，进行克隆远程的库到本地来git clone git@github.com:sunshine98yy/testgit.git（如下左图），现在目录下生成（如下右图） 默认情况下，你的小伙伴只能看到本地的master分支，现在我们的小伙伴要在dev分支上做开发，就必须创建远程的origin的dev分支到本地，于是可以使用这个命令创建本地dev分支： git checkout –b dev origin/dev #创建远程origin的dev分支到本地来 ****可以在dev上继续修改提交，时不时地把dev分支push到远程***** git push origin dev #把现在的dev分支推到远程去 小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时。 由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 git pull也失败了，是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系)。根据命令行提示只需要执行以下命令即可,设置dev和origin/dev的链接:分支的upstream git branch --set-upstream-to=origin/远程分支的名字(我的是dev) 本地分支的名字(我的是dev) 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push 现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。 git push origin dev #继续推送到远程仓库中 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的不得不先pull，在本地合并，然后才能push成功。每次合并再push后，分支会有分叉： Git有一种称为rebase的操作，把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： $ git log --graph --pretty=oneline --abbrev-commit * 582d922 (HEAD -&gt; master) add author * 8875536 add comment * d1be385 (origin/master) init hello * e5e69f1 Merge branch &#39;dev&#39; |\\ | * 57c53ab (origin/dev, dev) fix env conflict | |\\ | | * 7a5e5dd add env | * | 7bd91f1 add new env ... 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： $ git push origin master To github.com:michaelliao/learngit.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &#39;git@github.com:michaelliao/learngit.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： $ git pull remote: Counting objects: 3, done. remote: Compressing objects: 100% (1/1), done. remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:michaelliao/learngit d1be385..f005ed4 master -&gt; origin/master * [new tag] v1.0 -&gt; v1.0 Auto-merging hello.py Merge made by the &#39;recursive&#39; strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： $ git status On branch master Your branch is ahead of &#39;origin/master&#39; by 3 commits. (use &quot;git push&quot; to publish your local commits) nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * e0ea545 (HEAD -&gt; master) Merge branch &#39;master&#39; of github.com:michaelliao/learngit |\\ | * f005ed4 (origin/master) set exit=1 * | 582d922 add author * | 8875536 add comment |/ * d1be385 init hello ... 如果现在把本地分支push到远程，有没有问题？有！不好看！ 这个时候，rebase就派上了用场。我们输入命令git rebase试试： $ git rebase First, rewinding head to replay your work on top of it... Applying: add comment Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py Applying: add author Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * 7e61ed4 (HEAD -&gt; master) add author * 3611cfe add comment * f005ed4 (origin/master) set exit=1 * d1be385 init hello ... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程,再用git log看看效果,远程分支的提交历史也是一条直线。 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。Git有commit，为什么还要引入tag？commit号复杂，tag简介。 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch * dev master $ git checkout master Switched to branch &#39;master&#39; 然后，敲命令git tag就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： $ git log --pretty=oneline --abbrev-commit 12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101 4c805e2 fix bug 101 e1e9c68 merge with no-ff f52c633 add merge cf810e4 conflict fixed 5dc6824 &amp; simple 14096d0 AND simple b17d20e branch test d46f35e remove test.txt b84166e add test.txt 519219b git tracks changes e43a48b understand how stage works 1094adb append GPL e475afc add distributed eaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： $ git tag v0.9 f52c633 再用命令git tag查看标签： $ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息： $ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 操作标签如果标签打错了，也可以删除： $ git tag -d v0.1 Deleted tag &#39;v0.1&#39; (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin： $ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin --tags Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9 Deleted tag &#39;v0.9&#39; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9 To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git tag用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 使用gtihub我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone： git clone git@github.com:michaelliao/bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样： 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。 小结 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 git总结友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用： Git Cheat Sheet 新建代码库git init # 在当前目录新建一个Git代码库 git init [project-name] # 新建一个目录，将其初始化为Git代码库 git clone [url] # 下载一个项目和它的整个代码历史 配置git config --list # 显示当前的Git配置 git config -e [--global] # 编辑Git配置文件 git config [--global] user.name &quot;[name]&quot; # 设置提交代码时的用户信息 git config [--global] user.email &quot;[email address]&quot; # 设置提交代码时的用户邮箱信息 增加/删除文件git add [file1] [file2] ... # 添加指定文件到暂存区 git add [dir] # 添加指定目录到暂存区，包括子目录 git add . # 添加当前目录的所有文件到暂存区$ git add -p # 添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] ... # 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] # 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] # 改名文件，并且将这个改名放入暂存区 代码提交git commit -m [message] # 提交暂存区到仓库区 git commit [file1] [file2] ... -m [message] # 提交暂存区的指定文件到仓库区 git commit -a # 提交工作区自上次commit之后的变化，直接到仓库区 git commit -v # 提交时显示所有diff信息 git commit --amend -m [message] # 使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend [file1] [file2] ... # 重做上一次commit，并包括指定文件的新变化 分支git branch # 列出所有本地分支 git branch -r # 列出所有远程分支 git branch -a # 列出所有本地分支和远程分支 git branch [branch-name] # 新建一个分支，但依然停留在当前分支 git checkout -b [branch] # 新建一个分支，并切换到该分支 git branch [branch] [commit] # 新建一个分支，指向指定commit git branch --track [branch] [remote-branch] #新建一个分支，与指定的远程分支建立追踪关系 git checkout [branch-name] # 切换到指定分支，并更新工作区 git checkout - # 切换到上一个分支 git branch --set-upstream [branch] [remote-branch] # 建立追踪关系，在现有分支与指定的远程分支之间 git merge [branch] # 合并指定分支到当前分支 git cherry-pick [commit] # 选择一个commit，合并进当前分支 git branch -d [branch-name] # 删除分支 git push origin --delete [branch-name] git branch -dr [remote/branch] # 删除远程分支 标签git tag # 列出所有tag git tag [tag] # 新建一个tag在当前commit git tag [tag] [commit] # 新建一个tag在指定commit git tag -d [tag] # 删除本地tag git push origin :refs/tags/[tagName] # 删除远程tag git show [tag] # 查看tag信息 git push [remote] [tag] # 提交指定tag git push [remote] --tags # 提交所有tag git checkout -b [branch] [tag] # 新建一个分支，指向某个tag 查看信息git status # 显示有变更的文件 git log # 显示当前分支的版本历史 git log --stat # 显示commit历史，以及每次commit发生变更的文件 git log -S [keyword] # 搜索提交历史，根据关键词 git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --grep feature # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 git log --follow [file] git whatchanged [file] # 显示某个文件的版本历史，包括文件改名 git log -p [file] # 显示指定文件相关的每一次diff git log -5 --pretty --oneline # 显示过去5次提交 git shortlog -sn # 显示所有提交过的用户，按提交次数排序 git blame [file] # 显示指定文件是什么人在什么时间修改过 git diff # 显示暂存区和工作区的差异 git diff --cached [file] # 显示暂存区和上一个commit的差异 git diff HEAD # 显示工作区与当前分支最新commit之间的差异 git diff [first-branch]...[second-branch] # 显示两次提交之间的差异 git diff --shortstat &quot;@{0 day ago}&quot; # 显示今天你写了多少行代码 git show [commit] # 显示某次提交的元数据和内容变化 git show --name-only [commit] # 显示某次提交发生变化的文件 git show [commit]:[filename] # 显示某次提交时，某个文件的内容 git reflog# 显示当前分支的最近几次提交 远程同步git fetch [remote] # 下载远程仓库的所有变动 git remote -v # 显示所有远程仓库 git remote show [remote] # 显示某个远程仓库的信息 git remote add [shortname] [url] # 增加一个新的远程仓库，并命名 git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 git push [remote] [branch] # 上传本地指定分支到远程仓库 git push [remote] --force # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --all # 推送所有分支到远程仓库 撤销git checkout [file] # 恢复暂存区的指定文件到工作区 git checkout [commit] [file] # 恢复某个commit的指定文件到暂存区和工作区 git checkout . # 恢复暂存区的所有文件到工作区 git reset [file] # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset --hard # 重置暂存区与工作区，与上一次commit保持一致 git reset [commit] # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset --hard [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --keep [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git revert [commit] # 新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支 git stash git stash pop # 暂时将未提交的变化移除，稍后再移入","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Hexo搭建个人网站(步骤篇)","slug":"Hexo搭建个人博客网站（步骤篇）","date":"2020-05-21T11:20:00.000Z","updated":"2020-05-21T13:58:07.576Z","comments":true,"path":"2020/05/21/Hexo搭建个人博客网站（步骤篇）/","link":"","permalink":"/2020/05/21/Hexo搭建个人博客网站（步骤篇）/","excerpt":"","text":"环境部署安装gitNode.js官网 点击自己需要的版本，一路next默认安装即可。教程可参见之前的博客 安装Node.jsGit 官网 点击自己需要的版本默认安装即可。教程可参见博客,写的很详细了nodejs安装与环境变量配置 安装HexoHexo就是我们的个人博客网站的框架， 这里需要自己在某个磁盘里创建一个文件夹，Hexo框架和以后你自己发布的网页都在这个文件夹中，我在D盘创建一个YY_Blog的文件夹。 1.使用npm下载hexo：在命令行上（任意目录）使用npm install -g hexo 全局安装hexo； 2.安装完成后，在你喜爱的文件夹下（如D:\\YY_Blog），执行以下指令hexo init(在D:\\YY_Blog内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件；（过程有点慢，耐心等待） 3.安装依赖包：npm install至此，hexo博客环境已经搭建完成，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000即可查看效果： $ hexo g #等价于hexo generate 生成静态网页 $ hexo s #等价于hexo server 启动预览服务器，开启-d选项时可以预览草稿 将hexo部署到github上上文已经在本地部署好了hexo博客系统，但仅仅本地能够访问。如果想让别人访问到你的博客，你可以租一台云主机，然后把hexo系统部署到云主机上，好处是带宽、容量可以得到保证，缺点是需要花费一笔租金。还有另一种免费的方法，就是把hexo部署到githu pages或者gitcafe pages上，本文以github为例。 关于git的安装配置以及github添加公钥的流程可以参见我的博客 [[git的安装配置]]: d 1.创建repository【your repositories】—-【new】 如下图所示，这里要注意，repository名称一定是github的用户名+.github.io,否则github pages无法访问。 2.在github中添加公钥打开git bash输入以下命令 $ git config --global user.name &quot;你的用户名&quot; $ git config --global user.email &quot;你的邮箱&quot; 每次使用git命令从github上同步代码时，需要SSH连接认证。这时就需要你在本地先生成SSH KEY(命令如下)，然后把其拷贝到github上。点击Git Bash Here 输入以下命令： $ ssh-keygen -t rsa -C &quot;你的邮箱&quot; #邮箱是github的注册邮箱 Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 运行下面命令，将公钥的内容复制到剪切板 clip &lt; ~/.ssh/id_rsa.pub 打开github—-&gt;settings—-&gt;SSH and GPG keys—-&gt;new ssh key—-&gt;把内容粘到key区域—-&gt;add SSH key 如下图 3.部署hexo1.编辑_config.yml(在D:\\YY_Blog下)，repository是在github中申请的地址。如下： 注意：所有的冒号后面空一格 deploy: type: git repository: https://github.com/sunshine98yy/sunshine98yy.github.io.git branch: master 2.执行下面命令 生成、部署hexo博客到github上,这样，你就可以在sunshine98yy.github.io来访问你的博客了。(后面会有专门一栏讲如何绑定自己专属域名) hexo g hexo d 注意 在执行hexo d命令时，有可能会显示如下错误信息：ERROR Deployer not found : github 解决方法如下： 在hexo的配置文件中，把deploy的type改成git 运行如下命令：npm install hexo-deployer-git --save 文献参考https://blog.csdn.net/ParanoidYang/article/details/71436028 https://blog.csdn.net/guoxiaorui666/article/details/99623023 https://lanjingling.github.io/2015/09/23/hexo%E7%AE%80%E4%BB%8B/","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo搭建个人博客网站（原理篇）","slug":"Hexo搭建个人博客网站（原理篇）","date":"2020-05-20T15:14:57.000Z","updated":"2020-05-21T13:33:12.332Z","comments":true,"path":"2020/05/20/Hexo搭建个人博客网站（原理篇）/","link":"","permalink":"/2020/05/20/Hexo搭建个人博客网站（原理篇）/","excerpt":"","text":"前言学习HEXO的初衷是想建立一个博客网站，分享记录日常所学。参考了网上很多的资料，在安装、配置、开发的过程中补过坑，也接触了新的领域。挖掘新事物的过程就像从开始发现一粒沙到后来窥探到瀚海星辰一般有趣。在结合资料的基础上，将整个过程梳理记录一下。 首先需要阐明本文使用Windows环境配置。 Hexo这章我们主要来讲一下 Hexo 是怎样生成 HTML 的。 Hexo简介hexo是使用nodejs开发的一个快速、简洁、高效、开源的静态博客生成器。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 为什么选择Hexo hexo非常小巧，使用nodejs开发，下载安装时只需要几个npm命令即可。 纯静态博客，不需要什么额外的mysql数据库、php环境…仅仅需要一个nodejs环境即可。 由于是静态博客，所以，可以非常方便部署到github、gitcafe上(后者是国内的，速度可能更有保证) 支持markdown语法、兼容windows linux mac，高可扩展性和自定义，而且有非常多的hexo主题… 工作原理hexo文件架构├── node_modules： #依赖包-安装插件及所需nodejs模块。 ├── public #最终网页信息。即存放被解析markdown、html文件。 ├── scaffolds #模板文件夹。即当您新建文章时，根据 scaffold生成文件。 ├── source #资源文件夹。即存放用户资源。 | └── _posts #博客文章目录。 └── themes #存放主题。Hexo根据主题生成静态页面。 ├── _config.yml #网站的配置信息。标题、网站名称等。 ├── db.json： #source解析所得到的缓存文件。 ├── package.json # 应用程序信息。即配置Hexo运行需要js包。 首先本地文件夹的source就是数据库，以.md（markdown）格式存储文章，theme文件夹是主题文件（决定页面模板）。 我们可以通过部署流程来逐步详尽分析。以下先来了解hexo有哪些部署命令，再分析部署的步骤流程 hexo命令总览hexo可以粗略分为三个子项目，分别是: hexo-cli hexo (下文中用hexo core来指代) hexo plugins hexo-cli：hexo命令行，作用是： 1.启动hexo命令进程和参数解析机制。每次我们输入hexo xxx命令后，都会通过node调用hexo-cli中的entry函数(比如，可以把’hexo init’视为’node hexo-cli/entry.js init’)，hexo init命令仅仅在安装时调用 2.实现hexo命令的三个初始参数：init/version/plugins 3.加载hexo核心模块，并初始化 hexo core：hexo核心，作用是：实现hexo的new、generate、publish等功能 hexo plugins: 指一些能够扩展hexo的插件。插件可以按功能分成两类: 1.扩展hexo命令的参数，如hexo-server(安装这个插件以后才能使用hexo server命令) 2.扩展hexo解析文件的”能力”，如增加jade模版解析功能的hexo-render-jade插件 介绍hexo主要命令： hexo n title #等价于 hexo new [layout] title 发布新文章 hexo p filename #等价于hexo publish filename 将_drafts下的文件放到_posts下，也就是发布草稿 hexo g #等价于hexo generate 生成静态网页 hexo s #等价于hexo server 启动预览服务器，开启-d选项时可以预览草稿 hexo d #等价于hexo deploy 发布到远程服务器，开启–generate选项可以在deploy前自动generate hexo s –debug #使用hexo s 启动本地服务后，如果修改了配置或者文章内容，需要停止服务后重新启动才能生效。这样，在调试或写文章阶段非常不方便，可以使用下面命令，以debug的方式启动，这样每次修改后就无需重启服务了。 部署的流程hexo g：生成静态文件。将我们的数据和界面模板相结合生成静态文件的过程。Hexo（node.js程序）遍历主题文件中你的source目录（js、css、img等静态资源），建立索引，再根据索引生成由html、js、css、img建立的纯静态文件并放在public文件夹里。public就是你的博客了，而这些恰好能被git pages识别。 hexo d：部署文件。主要是根据在_config.yml中配置的git仓库或者coding的地址，将public文件通过git方式push到上传到github或coding的指定分支，然后在根据pages服务呈现出页面。当然把public文件部署至你的服务器也是OK滴。 Hexo的模板引擎模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离 1.请看Hexo文件结构，source文件夹与themes文件夹是同级的，进而我们就可以将source文件夹理解为数据库，而主题文件夹相当于界面。hexo g就将我们的数据和界面相结合生成静态文件public 2.Hexo模板引擎默认使用ejs编写（本文以ejs模板举例，其他的有swig、jade）。hexo首先会解析.md文件，然后根据layout变量判断布局类型，再调用相应布局文件，这样每一块内容都是独立的，提供代码的复用性。最终生成一个html页面 3.布局模板文件位于layout文件夹下，以下将布局模板简称模板。layout文件结构在不同主题下文件排布不一，但整体框架是一样的，有： 公共模板。里面引入了head、footer等公共组件，在其他模板下会自动引入公共模板 首页模板 文章模板 分类模板 归档模板 …… 每个模板都默认使用layout布局，您可在文章的前置申明中指定其他布局，比如“post”或者“page”或是设为false来关闭布局功能（如果不填默认是post，这个在_config.yml中可以设置默认值），您甚至可在布局中再使用其他布局来建立嵌套布局 我们使用的模板。hexo new [layout] &lt;title&gt;就会使用对应的模板。 数据填充上面解释了界面的原理，此篇将分析数据及数据如何与界面结合。 数据的填充主要是 hexo -g 的时候将数据传递给 ejs 模板，然后再由 ejs 模板填充到 HTML 中。 配置文件中的数据Hexo 的配置文件 _config.yml 使用 yml语法 。例如博客的名字、副标题等等之类。这些数据项组织在 config 对象中。可以是数字、字符串、对象、数组。 如果要在模板中使用某个具体的值，比如字符串、数字、逻辑变量或者对象的某个成员，可以在主题的模板文件 ejs中直接使用： {% block title %} {{ page.title }} | {{ config.title }} {% endblock %} Github PagesHexo搭建的博客项目源码托管在github，并享受github pages服务。 GitHub pages简称pages服务，每个仓库都有一个pages服务，可用来展示项目，通过简单的设置项目的index.html，并以此做为入口供用户参观访问。大部分的 pages 服务都是用来搭建个人博客的。言外之意不仅能搭建博客，还能做些其他的事情~ 生成博客的页面有动、静态页面之分，著名的博客 wordpress ，既是动态页面生成的博客，其思路是 php + MySql 。 博客hexo生成的是静态页面，而Github pages 又支持静态页面的解析。因此二者一拍即合能够用来生成 html 拼合成博客。 参考文献：https://hexo.io/zh-cn/docs/github-pages https://juejin.im/post/598eeaff5188257d592e55bb#heading-5","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"解决hexo不兼容标签问题","slug":"如何从根本解决hexo不兼容标签问题","date":"2020-05-20T13:21:08.000Z","updated":"2020-06-26T13:43:29.095Z","comments":true,"path":"2020/05/20/如何从根本解决hexo不兼容标签问题/","link":"","permalink":"/2020/05/20/如何从根本解决hexo不兼容标签问题/","excerpt":"","text":"如何从根本解决hexo不兼容{{}}标签问题报错文字转载于博客如何从根本解决hexo不兼容{{}}标签问题 本人在记录js学习的过程中md使用{{}}符号，发现hexo g报错。 如果你的博客是使用github+hexo搭建的，很可能也遇到过由于nunjucks模板标签导致MD文件解析报错的问题，常见问题如下： 15:07:29.010 FATAL Something is wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Template render error: (unknown path) [Line 37, Column 81] expected variable end at Object._prettifyError (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:524:21) at Environment.renderString (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:362:17) at Promise (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/extend/tag.js:66:9) at Promise._execute (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/debuggability.js:303:9) at Promise._resolveFromExecutor (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:483:18) 或者： Unhandled rejection Template render error: (unknown path) [Line 10, Column 95] unexpected token: # at Object._prettifyError (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:524:21) at Environment.renderString (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:362:17) at Promise (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/extend/tag.js:66:9) at Promise._execute (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/debuggability.js:303:9) at Promise._resolveFromExecutor (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:483:18) at new Promise (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:79:10) at Tag.render (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/extend/tag.js:64:10) at Object.tagFilter [as onRenderEnd] (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/hexo/post.js:230:16) at Promise.then.then.result (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/hexo/render.js:65:19) at tryCatcher (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:693:18) at Async._drainQueue (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/async.js:133:16) at Async._drainQueues (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/async.js:143:10) at Immediate.Async.drainQueues (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:651:20) at tryOnImmediate (timers.js:624:5) at processImmediate [as _immediateCallback] (timers.js:596:5) 出现上述原因都是因为你的Markdown文件中有标签与nunjucks模板引擎的标签冲突了，比如{{}}，}等等这些标签的内容都会解析失败，那么有什么好的处理方案呢？ 处理方案2答案是有的，我们可以直接修改nunjucks模板的源代码，找到如下文件： node_modules/nunjucks/src/lexer.js 在文件的开头可以看到如下代码： 可以直接改了这些渲染标签，比如我的Markdown文件中就是需要显示{{name}}这一类代码。那么你可以这么做： var VARIABLE_START = &#39;{$&#39;; var VARIABLE_END = &#39;$}&#39;; 把模板引擎的占位符修改为其他字符之后，这样模板解析的时候就不会跟你的Markdown内容冲突了，而且是对所有Markdown文件都有效的。 但是需要注意的时候，如果你在项目下执行npm install更新nunjucks模板，那么你修改的node_modules/nunjucks/src/lexer.js会被还原，需要重新修改一遍。但是相对于每个Markdown都修改还是有很大好处的。 方案3提供一个一劳永逸的方案，修改项目的package.json文件，把hexo-generator-feed、hexo-generator-search改为我重新处理过的插件即可。 { &quot;name&quot;: &quot;xcoding&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.7.1&quot; }, &quot;dependencies&quot;: { //…… 其他省略 &quot;hexo-generator-feed-cst&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-search-cst&quot;: &quot;^0.1.0&quot;, //…… 其他省略 } } 修改完package.json之后执行命令npm install重新安装依赖。安装完毕后重新启动hexo。这两个插件相关的配置都不需要做任何修改，也不用担心查询更新后被覆盖。","categories":[{"name":"hexo","slug":"hexo","permalink":"/categories/hexo/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"/categories/hexo/"}]},{"title":"Hexo运营前记","slug":"Hexo运营前记","date":"2020-05-20T11:30:23.000Z","updated":"2020-05-20T11:19:52.510Z","comments":true,"path":"2020/05/20/Hexo运营前记/","link":"","permalink":"/2020/05/20/Hexo运营前记/","excerpt":"","text":"着手搭建博客是一件不在计划内的事情。起因是前段时间接触Linux的内容，讲到用SSH实现客户端到服务器端的免密登录时，有用一个hexo+github page搭建网站过程中的环节举例。虽然只是一句话带过的例子，在我尝试配置了本地SSH秘钥后，完全发现了一个新的探索方向（折腾方向）。 做博客就像打游戏，当你以为自己升到80级时，对于别人来说这仅仅处于20级的位置，层次浅到非常。 花在上面的时间前前后后有两周的晚上，开始照着官方文档来，实现基本配置。后面又浏览了下大佬们的博客，对比一下自己眼前毫无特色的主页不香了。于是推倒重建找主题，加美化插件。只能说一时折腾一时爽，永远折腾永远爽吧。 整个过程大致是换了两个主题，Icarus、Sakura。搭建用CDN加速连接的图库，熟悉hexo框架的基本命令，markdown的基本语法（没错，写博客更博客不像空间发状态那么直接），走了一遍git的工作流程，购买解析了域名。不停地倒腾配置文件，最主要的是找合适的优化插件。耗费这么多精力是我一开始没想到的。自己就像在海边捡起一枚贝壳，透过小小的贝壳看到大海的模样。下面是一开始Icarus的主题，其实还是挺好看的。作者最近用新的语言重新写了一套框架，因此想自己发挥的难度对我这种新手难度很大。 Icarus这款主题主打简洁大方，页面清爽。在上面增加了板娘的效果，评论打赏分类标签历程展示，基本都能实现，icarus也有缺点，无多级导航（仅仅是个人喜好）。后来浏览到sakura主题，也就是现在的主题。在简洁和酷炫之间还是选择了后者。模板用的人还不多，下载了主题star了下项目，感谢原作者的创作。下面是自己DIY的样式。 “工欲善其事必先利其器”，搭建的博客网站是记录自己历程的利器。也很是佩服自己这把年纪了还能这么折腾。 折腾被赋予了一个新的含义——走出舒适区。诚然，走出舒适区现在已然成许多人的口号，嘴上说说而已的口号，智商常常不在线的我更是如此。 漫长的道路，现在只是一个开始的起点。 A journey like life, welcome to my entire world!","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"画廊——日常","slug":"画廊","date":"2020-05-19T14:06:43.000Z","updated":"2020-05-21T06:14:52.200Z","comments":true,"path":"2020/05/19/画廊/","link":"","permalink":"/2020/05/19/画廊/","excerpt":"","text":"献给我琳~","categories":[],"tags":[{"name":"光影艺术","slug":"光影艺术","permalink":"/tags/光影艺术/"}],"keywords":[]},{"title":"SSM+Springboot商铺系统(一)","slug":"SSM-Springboot商铺系统","date":"2020-05-19T13:21:08.000Z","updated":"2020-05-19T13:31:48.298Z","comments":true,"path":"2020/05/19/SSM-Springboot商铺系统/","link":"","permalink":"/2020/05/19/SSM-Springboot商铺系统/","excerpt":"","text":"待更~","categories":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}],"tags":[],"keywords":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}]},{"title":"Linux核心技术与应用笔记（一）","slug":"Linux核心技术与应用笔记（一）","date":"2020-05-19T11:24:34.000Z","updated":"2020-05-19T11:42:58.713Z","comments":true,"path":"2020/05/19/Linux核心技术与应用笔记（一）/","link":"","permalink":"/2020/05/19/Linux核心技术与应用笔记（一）/","excerpt":"","text":"待更~~~~","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Sakura主题配置总结","slug":"Hexo-Theme-Sakura","date":"2020-05-19T02:45:01.000Z","updated":"2020-05-20T15:44:32.309Z","comments":true,"path":"2020/05/19/Hexo-Theme-Sakura/","link":"","permalink":"/2020/05/19/Hexo-Theme-Sakura/","excerpt":"","text":"前言搭建完框架后，为博客找一个主题。主题的搭建往往是无止境的，适合爱折腾的选手。在网上被迫欣赏大佬们的华丽主题后，我看着自己一开始配置的主题，突然觉得不香了。是时候换一拨了，挑选了一个用的人比较少的sakura主题，在github上star了项目，感谢原作者的辛勤创作。 一： 主题下载hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 二： 主题配置博客根目录下的_config配置站点（显示在浏览器导航页的信息） # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://sunshine98yy.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/sunshine98yy/sunshine98yy.github.io.git,backup # coding: https://git.coding.net/sunshine98yy/sunshine98yy.git,backup 顶部站点名字其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: YU YU 顶部导航栏# 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } 前面的path是网页路径，这个不建议修改，但可以修改。后面的如: fa: fas fa-home fa-1x 这个就是对应的图标设置,关于这个图标大家可以去fontawesome看教程以及选择自己喜欢的图标，导航栏下拉下拉菜单的图标修改和导航栏相同。 头像修改# favicon and site master avatar # 站点的favicon和头像 输入图片路径【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg 我这个是使用cdn后的路径，也可以修改为： favicon: https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg 大家可以用jsDeliver+github搭建自己的cdn,具体教程请点击查看我的另一篇博客其中有详细介绍！ # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"},{"name":"sakura","slug":"sakura","permalink":"/tags/sakura/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}