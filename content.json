{"meta":{"title":"风中的鱼","subtitle":null,"description":"心里有火眼里有光","author":"YU YU","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-05-19T07:23:57.767Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"categories","date":"2020-03-09T05:50:05.000Z","updated":"2020-05-19T15:43:16.267Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-05-19T08:37:48.007Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"tags","date":"2020-03-09T05:50:05.000Z","updated":"2020-05-19T15:18:50.643Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-05-18T08:11:28.691Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"[object Object]","slug":"如何从根本解决hexo不兼容{{}}标签问题","date":"2020-06-18T15:39:18.281Z","updated":"2020-06-18T16:02:04.107Z","comments":true,"path":"2020/06/18/如何从根本解决hexo不兼容{{}}标签问题/","link":"","permalink":"/2020/06/18/如何从根本解决hexo不兼容{{}}标签问题/","excerpt":"","text":"如何从根本解决hexo不兼容{{}}标签问题报错文字转载于博客如何从根本解决hexo不兼容{{}}标签问题 本人在记录js学习的过程中md使用{{}}符号，发现hexo g报错。 如果你的博客是使用github+hexo搭建的，很可能也遇到过由于nunjucks模板标签导致MD文件解析报错的问题，常见问题如下： 15:07:29.010 FATAL Something is wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Template render error: (unknown path) [Line 37, Column 81] expected variable end at Object._prettifyError (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:524:21) at Environment.renderString (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:362:17) at Promise (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/extend/tag.js:66:9) at Promise._execute (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/debuggability.js:303:9) at Promise._resolveFromExecutor (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:483:18) 或者： Unhandled rejection Template render error: (unknown path) [Line 10, Column 95] unexpected token: # at Object._prettifyError (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:524:21) at Environment.renderString (/Users/ubuntuvim/git/xcoding/node_modules/nunjucks/src/environment.js:362:17) at Promise (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/extend/tag.js:66:9) at Promise._execute (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/debuggability.js:303:9) at Promise._resolveFromExecutor (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:483:18) at new Promise (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:79:10) at Tag.render (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/extend/tag.js:64:10) at Object.tagFilter [as onRenderEnd] (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/hexo/post.js:230:16) at Promise.then.then.result (/Users/ubuntuvim/git/xcoding/node_modules/hexo/lib/hexo/render.js:65:19) at tryCatcher (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/promise.js:693:18) at Async._drainQueue (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/async.js:133:16) at Async._drainQueues (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/async.js:143:10) at Immediate.Async.drainQueues (/Users/ubuntuvim/git/xcoding/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:651:20) at tryOnImmediate (timers.js:624:5) at processImmediate [as _immediateCallback] (timers.js:596:5) 出现上述原因都是因为你的Markdown文件中有标签与nunjucks模板引擎的标签冲突了，比如{{}}，}等等这些标签的内容都会解析失败，那么有什么好的处理方案呢？ 处理方案2答案是有的，我们可以直接修改nunjucks模板的源代码，找到如下文件： node_modules/nunjucks/src/lexer.js 在文件的开头可以看到如下代码： 可以直接改了这些渲染标签，比如我的Markdown文件中就是需要显示{{name}}这一类代码。那么你可以这么做： var VARIABLE_START = &#39;{$&#39;; var VARIABLE_END = &#39;$}&#39;; 把模板引擎的占位符修改为其他字符之后，这样模板解析的时候就不会跟你的Markdown内容冲突了，而且是对所有Markdown文件都有效的。 但是需要注意的时候，如果你在项目下执行npm install更新nunjucks模板，那么你修改的node_modules/nunjucks/src/lexer.js会被还原，需要重新修改一遍。但是相对于每个Markdown都修改还是有很大好处的。 方案3提供一个一劳永逸的方案，修改项目的package.json文件，把hexo-generator-feed、hexo-generator-search改为我重新处理过的插件即可。 { &quot;name&quot;: &quot;xcoding&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.7.1&quot; }, &quot;dependencies&quot;: { //…… 其他省略 &quot;hexo-generator-feed-cst&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-search-cst&quot;: &quot;^0.1.0&quot;, //…… 其他省略 } } 修改完package.json之后执行命令npm install重新安装依赖。安装完毕后重新启动hexo。这两个插件相关的配置都不需要做任何修改，也不用担心查询更新后被覆盖。","categories":[{"name":"hexo","slug":"hexo","permalink":"/categories/hexo/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"/categories/hexo/"}]},{"title":"Java教程笔记之异常处理","slug":"Java教程笔记之异常处理","date":"2020-06-18T15:12:25.000Z","updated":"2020-06-18T15:13:51.953Z","comments":true,"path":"2020/06/18/Java教程笔记之异常处理/","link":"","permalink":"/2020/06/18/Java教程笔记之异常处理/","excerpt":"","text":"异常处理Java的异常一个健壮的程序必须处理各种各样的错误。Java内置了一套异常处理机制，总是使用异常来表示错误。 异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了 try { String s = processFile(“C:\\\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 因为Java的异常是class，它的继承关系如下： 从继承关系可知：Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力，例如： OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 而Exception则是运行时的错误，它可以被捕获并处理。 某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如： NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如： NullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Exception又分为两大类： RuntimeException（（运行时异常））以及它的子类； 非RuntimeException（包括IOException、ReflectiveOperationException等等） Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常编译器要求强制处置，要么try-cathch,要么在方法名后面抛出。不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。 捕获异常捕获异常使用try...catch语句，把可能发生异常的代码放到try {...}中，然后使用catch捕获对应的Exception及其子类： public class Main { public static void main(String[] args) { byte[] bs = toGBK(&quot;中文&quot;); //在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的异常,因此会报错 System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) { try { // 用指定编码转换String为byte[]: return s.getBytes(&quot;GBK&quot;); } catch (UnsupportedEncodingException e) { // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e); // 打印异常信息 return s.getBytes(); // 尝试使用用默认编码 } } } //method_2 static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(&quot;GBK&quot;); } 如果我们不捕获UnsupportedEncodingException，会出现编译失败的问题这样的Checked Exception，必须被捕获。 这是因为String.getBytes(String)方法定义是： public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { ... } 在方法定义的时候，使用throws xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。 在toGBK()方法中，因为调用了String.getBytes(String)方法，就必须捕获UnsupportedEncodingException。我们也可以不捕获它，而是在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查。 上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用return s.getBytes(&quot;GBK&quot;);的问题，而是byte[] bs = toGBK(&quot;中文&quot;);。因为在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的UnsupportedEncodingException。 修复方法是在main()方法中捕获异常并处理。 public class Main { public static void main(String[] args) { try { byte[] bs = toGBK(&quot;中文&quot;); System.out.println(Arrays.toString(bs)); } catch (UnsupportedEncodingException e) { System.out.println(e); } } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(&quot;GBK&quot;); } } 可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在main()方法中捕获，不会出现漏写try的情况。这是由编译器保证的。main()方法也是最后捕获Exception的机会。 如果是测试代码，上面的写法就略显麻烦。如果不想写任何try代码，可以直接把main()方法定义为throws Exception public class Main { public static void main(String[] args) throws Exception { byte[] bs = toGBK(&quot;中文&quot;); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(&quot;GBK&quot;); } } 因为main()方法声明了可能抛出Exception，也就声明了可能抛出所有的Exception，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。 还有一些童鞋喜欢在toGBK()内部“消化”异常： static byte[] toGBK(String s) { try { return s.getBytes(&quot;GBK&quot;); } catch (UnsupportedEncodingException e) { // 什么也不干 } return null; 这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来： static byte[] toGBK(String s) { try { return s.getBytes(&quot;GBK&quot;); } catch (UnsupportedEncodingException e) { // 先记下来再说: e.printStackTrace(); } return null; 所有异常都可以调用printStackTrace()方法打印异常栈，这是一个简单有用的快速打印异常的方法。 小结Java使用异常来表示错误，并通过try ... catch捕获异常； Java的异常是class，并且从Throwable继承； Error是无需捕获的严重错误，Exception是应该捕获的可处理的错误； RuntimeException无需强制捕获，非RuntimeException（Checked Exception）需强制捕获，或者用throws声明； 不推荐捕获了异常但不进行任何处理。 捕获异常在Java中，凡是可能抛出异常的语句，都可以用try ... catch捕获。把可能发生异常的语句放在try { ... }中，然后使用catch捕获对应的Exception及其子类。 多catch语句可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 简单地说就是：多个catch语句只有一个能被执行。例如： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(e); } catch (NumberFormatException e) { System.out.println(e); } } 存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。例如： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(&quot;IO error&quot;); } catch (UnsupportedEncodingException e) { // 永远捕获不到 System.out.println(&quot;Bad encoding&quot;); } } 对于上面的代码，UnsupportedEncodingException异常是永远捕获不到的，因为它是IOException的子类。当抛出UnsupportedEncodingException异常时，会被catch (IOException e) { ... }捕获并执行。 因此，正确的写法是把子类放到前面。 finally语句无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？ 可以把执行语句写若干遍：正常执行的放到try中，每个catch再写一遍。例如： public static void main(String[] args) { try { process1(); process2(); process3(); System.out.println(&quot;END&quot;); } catch (UnsupportedEncodingException e) { System.out.println(&quot;Bad encoding&quot;); System.out.println(&quot;END&quot;); } catch (IOException e) { System.out.println(&quot;IO error&quot;); System.out.println(&quot;END&quot;); } } 上述代码无论是否发生异常，都会执行System.out.println(&quot;END&quot;);这条语句。 那么如何消除这些重复的代码？Java的try ... catch机制还提供了finally语句，finally语句块保证有无错误都会执行。上述代码可以改写如下： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(&quot;Bad encoding&quot;); } catch (IOException e) { System.out.println(&quot;IO error&quot;); } finally { System.out.println(&quot;END&quot;); } } 注意finally有几个特点： finally语句不是必须的，可写可不写； finally总是最后执行。 如果没有发生异常，就正常执行try { ... }语句块，然后执行finally。如果发生了异常，就中断执行try { ... }语句块，然后跳转执行匹配的catch语句块，最后执行finally。 可见，finally是用来保证一些代码必须执行的。 某些情况下，可以没有catch，只使用try ... finally结构。例如： void process(String file) throws IOException { try { ... } finally { System.out.println(&quot;END&quot;); } } 因为方法声明了可能抛出的异常，所以可以不写catch。 捕获多种异常如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条catch子句： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(&quot;Bad input&quot;); } catch (NumberFormatException e) { System.out.println(&quot;Bad input&quot;); } catch (Exception e) { System.out.println(&quot;Unknown error&quot;); } } 因为处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException System.out.println(&quot;Bad input&quot;); } catch (Exception e) { System.out.println(&quot;Unknown error&quot;); } } 小结使用try ... catch ... finally时： 多个catch语句的匹配顺序非常重要，子类必须放在前面； finally语句保证了有无异常都会执行，它是可选的； 一个catch语句也可以匹配多个非继承关系的异常。 抛出异常异常的传播当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止 public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { process2(); } static void process2() { Integer.parseInt(null); // 会抛出NumberFormatException } } 通过printStackTrace()可以打印出方法的调用栈，类似： java.lang.NumberFormatException: null at java.base/java.lang.Integer.parseInt(Integer.java:614) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.process2(Main.java:16) at Main.process1(Main.java:12) at Main.main(Main.java:5) printStackTrace()对于调试错误非常有用，上述信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的，从下往上看，调用层次依次是： 1. `main()`调用`process1()`； 2. `process1()`调用`process2()`； 3. `process2()`调用`Integer.parseInt(String)`； 4. `Integer.parseInt(String)`调用`Integer.parseInt(String, int)`。 查看Integer.java源码可知，抛出异常的方法代码如下： public static int parseInt(String s, int radix) throws NumberFormatException { if (s == null) { throw new NumberFormatException(&quot;null&quot;); } ... } 并且，每层调用均给出了源代码的行号，可直接定位。 抛出异常当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。 如何抛出异常？参考Integer.parseInt()方法，抛出异常分两步： 创建某个Exception的实例； 用throw语句抛出。 下面是一个例子： void process2(String s) { if (s==null) { NullPointerException e = new NullPointerException(); throw e; } } 实际上，绝大部分抛出异常的代码都会合并写成一行： void process2(String s) { if (s==null) { throw new NullPointerException(); } } 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： void process1(String s) { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } void process2(String s) { if (s==null) { throw new NullPointerException(); } } 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 如果在main()中捕获IllegalArgumentException，我们看看打印的异常栈： public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); // } } static void process2() { throw new NullPointerException(); } } 打印出的异常栈类似： java.lang.IllegalArgumentException at Main.process1(Main.java:15) at Main.main(Main.java:5) 这说明新的异常丢失了原始异常信息，我们已经看不到原始异常NullPointerException的信息了。 为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。对上述代码改进如下： public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(e);\\\\把原始的`Exception`实例传进去 } } static void process2() { throw new NullPointerException(); } } 运行上述代码，打印出的异常栈类似： java.lang.IllegalArgumentException: java.lang.NullPointerException at Main.process1(Main.java:15) at Main.main(Main.java:5) Caused by: java.lang.NullPointerException at Main.process2(Main.java:20) at Main.process1(Main.java:13) 注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的。 在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。 异常屏蔽如果在执行finally语句时抛出异常，那么，catch语句的异常还能否继续抛出？例如： public class Main { public static void main(String[] args) { try { Integer.parseInt(&quot;abc&quot;); } catch (Exception e) { System.out.println(&quot;catched&quot;); throw new RuntimeException(e); } finally { System.out.println(&quot;finally&quot;); throw new IllegalArgumentException(); } } } 执行上述代码，发现异常信息如下： catched finally Exception in thread &quot;main&quot; java.lang.IllegalArgumentException at Main.main(Main.java:11) 这说明finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。 在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出： public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(&quot;abc&quot;)); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } } 当catch和finally都抛出了异常时，虽然catch的异常被屏蔽了，但是，finally抛出的异常仍然包含了它： Exception in thread &quot;main&quot; java.lang.IllegalArgumentException at Main.main(Main.java:11) Suppressed: java.lang.NumberFormatException: For input string: &quot;abc&quot; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.main(Main.java:6) 通过Throwable.getSuppressed()可以获取所有的Suppressed Exception。 绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception。 小结调用printStackTrace()可以打印异常的传播栈，对于调试非常有用； 捕获异常并再次抛出新的异常时，应该持有原始异常信息； 通常不要在finally中抛出异常。如果在finally中抛出异常，应该原始异常加入到原有异常中。调用方可通过Throwable.getSuppressed()获取所有添加的Suppressed Exception。 自定义异常Java标准库定义的常用异常包括： 当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出IllegalArgumentException： static void process1(int age) { if (age &lt;= 0) { throw new IllegalArgumentException(); } } 在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： public class BaseException extends RuntimeException { } 其他业务类型的异常就可以从BaseException派生： public class UserNotFoundException extends BaseException { } public class LoginFailedException extends BaseException { } ... 自定义的BaseException应该提供多个构造方法： public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); } } 上述构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。 NullPointerException在所有的RuntimeException异常中，Java程序员最熟悉的恐怕就是NullPointerException了。 NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的。 public class Main { public static void main(String[] args) { String s = null; System.out.println(s.toLowerCase());//NullPointerException } } 处理NullPointerException如果遇到NullPointerException，我们应该如何处理？首先，必须明确，NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误。即调试发现有错后直接修改程序。 好的编码习惯可以极大地降低NullPointerException的产生： 1.成员变量在定义时初始化：使用空字符串&quot;&quot;而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串&quot;&quot;表示未填写比null安全得多。 public class Person { private String name = &quot;&quot;; } 2.返回空字符串&quot;&quot;、空数组而不是null： public String[] readLinesFromFile(String file) { if (getFileSize(file) == 0) { // 返回空数组而不是null: return new String[0]; } ... } 如果调用方一定要根据null判断，比如返回null表示文件不存在，那么考虑返回Optional： public Optional&lt;String&gt; readFromFile(String file) { if (!fileExist(file)) { return Optional.empty(); } ... } 这样调用方必须通过Optional.isPresent()判断是否有结果。 定位NullPointerException如果产生了NullPointerException，例如，调用a.b.c.x()时产生了NullPointerException，原因可能是： a是null； a.b是null； a.b.c是null； 确定到底是哪个对象是null以前只能打印这样的日志： System.out.println(a); System.out.println(a.b); System.out.println(a.b.c); 从Java 14开始，如果产生了NullPointerException，JVM可以给出详细的信息告诉我们null对象到底是谁,详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个-XX:+ShowCodeDetailsInExceptionMessages参数启用它： java -XX:+ShowCodeDetailsInExceptionMessages Main.java *使用断言断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。 我们先看一个例子： public static void main(String[] args) { double x = Math.abs(-123.45); assert x &gt;= 0; System.out.println(x); } 语句assert x &gt;= 0;即为断言，断言条件x &gt;= 0预期为true。如果计算结果为false，则断言失败，抛出AssertionError。 使用assert语句时，还可以添加一个可选的断言消息： assert x &gt;= 0 : &quot;x must &gt;= 0&quot;; 这样，断言失败的时候，AssertionError会带上消息x must &gt;= 0，更加便于调试。 Java断言的特点是：断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。 对于可恢复的程序错误，不应该使用断言。例如： void sort(int[] arr) { assert arr != null; } 应该抛出异常并在上层捕获： void sort(int[] arr) { if (x == null) { throw new IllegalArgumentException(&quot;array cannot be null&quot;); } } 当我们在程序中使用assert时，例如，一个简单的断言： // assert public class Main { public static void main(String[] args) { int x = -1; assert x &gt; 0; System.out.println(x); } } 断言x必须大于0，实际上x为-1，断言肯定失败。执行上述代码，发现程序并未抛出AssertionError，而是正常打印了x的值。 为什么assert语句不起作用？ 这是因为JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。 要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果： $ java -ea Main.java Exception in thread &quot;main&quot; java.lang.AssertionError at Main.main(Main.java:5) 还可以有选择地对特定地类启用断言，命令行参数是：-ea:com.itranswarp.sample.Main，表示只对com.itranswarp.sample.Main这个类启用断言。 或者对特定地包启用断言，命令行参数是：-ea:com.itranswarp.sample...（注意结尾有3个.），表示对com.itranswarp.sample这个包启动断言。 实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解JUnit的使用。 小结断言是一种调试方式，断言失败会抛出AssertionError，只能在开发和测试阶段启用断言； 对可恢复的错误不能使用断言，而应该抛出异常； 断言很少被使用，更好的方法是编写单元测试。 *使用JDK Logging在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用System.out.println()打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。 代码改好了怎么办？当然是删除没有用的System.out.println()语句了。 如果改代码又改出问题怎么办？再加上System.out.println()。 反复这么搞几次，很快大家就发现使用System.out.println()非常麻烦。 怎么办？ 解决方法是使用日志。 那什么是日志？日志就是Logging，它的目的是为了取代System.out.println()。 输出日志，而不是用System.out.println()，有以下几个好处： 可以设置输出样式，避免自己每次都写&quot;ERROR: &quot; + var； 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志； 可以被重定向到文件，这样可以在程序运行结束后查看日志； 可以按包名控制日志级别，只输出某些包打的日志； …… 如何使用日志？ 因为Java标准库内置了日志包java.util.logging，我们可以直接用。 public class Hello { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(&quot;start process...&quot;); logger.warning(&quot;memory is running out...&quot;); logger.fine(&quot;ignored.&quot;); logger.severe(&quot;process will be terminated...&quot;); } } 使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。 4条日志，只打印了3条，logger.fine()没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通： SEVERE WARNING INFO CONFIG FINE FINER FINEST 因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。 使用Java标准库内置的Logging有以下局限： Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置； 配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=。 因此，Java标准库内置的Logging使用并不是非常广泛。更方便的日志系统我们稍后介绍。 使用Commons Logging和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。 Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。 使用Commons Logging只需要和两个类打交道，并且只有两步： 第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打日志。 import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class Main { public static void main(String[] args) { Log log = LogFactory.getLog(Main.class); log.info(&quot;start...&quot;); log.warn(&quot;end.&quot;); } } 运行上述代码，肯定会得到编译错误，。因为Commons Logging是一个第三方提供的库，所以，必须先把它下载下来。下载后，解压，找到commons-logging-1.2.jar这个文件，再把Java源码Main.java放到一个目录下，例如work目录： work │ ├─ commons-logging-1.2.jar │ └─ Main.java 运行结果如下： Mar 02, 2019 7:15:31 PM Main main INFO: start... Mar 02, 2019 7:15:31 PM Main main WARNING: end. Commons Logging定义了6个日志级别： FATAL ERROR WARNING INFO DEBUG TRACE 默认级别是INFO。 在实例方法中引用Log，通常定义一个实例变量： // 在实例方法中引用Log: public class Person { protected final Log log = LogFactory.getLog(getClass()); void foo() { log.info(&quot;foo&quot;); } } 注意到实例变量log的获取方式是LogFactory.getLog(getClass())，虽然也可以用LogFactory.getLog(Person.class)，但是前一种方式有个非常大的好处，就是子类可以直接使用该log实例。 // 在子类中使用父类实例化的log: public class Student extends Person { void bar() { log.info(&quot;bar&quot;); } } 此外，Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单： try { ... } catch (Exception e) { log.error(&quot;got exception!&quot;, e); } 小结Commons Logging是使用最广泛的日志模块； Commons Logging的API非常简单； Commons Logging可以自动检测并使用其他日志模块。 使用Log4jCommons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。 Log4j是一种非常流行的日志框架，最新版本是2.x。 Log4j是一个组件化设计的日志系统，它的架构大致如下： log.info(&quot;User signed in.&quot;); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如： console：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。 上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。 以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Configuration&gt; &lt;Properties&gt; &lt;!-- 定义日志格式 --&gt; &lt;Property name=&quot;log.pattern&quot;&gt;%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n&lt;/Property&gt; &lt;!-- 定义文件名变量 --&gt; &lt;Property name=&quot;file.err.filename&quot;&gt;log/err.log&lt;/Property&gt; &lt;Property name=&quot;file.err.pattern&quot;&gt;log/err.%i.log.gz&lt;/Property&gt; &lt;/Properties&gt; &lt;!-- 定义Appender，即目的地 --&gt; &lt;Appenders&gt; &lt;!-- 定义输出到屏幕 --&gt; &lt;Console name=&quot;console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!-- 日志格式引用上面定义的log.pattern --&gt; &lt;PatternLayout pattern=&quot;${log.pattern}&quot; /&gt; &lt;/Console&gt; &lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt; &lt;RollingFile name=&quot;err&quot; bufferedIO=&quot;true&quot; fileName=&quot;${file.err.filename}&quot; filePattern=&quot;${file.err.pattern}&quot;&gt; &lt;PatternLayout pattern=&quot;${log.pattern}&quot; /&gt; &lt;Policies&gt; &lt;!-- 根据文件大小自动切割日志 --&gt; &lt;SizeBasedTriggeringPolicy size=&quot;1 MB&quot; /&gt; &lt;/Policies&gt; &lt;!-- 保留最近10份 --&gt; &lt;DefaultRolloverStrategy max=&quot;10&quot; /&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;info&quot;&gt; &lt;!-- 对info级别的日志，输出到console --&gt; &lt;AppenderRef ref=&quot;console&quot; level=&quot;info&quot; /&gt; &lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt; &lt;AppenderRef ref=&quot;err&quot; level=&quot;error&quot; /&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;/Configuration&gt; 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从这里下载Log4j，解压后，把以下3个jar包放到classpath中： log4j-api-2.x.jar log4j-core-2.x.jar log4j-jcl-2.x.jar 因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的commons-logging-1.2.jar也放到classpath中。 要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出 最佳实践在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入classpath，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。 小结通过Commons Logging实现日志，不需要修改代码即可使用Log4j； 使用Log4j只需要把log4j2.xml和相关jar放入classpath； 如果要更换Log4j，只需要移除log4j2.xml和相关jar； 只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。","categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"java","slug":"java","permalink":"/categories/java/"}]},{"title":"Java教程笔记之Maven基础","slug":"Java教程笔记之Maven基础","date":"2020-06-10T16:28:11.000Z","updated":"2020-06-10T16:31:03.437Z","comments":true,"path":"2020/06/11/Java教程笔记之Maven基础/","link":"","permalink":"/2020/06/11/Java教程笔记之Maven基础/","excerpt":"","text":"maven学习结合maven教程,廖雪峰的官方网站以及慕课的学习资料总结。 Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。 Maven介绍在了解Maven之前，我们先来看看一个Java项目需要的东西。 首先，我们需要确定引入哪些依赖包。如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。 其次，我们要确定项目的目录结构。例如，src目录存放Java源码，resources目录存放配置文件，bin目录存放编译生成的.class文件。 此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。 最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。 这些工作非常琐碎耗时,我们需要一个标准化的Java项目管理和构建工具。 Maven就是专门为Java项目打造的管理和构建工具，它的主要功能有： 提供了一套标准化的项目结构； 提供了一套标准化的构建流程（编译，测试，打包，发布……）； 提供了一套依赖管理机制。 Maven项目结构一个使用Maven管理的普通Java项目，它的目录结构默认如下： 项目的根目录a-maven-project是项目名，它有一个项目核心配置文件pom.xml。 存放Java源码的目录是src/main/java，存放项目资源文件(如spring, hibernate配置文件)的目录是src/main/resources 存放测试源码的目录是src/test/java，存放测试资源的目录是src/test/resources 所有编译、打包生成的文件都放在target目录，如.class、.jar、.war文件 这些就是一个Maven项目的标准目录结构。 所有的目录结构都是约定好的标准结构，我们不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。 我们再来看最关键的一个项目描述文件pom.xml，它的内容长得像下面： &lt;project ...&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; ... &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。 使用&lt;dependency&gt;声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。 安装Maven要安装Maven，可以从Maven官网下载最新的Maven 3.6.x，然后在本地解压，设置几个环境变量，可参考Maven 环境配置 然后，打开命令行窗口，输入mvn -version，应该看到Maven的版本信息： 如果提示命令未找到，说明系统PATH路径有误，需要修复后再运行。 小结Maven是一个Java项目的管理和构建工具： Maven使用pom.xml定义项目内容，并使用预设的目录结构； 在Maven中声明一个依赖项可以自动下载并导入classpath； Maven使用groupId，artifactId和version唯一定位一个依赖。 依赖管理Maven解决了依赖管理问题。例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包： 当我们声明了abc的依赖时，Maven自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。 因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的jar包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。我们来看一个复杂依赖示例： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 当我们声明一个spring-boot-starter-web依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖： spring-boot-starter-web spring-boot-starter spring-boot sprint-boot-autoconfigure spring-boot-starter-logging logback-classic logback-core slf4j-api jcl-over-slf4j slf4j-api jul-to-slf4j slf4j-api log4j-over-slf4j slf4j-api spring-core snakeyaml spring-boot-starter-tomcat tomcat-embed-core tomcat-embed-el tomcat-embed-websocket tomcat-embed-core jackson-databind ... 如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。 依赖关系Maven定义了几种依赖关系，分别是compile、test、runtime和provided： scope 说明 示例 compile 编译时需要用到该jar包（默认） commons-logging test 编译Test时需要用到该jar包 junit runtime 编译时不需要，但运行时需要用到 mysql provided 编译时需要用到，但运行时由JDK或某个服务器提供 servlet-api 默认的compile是最常用的，Maven会把这种类型的依赖直接放入classpath。 test依赖表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是JUnit： &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; runtime依赖表示编译时不需要，但运行时需要。最典型的runtime依赖是JDBC驱动，例如MySQL驱动： &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; provided依赖表示编译时需要，但运行时不需要。最典型的provided依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要： &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。 Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。 唯一ID对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包： groupId：属于组织名称，类似Java包名； artifactId：该jar包自身的名称，类似Java类名； version：该jar包的版本。 通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。 因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。 注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。 Maven镜像除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步： 中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录(Window : C:\\Users\\xxx.m2)下进入.m2目录，创建一个settings.xml配置文件，内容如下： &lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 国内推荐阿里云的Maven镜像 --&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt; 配置镜像仓库后，Maven的下载速度就会非常快。 搜索第三方组件最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制 构建流程Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。 Lifecycle和Phase使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。 Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase： validateinitializegenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resourcescompileprocess-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resourcestest-compileprocess-test-classestestprepare-packagepackagepre-integration-testintegration-testpost-integration-testverifyinstalldeploy 如果我们运行mvn package，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止： validate … package 如果我们运行mvn compile，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase： validate … compile Maven另一个常用的生命周期是clean，它会执行3个phase： pre-clean clean （注意这个clean不是lifecycle而是phase） post-clean 所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。 更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下： pre-clean clean （注意这个clean是phase） validate … package 在实际开发过程中，经常使用的命令有： mvn clean：清理所有生成的class和jar； mvn clean compile：先清理，再执行到compile； mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile； mvn clean package：先清理，再执行到package。 大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。 经常用到的phase其实只有几个： clean：清理 compile：编译 test：运行测试 package：打包 Goal执行一个phase又会触发一个或多个goal： 执行的Phase 对应执行的Goal compile compiler:compile test compiler:testCompile surefire:test goal的命名总是abc:xyz这种形式。 lifecycle相当于Java的package，它包含一个或多个phase； phase相当于Java的class，它包含一个或多个goal； goal相当于class的method，它其实才是真正干活的。 大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器： mvn tomcat:run 小结Maven通过lifecycle、phase和goal来提供标准的构建流程。 最常用的构建命令是指定phase，然后让Maven执行到指定的phase： mvn clean mvn clean compile mvn clean test mvn clean package 通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。 使用插件我们在前面介绍了Maven的lifecycle，phase和goal：使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。每个phase会执行自己默认的一个或多个goal。goal是最小任务单元。 我们以compile这个phase为例，如果执行： mvn compile Maven将执行compile这个phase，这个phase会调用compiler插件执行关联的compiler:compile这个goal。 实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行compile，它只是负责找到对应的compiler插件，然后执行默认的compiler:compile这个goal来完成编译。 所以，使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。 Maven已经内置了一些常用的标准插件： 插件名称 对应执行的phase clean clean compiler compile surefire test jar package 如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用maven-shade-plugin可以创建一个可执行的jar，要使用这个插件，需要在pom.xml中声明它： &lt;project&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; ... &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定Java程序的入口，它的配置是： &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;com.itranswarp.learnjava.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; 注意，Maven自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明。 下面列举了一些常用的插件： maven-shade-plugin：打包所有依赖包并生成可执行jar； cobertura-maven-plugin：生成单元测试覆盖率报告； findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。 模块管理在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法： 对于Maven工程来说，原来是一个大项目： 现在可以分拆成3个模块： Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-a&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-a&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 模块B的pom.xml： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-b&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-b&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;parent&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 注意到parent的是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;module-a&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-a&lt;/name&gt; &lt;/project&gt; 模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。 如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B： ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-b&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 最后，在编译的时候，需要在根目录创建一个pom.xml统一编译： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;build&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;build&lt;/name&gt; &lt;modules&gt; &lt;module&gt;parent&lt;/module&gt; &lt;module&gt;module-a&lt;/module&gt; &lt;module&gt;module-b&lt;/module&gt; &lt;module&gt;module-c&lt;/module&gt; &lt;/modules&gt; &lt;/project&gt; 这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个，一次性全部编译。 中央仓库其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。 私有仓库私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。 本地仓库本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Java教程笔记之面向对象编程","slug":"Java教程笔记之面向对象编程","date":"2020-06-09T14:24:27.000Z","updated":"2020-06-10T04:35:55.843Z","comments":true,"path":"2020/06/09/Java教程笔记之面向对象编程/","link":"","permalink":"/2020/06/09/Java教程笔记之面向对象编程/","excerpt":"","text":"重新学一遍Java,结合以前的笔记，内容主要摘自廖雪峰的官方网站,感谢分享。 Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。 和面向对象编程不同的，是面向过程编程。面向过程编程，是把模型分解成一步一步的过程。而面向对象编程，顾名思义，你得首先有个对象,有了对象后，就可以和对象进行互动： GirlFriend gf = new GirlFriend(); gf.name = &quot;Alice&quot;; gf.send(&quot;flowers&quot;); 面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。 面向对象基础class和instanceclass是一种对象模版，它定义了如何创建实例。class本身就是一种数据类型 instance是对象实例，instance是根据class创建的实例。可以创建多个instance，每个instance类型相同，但各自属性可能不相同 定义class在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： class Person { public String name; public int age; } 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 创建实例定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： Person ming = new Person(); 注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。我们可以通过这个指向实例的变量来操作实例。访问实例变量可以用变量.字段，例如： Person ming = new Person(); ming.name = &quot;Xiao Ming&quot;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = &quot;Xiao Hong&quot;; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： ┌──────────────────┐ ming ──────&gt;│Person instance │ ├──────────────────┤ │name = &quot;Xiao Ming&quot;│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────&gt;│Person instance │ ├──────────────────┤ │name = &quot;Xiao Hong&quot;│ │age = 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 小结在OOP中，class和instance是“模版”和“实例”的关系； 定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例； class定义的field，在每个instance都会拥有各自的field，且互不干扰； 通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance； 访问实例字段的方法是变量名.字段名；指向instance的变量都是引用变量。 方法一个class可以包含多个field，为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问。外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？ 我们需要使用方法（method）来让外部代码可以间接修改field public class Main { public static void main(String[] args) { Person ming =new Person(); ming.setName(&quot;zhang san&quot;); ming.setAge(12); System.out.print(ming.getName()+&quot;: &quot;+ming.getAge()); } } class Person{ private String name; private int age; public String getName() { return name; } public void setName(String name) { if (name == null || name.isBlank()){//不允许传入null和空字符串 throw new IllegalArgumentException(&quot;invalid name&quot;); } this.name = name.strip();//去掉首尾空格 } public int getAge() { return age; } public void setAge(int age) { if (age &lt; 0 || age &gt; 100) { throw new IllegalArgumentException(&quot;invalid age value&quot;); } this.age = age; } } 虽然外部代码不能直接修改private字段，但是，外部代码可以调用方法setName()和setAge()来间接修改private字段。在方法内部，我们就有机会检查参数对不对。 所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。 调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加; 定义方法定义方法的语法是： 修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法private方法不允许外部调用，内部方法可以调用。 this变量在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。通过this.field就可以访问当前实例的字段。 如果没有命名冲突，可以省略this。 class Person { private String name; public String getName() { return name; // 相当于this.name } } 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this： class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 } } 方法参数方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如： class Person { ... public void setNameAndAge(String name, int age) { ... } } 用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int： Person ming = new Person(); ming.setNameAndAge(&quot;Xiao Ming&quot;); // 编译错误：参数个数不对 ming.setNameAndAge(12, &quot;Xiao Ming&quot;); // 编译错误：参数类型不对 可变参数可变参数用类型...定义，可变参数相当于数组类型： class Group { private String[] names; public void setNames(String... names) { this.names = names; } } 调用时，可以这么写： Group g = new Group(); g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个String g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个String g.setNames(&quot;Xiao Ming&quot;); // 传入1个String g.setNames(); // 传入0个String 完全可以把可变参数改写为String[]类型： class Group { private String[] names; public void setNames(String[] names) { this.names = names; } } 但是，调用方需要自己先构造String[]，比较麻烦。例如： Group g = new Group(); g.setNames(new String[] {&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;}); // 传入1个String[] 另一个问题是，调用方可以传入null,而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。 参数绑定基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 // 基本类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15还是20?15 } } class Person { private int age; public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } } 引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。 // 引用类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { &quot;Homer&quot;, &quot;Simpson&quot; }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // &quot;Homer Simpson&quot; fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot; System.out.println(p.getName()); // &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;? } } class Person { private String[] name; public String getName() { return this.name[0] + &quot; &quot; + this.name[1]; } public void setName(String[] name) { this.name = name; } } 构造方法创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化： public class Main { public static void main(String[] args) { Person p = new Person(&quot;Xiao Ming&quot;, 15); System.out.println(p.getName()); System.out.println(p.getAge()); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。 默认构造方法如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样： class Person { public Person() { } } 如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法： public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来： public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： class Person { private String name; // 默认初始化为null private int age; // 默认初始化为0 public Person() { } } 在Java中，创建对象实例的时候，按照如下顺序进行初始化： 先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null； 执行构造方法的代码进行初始化。 因此，构造方法的代码由于后运行，所以，new Person(&quot;Xiao Ming&quot;, 12)的字段值最终由构造方法的代码确定。 多构造方法可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { } } 如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person()。 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(&quot;Unnamed&quot;); // 调用另一个构造方法Person(String) } } 方法重载方法名相同，但各自的参数不同，称为方法重载（Overload）。 注意：方法重载的返回值类型通常都是相同的。 方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 举个例子，String类提供了多个重载方法indexOf()，可以查找子串： int indexOf(int ch)：根据字符的Unicode码查找； int indexOf(String str)：根据字符串查找； int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置； int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置。 继承在前面的章节中，我们已经定义了Person类： class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } 现在，假设需要定义一个Student类，字段如下： class Student { private String name; private int age; private int score; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} public int getScore() { … } public void setScore(int score) { … } } 仔细观察，发现Student类包含了Person类已有的字段和方法，只是多出了一个score字段和相应的getScore()、setScore()方法。 能不能在Student中不要写重复的代码？ 这个时候，继承就派上用场了。 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 Java使用extends关键字来实现继承： class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … } } 通过继承，Student只需要编写额外的功能，不再需要重复代码。 注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！ 在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 继承树注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ │ ┌───────────┐ │ Student │ └───────────┘ Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ ▲ │ │ │ │ ┌───────────┐ ┌───────────┐ │ Student │ │ Teacher │ └───────────┘ └───────────┘ protected继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段： class Person { private String name; private int age; } class Student extends Person { public String hello() { return &quot;Hello, &quot; + name; // 编译错误：无法访问name字段 } } 这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问。 因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。 supersuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如： class Student extends Person { public String hello() { return &quot;Hello, &quot; + super.name; } } 在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super(); public class Main { public static void main(String[] args) { Student s = new Student(&quot;Xiao Ming&quot;, 12, 89); } } class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; } } class Student extends Person { protected int score; public Student(String name, int age, int score) { this.score = score; } } 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。 Student类的构造方法实际上是这样： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(); // 自动调用父类的构造方法 this.score = score; } } 但是，Person类并没有无参数的构造方法，因此，编译失败。 解决方法是调用Person类存在的某个构造方法。例如： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 调用父类的构造方法Person(String, int) this.score = score; } } 这样就可以正常编译了！ 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 向上转型如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例： Student s = new Student(); 如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例： Person p = new Person(); 现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？ Person p = new Student(); // ??? 测试一下就可以发现，这种指向是允许的！ 这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 Student s = new Student(); Person p = s; // upcasting, ok Object o1 = p; // upcasting, ok Object o2 = s; // upcasting, ok 注意到继承树是Student &gt; Person &gt; Object，所以，可以把Student类型转型为Person，或者更高层次的Object。 向下转型和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如： Person p1 = new Student(); // upcasting, ok Person p2 = new Person(); Student s1 = (Student) p1; // ok Student s2 = (Student) p2; // runtime error! ClassCastException! 不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。 为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型。 instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。 利用instanceof，在向下转型前可以先判断： Person p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 } 区分继承和组合在使用继承时，我们要注意逻辑一致性。继承是is关系，组合是has关系。 具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例： class Student extends Person { protected Book book; protected int score; } 多态在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 例如，在Person类中，我们定义了run()方法： class Person { public void run() { System.out.println(&quot;Person.run&quot;); } } 在子类Student中，覆写这个run()方法： class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } Override和Overload不同的是，方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。 class Person { public void run() { … } } class Student extends Person { // 不是Override，因为参数不同: public void run(String s) { … } // 不是Override，因为返回值不同: public int run() { … } } 加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错，但是@Override不是必需的。 已经知道，引用变量的声明类型可能与其实际类型不符，例如： Person p = new Student(); 如果子类覆写了父类的方法,例如student复写了person的方法，那么，一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？： public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); // 应该打印Person.run还是Student.run? } } class Person { public void run() { System.out.println(&quot;Person.run&quot;); } } class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } 运行一下上面的代码就可以知道，实际上调用的方法是Student的run()方法。因此可得出结论： Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。 这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： public void runTwice(Person p) { p.run(); p.run(); } 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。 多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。 这种不确定性的方法调用，究竟有什么作用？ 假设我们定义一种收入，需要给它报税，那么先定义一个Income类： class Income { protected double income; public double getTax() { return income * 0.1; // 税率10% } } 对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()： class Salary extends Income { @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; } } 如果你享受国务院特殊津贴，那么按照规定，可以全部免税： class StateCouncilSpecialAllowance extends Income { @Override public double getTax() { return 0; } } 现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写： public double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } 来试一下（给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税）： public class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } } class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% } } class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; } } class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; } } 利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 覆写Object方法因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 在必要的情况下，我们可以覆写Object的这几个方法。例如： class Person { ... // 显示更有意义的字符串: @Override public String toString() { return &quot;Person:name=&quot; + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); } } 调用super在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。 class Person { protected String name; public String hello() { return &quot;Hello, &quot; + name; } } Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + &quot;!&quot;; } } final继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： class Person { protected String name; public final String hello() { return &quot;Hello, &quot; + name; } } 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： final class Person { protected String name; } // compile error: 不允许继承自Person Student extends Person { } 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。例如： class Person { public final String name = &quot;Unamed&quot;; //对final字段重新赋值会报错 } 可以在构造方法中初始化final字段： class Person { public final String name; public Person(String name) { this.name = name; } } 这种方法更为常用，因为可以保证实例一旦创建，其final字段就不可修改。 小结： 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为； Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态； final修饰符有多种作用： final修饰的方法可以阻止被覆写； final修饰的class可以阻止被继承； final修饰的field必须在创建对象时初始化，随后不可修改。 抽象类由于多态的存在，每个子类都可以覆写父类的方法，如果父类的方法没有实际意义，能否去掉方法的执行语句？答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。能不能去掉父类的方法？答案还是不行，因为去掉父类的方法，就失去了多态的特性。 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： class Person {//无法编译 public abstract void run(); } 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： abstract class Person { public abstract void run(); } 抽象类如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： Person p = new Person(); // 编译错误 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); } } abstract class Person { public abstract void run(); } class Student extends Person { @Override public void run() { System.out.println(&quot;Student.run&quot;); } } 抽象类的使用要点: 有抽象方法的类只能定义成抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承， 抽象方法必须被子类实现。 面向抽象编程当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： Person s = new Student(); Person t = new Teacher(); 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： // 不关心Person变量的具体子类型: s.run(); t.run(); 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： // 同样不关心新的子类是如何实现run()方法的： Person e = new Employee(); e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 小结 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范； 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法； 如果不实现抽象方法，则该子类仍是一个抽象类； 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。 接口在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： abstract class Person { public abstract void run(); public abstract String getName(); } 就可以把该抽象类改写为接口：interface。在Java中，使用interface可以声明一个接口： interface Person { void run(); String getName(); } 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + &quot; run&quot;); } @Override public String getName() { return this.name; } } 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： class Student implements Person, Hello { // 实现了两个interface ... } 术语Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 抽象类和接口的对比如下： abstract class interface 继承 只能extends一个class 可以implements多个interface 字段 可以定义实例字段 不能定义实例字段 抽象方法 可以定义抽象方法 可以定义抽象方法 非抽象方法 可以定义非抽象方法 可以定义default方法 接口继承一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： interface Hello { void hello(); } interface Person extends Hello { void run(); String getName(); } 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 继承关系合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。 可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系： 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象： List list = new ArrayList(); // 用List接口引用具体子类的实例 Collection coll = list; // 向上转型为Collection接口 Iterable it = coll; // 向上转型为Iterable接口 default方法实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 public class Main { public static void main(String[] args) { Person p = new Student(&quot;Xiao Ming&quot;); p.run(); } } interface Person { String getName(); default void run() { System.out.println(getName() + &quot; run&quot;); } } class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; } } 静态字段和静态方法在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子： class Person { public String name; public int age; // 定义静态字段number: public static int number; } 我们来看看下面的代码： public class Main { public static void main(String[] args) { Person ming = new Person(&quot;Xiao Ming&quot;, 12); Person hong = new Person(&quot;Xiao Hong&quot;, 15); ming.number = 88; System.out.println(hong.number); //88 hong.number = 99; System.out.println(ming.number); //99 } } class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; } } 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例： 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： Person.number = 99; System.out.println(Person.number); 静态方法有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如： public class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); } } class Person { public static int number; public static void setNumber(int value) { number = value; } } 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 静态方法经常用于工具类。例如： Arrays.sort() Math.random() 静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。 接口的静态字段因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： public interface Person { public static final int MALE = 1; public static final int FEMALE = 2; } 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2; } 编译器会自动把该字段变为public static final类型。 小结 静态字段属于所有实例“共享”的字段，实际上是属于class的字段； 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法； 静态方法常用于工具类和辅助方法。 包在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 例如： 小明的Person类存放在包ming下面，因此，完整类名是ming.Person； 小红的Person类存放在包hong下面，因此，完整类名是hong.Person； 小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays； JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays。 在定义class的时候，我们需要在第一行声明这个class属于哪个包。 小明的Person.java文件： package ming; // 申明包名ming public class Person { } 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。 包可以是多层结构，用.隔开。例如：java.util。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是: package_sample └─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致。 包作用域位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： package hello; public class Person { // 包作用域: void hello() { System.out.println(&quot;Hello!&quot;); } } Main类也定义在hello包下面： package hello; public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 } } import在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法： 第一种，直接写出完整类名mr.jun.Arrays arrays = new mr.jun.Arrays(); 第二种写法是用import语句，导入小军的Arrays，然后写简单类名： package ming; // 导入完整类名: import mr.jun.Arrays; public class Person { public void run() { Arrays arrays = new Arrays(); } } 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）：import mr.jun.*;我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 还有一种import static的语法，它可以导入一个类的静态字段和静态方法： ackage main; // 导入System类的所有静态字段和静态方法: import static java.lang.System.*; public class Main { public static void main(String[] args) { // 相当于调用System.out.println(…) out.println(&quot;Hello, world!&quot;); } } import static很少使用。 Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 // Main.java package test; import java.text.Format; public class Main { public static void main(String[] args) { java.util.List list; // ok，使用完整类名 -&gt; java.util.List Format format = null; // ok，使用import的类 -&gt; java.text.Format String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type } } 编写class的时候，编译器会自动帮我们做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。 如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 最佳实践为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。 子包可以根据功能自行命名，如org.apache. commons.log 要注意不要和java.lang包的类重名,注意也不要和JDK常用类重名 小结Java内建的package机制是为了避免class命名冲突； JDK的核心类使用java.lang包，编译器会自动导入； JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，……； 包名推荐使用倒置的域名，例如org.apache。 作用域 定义为public的class、interface可以被其他任何类访问 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限 定义为private的field、method无法被其他类访问,确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法.由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限。 public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(&quot;private hello!&quot;); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } } } protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 default只要在同一个包，就可以访问package(default)权限的class、field和method 小结Java内建的访问权限包括public、protected、private和package(default)权限； Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束； final修饰符不是访问权限，它可以修饰class、field和method； 一个.java文件只能包含一个public类，但可以包含多个非public类。 面向对象的内存分析Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。 栈的特点如下： 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 堆的特点如下： 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点如下： JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 垃圾回收机制垃圾回收机制（Garbage Collection） 针对内存管理问题，Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配：使用new关键字创建对象即可 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情： 发现无用的对象 无用的对象指的就是没有任何变量引用该对象 回收无用对象占用的内存空间 Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理 垃圾回收相关算法引用计数法 堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。 public class Student { String name; Student friend; public static void main(String[] args) { Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; } } s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。 引用可达法(根搜索算法) 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 通用的分代垃圾回收机制将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。 Minor GC:用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) Major GC：用于清理老年代区域。 Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 清理过程 创建新对象，大多数放在Eden区 Eden满了（或达到一定比例），触发Minor GC, 把有用的复制到Survivor1, 同时清空Eden区。 Eden区再次满了，出发Minor GC, 把Eden和Survivor1中有用的，复制到Survivor2, 同时清空Eden，Survivor1。 Eden区第三次满了，出发Minor GC, 把Eden和Survivor2中有用的，复制到Survivor1, 同时清空Eden，Survivor2。形成循环，Survoivor1和Survivor2中来回清空、复制，过程中有一个Survivor处于空的状态用于下次复制的。 重复多次（默认15），没有被Survivor清理的对象，复制到Old（Tenuerd）区。 当Old达到一定比例，触发Major GC，清理老年代。 当Old满了，触发Full 。注意，Full GC清理代价大，系统资源消耗高。 Java核心类本节我们将介绍Java的核心类，包括：字符串、StringBuilder、StringJoiner、包装类型、JavaBean、枚举、常用工具类 字符串和编码String在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用&quot;...&quot;来表示一个字符串： String s1 = &quot;Hello!&quot;; 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的： String s2 = new String(new char[] {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;}); 因为String太常用了，所以Java提供了&quot;...&quot;这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 public class Main { public static void main(String[] args) { String s = &quot;Hello&quot;; System.out.println(s); //Hello s = s.toUpperCase(); System.out.println(s); //HELLO,S重新指向了新的字符串 } } 字符串比较当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。 public class Main { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; System.out.println(s1 == s2); \\\\true System.out.println(s1.equals(s2)); \\\\true } } 表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 所以，这种==比较返回true纯属巧合。换一种写法，==比较就会失败：String s2 = &quot;HELLO&quot;.toLowerCase(); 结论：两个字符串比较，必须总是使用equals()方法。要忽略大小写比较，使用equalsIgnoreCase()方法。 String类还提供了多种方法来搜索子串、提取子串。常用的方法有： // 搜索子串: &quot;Hello&quot;.contains(&quot;ll&quot;); // true &quot;Hello&quot;.indexOf(&quot;l&quot;); // 2 &quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3 &quot;Hello&quot;.startsWith(&quot;He&quot;); // true &quot;Hello&quot;.endsWith(&quot;lo&quot;); // true //提取子串： &quot;Hello&quot;.substring(2); // &quot;llo&quot; &quot;Hello&quot;.substring(2, 4);// &quot;ll&quot; [)的关系 去除首尾空白字符使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n： &quot; \\tHello\\r\\n &quot;.trim(); // &quot;Hello&quot; 注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。 另一个strip()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除： &quot;\\u3000Hello\\u3000&quot;.strip(); // &quot;Hello&quot; &quot; Hello &quot;.stripLeading(); // &quot;Hello &quot; &quot; Hello &quot;.stripTrailing(); // &quot; Hello&quot; String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串： &quot;&quot;.isEmpty(); // true，因为字符串长度为0 &quot; &quot;.isEmpty(); // false，因为字符串长度不为0 &quot; \\n&quot;.isBlank(); // true，因为只包含空白字符 &quot; Hello &quot;.isBlank(); // false，因为包含非空白字符 替换子串要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换： String s = &quot;hello&quot;; s.replace(&#39;l&#39;, &#39;w&#39;); // &quot;hewwo&quot;，所有字符&#39;l&#39;被替换为&#39;w&#39; s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot; 另一种是通过正则表达式替换： String s = &quot;A,,B;C ,D&quot;; s.replaceAll(&quot;[\\\\,\\\\;\\\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot; 上面的代码通过正则表达式，把匹配的子串统一替换为&quot;,&quot;。关于正则表达式的用法我们会在后面详细讲解。 分割字符串要分割字符串，使用split()方法，并且传入的也是正则表达式： String s = &quot;A,B,C,D&quot;; String[] ss = s.split(&quot;\\\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;} 拼接字符串拼接字符串使用静态方法join()，它用指定的字符串连接字符串数组： String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}; String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; 格式化字符串字符串提供了formatted()方法和format()静态方法，可以传入其他参数，替换占位符，然后生成新的字符串： public class Main { public static void main(String[] args) { String s = &quot;Hi %s, your score is %d!&quot;; System.out.println(s.formatted(&quot;Alice&quot;, 80)); System.out.println(String.format(&quot;Hi %s, your score is %.2f!&quot;, &quot;Bob&quot;, 59.5)); } } 有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有： %s：显示字符串； %d：显示整数； %x：显示十六进制整数； %f：显示浮点数。 占位符还可以带格式，例如%.2f表示显示两位小数。如果你不确定用啥占位符，那就始终用%s，因为%s可以显示任何数据类型。 类型转换要把任意基本类型或引用类型转换为字符串，可以使用静态方法valueOf()。这是一个重载方法，编译器会根据参数自动选择合适的方法： String.valueOf(123); // &quot;123&quot; String.valueOf(45.67); // &quot;45.67&quot; String.valueOf(true); // &quot;true&quot; String.valueOf(new Object()); // 类似java.lang.Object@636be97c 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为int类型： int n1 = Integer.parseInt(&quot;123&quot;); // 123 int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255 把字符串转换为boolean类型： boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false 转换为char[]String和char[]类型可以互相转换，方法是： char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[] String s = new String(cs); // char[] -&gt; String 如果修改了char[]数组，String并不会改变 public class Main { public static void main(String[] args) { char[] cs = &quot;Hello&quot;.toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = &#39;X&#39;; System.out.println(s); } } 这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。 字符编码ASCII编码占用一个字节，编码范围从0到127，最高位始终为0。例如，字符&#39;A&#39;的编码是0x41，字符&#39;1&#39;的编码是0x31。 把汉字也纳入计算机编码，很显然一个字节不够。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字&#39;中&#39;的GB2312编码是0xd6d0。 类似的，日文有Shift_JIS编码，这些编码因为标准不统一，同时使用，就会产生冲突。为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。 Unicode编码需要两个或者更多字节表示，我们可以比较中英文字符在ASCII、GB2312和Unicode的编码： 英文字符&#39;A&#39;的ASCII编码和Unicode编码： ┌────┐ ASCII: │ 41 │ └────┘ ┌────┬────┐ Unicode: │ 00 │ 41 │ └────┴────┘ 英文字符的Unicode编码就是简单地在前面添加一个00字节。 中文字符&#39;中&#39;的GB2312编码和Unicode编码： ┌────┬────┐ GB2312: │ d6 │ d0 │ └────┴────┘ ┌────┬────┐ Unicode: │ 4e │ 2d │ └────┴────┘ 因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符&#39;A&#39;的UTF-8编码变为0x41，正好和ASCII码一致，而中文&#39;中&#39;的UTF-8编码为3字节0xe4b8ad。 UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。 在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做： byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐 byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换 byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换 byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 注意：转换编码后，就不再是char类型，而是byte类型表示的数组。 如果要把已知编码的byte[]转换为String，可以这样做： byte[] b = ... String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换 String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 始终牢记：Java的String和char在内存中总是以Unicode编码表示。 小结 Java字符串String是不可变对象； 字符串操作不改变原字符串内容，而是返回新字符串； 常用的字符串操作：提取子串、查找、替换、大小写转换等； Java使用Unicode编码表示String和char； 转换编码就是将String和byte[]转换，需要指定编码； 转换为byte[]时，始终优先考虑UTF-8编码。 StringBuilderJava编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。 考察下面的循环代码： String s = &quot;&quot;; for (int i = 0; i &lt; 1000; i++) { s = s + &quot;,&quot; + i; } 虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： StringBuilder sb = new StringBuilder(1024); for (int i = 0; i &lt; 1000; i++) { sb.append(&#39;,&#39;); sb.append(i); } String s = sb.toString(); StringBuilder还可以进行链式操作： public class Main { public static void main(String[] args) { var sb = new StringBuilder(1024);//类型的名字太长，写起来比较麻烦,如果想省略变量类型，可以使用var关键字,编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder sb.append(&quot;Mr &quot;) .append(&quot;Bob&quot;) .append(&quot;!&quot;) .insert(0, &quot;Hello, &quot;); System.out.println(sb.toString()); //Hello, Mr Bob! } } 如果我们查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。 仿照StringBuilder，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器： public class Main { public static void main(String[] args) { Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value());//19 } } class Adder { private int sum = 0; public Adder add(int n) { sum += n; return this; } public Adder inc() { sum ++; return this; } public int value() { return sum; } } 注意：对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。 StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。 StringJoiner用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事： public class Main { public static void main(String[] args) { String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; var sj = new StringJoiner(&quot;, &quot;); //需要给StringJoiner指定“开头”和“结尾”： var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;); for (String name : names) { sj.add(name); } System.out.println(sj.toString());//Bob, Alice, Grace System.out.println(sj.toString());//Hello Bob, Alice, Grace! } } 查看源码，可以发现，StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。 String.join()String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便： String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; var s = String.join(&quot;, &quot;, names); 包装类型Java的数据类型分两种： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： String s = null; int n = null; // compile error! 如何把一个基本类型视为对象（引用类型）？ 比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）： public class Integer { private int value; public Integer(int value) { this.value = value; } public int intValue() { return this.value; } } 定义好了Integer类，我们就可以把int和Integer互相转换： Integer n = null; Integer n2 = new Integer(99); int n3 = n2.intValue(); 实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 我们可以直接使用，并不需要自己去定义： public class Main { public static void main(String[] args) { int i = 100; // 通过new操作符创建Integer实例(不推荐使用,会有编译警告): Integer n1 = new Integer(i); // 通过静态方法valueOf(int)创建Integer实例: Integer n2 = Integer.valueOf(i); // 通过静态方法valueOf(String)创建Integer实例: Integer n3 = Integer.valueOf(&quot;100&quot;); System.out.println(n3.intValue()); } } Auto BoxingJava编译器可以帮助我们自动在int和Integer之间转型： Integer n = 100; // 编译器自动使用Integer.valueOf(int) int x = n; // 编译器自动使用Integer.intValue() 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException。 不变类所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下： public final class Integer { private final int value; } 因此，一旦创建了Integer对象，该对象就是不变的。 对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较 public class Main { public static void main(String[] args) { Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(&quot;x == y: &quot; + (x==y)); // true System.out.println(&quot;m == n: &quot; + (m==n)); // false System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true } } 较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 进制转换最常用的静态方法parseInt()可以把字符串解析成一个整数： int x1 = Integer.parseInt(&quot;100&quot;); // 100 int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析 Integer还可以把整数格式化为指定进制的字符串： public class Main { public static void main(String[] args) { System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制 System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制 System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制 System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制 System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制 } } 注意：上述方法的输出都是String 我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。 这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。 Java的包装类型还定义了一些有用的静态变量 // boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段: Boolean t = Boolean.TRUE; Boolean f = Boolean.FALSE; // int可表示的最大/最小值: int max = Integer.MAX_VALUE; // 2147483647 int min = Integer.MIN_VALUE; // -2147483648 // long类型占用的bit和byte数量: int sizeOfLong = Long.SIZE; // 64 (bits) int bytesOfLong = Long.BYTES; // 8 (bytes) 最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： // 向上转型为Number: Number num = new Integer(999); // 获取byte, int, long, float, double: byte b = num.byteValue(); int n = num.intValue(); long ln = num.longValue(); float f = num.floatValue(); double d = num.doubleValue(); 处理无符号整型在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。 例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int： public class Main { public static void main(String[] args) { byte x = -1; byte y = 127; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(y)); // 127 } } 类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。 JavaBean在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 如果读写方法符合以下这种命名规范： // 读方法: public Type getXyz() // 写方法: public void setXyz(Type value) 那么这种class被称为JavaBean 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz()。 boolean字段比较特殊，它的读方法一般命名为isXyz()： // 读方法: public boolean isChild() // 写方法: public void setChild(boolean value) 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 属性只需要定义getter和setter方法，不一定需要对应的字段。例如，child只读属性定义如下： public class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } public boolean isChild() { return age &lt;= 6; } } 可以看出，getter和setter也是一种数据封装的方法。 枚举类在Java中，我们可以通过static final来定义常量。使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。 enum为了让编译器能自动检查某个值在枚举的集合内，并且不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(&quot;Work at home!&quot;); } else { System.out.println(&quot;Work at office!&quot;); } } } enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT; } 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过： int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator &#39;==&#39; } 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值： Weekday x = Weekday.SUN; // ok! Weekday y = Color.RED; // Compile error: incompatible types 这就使得编译器可以在编译期自动检查出所有可能的潜在错误。 enum的比较使用enum定义的枚举类是一种引用类型。引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： if (day == Weekday.FRI) { // ok! } if (day.equals(Weekday.SUN)) { // ok, but more code! } enum类型通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 例如，我们定义的Color枚举类： public enum Color { RED, GREEN, BLUE; } 编译器编译出的class大概就像这样： public final class Color extends Enum { // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() {} } 因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法： name():返回常量名，例如： String s = Weekday.SUN.name(); // &quot;SUN&quot; ordinal():返回定义的常量的顺序，从0开始计数，例如： int n = Weekday.MON.ordinal(); // 1 改变枚举常量定义的顺序就会导致ordinal()返回值发生变化。如果在代码中编写了类似if(x.ordinal()==1)这样的语句，就要保证enum的枚举顺序不能变。新增的常量必须放在最后。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且给每个枚举常量添加字段： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { System.out.println(&quot;Work at home!&quot;); } else { System.out.println(&quot;Work at office!&quot;); } } } enum Weekday { MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);//每个枚举值都是class实例 public final int dayValue; private Weekday(int dayValue) { this.dayValue = dayValue; } } 注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！ 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); } else { System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); } } } enum Weekday { MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) { this.dayValue = dayValue; this.chinese = chinese; } @Override public String toString() { return this.chinese; } } 覆写toString()的目的是在输出时更有可读性。 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！ switch最后，枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比int、String类型更适合用在switch语句中： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); break; case SAT: case SUN: System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); break; default: throw new RuntimeException(&quot;cannot process &quot; + day); //加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。 } } } enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN; } 小结Java使用enum定义枚举类型，它被编译器编译为final class Xxx extends Enum { … }； 通过name()获取常量定义的字符串，注意不要使用toString()； 通过ordinal()返回常量定义的顺序（无实质意义）； 可以为enum编写构造方法、字段和方法 enum的构造方法要声明为private，字段强烈建议声明为final； enum适合用在switch语句中。 BigInteger在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。 如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数,对BigInteger做运算的时候，只能使用实例方法，例如，加法运算： BigInteger i1 = new BigInteger(&quot;1234567890&quot;); BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;); BigInteger sum = i1.add(i2); // 12345678902469135780 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。也可以把BigInteger转换成long型: BigInteger i = new BigInteger(&quot;123456789000&quot;); System.out.println(i.longValue()); // 123456789000 System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range 使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException。 可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。如果BigInteger的值甚至超过了float的最大范围（3.4*10^38),那么返回的float是Infinity 。 BigDecimalBigDecimal可以表示一个任意大小且精度完全准确的浮点数。 BigDecimal bd = new BigDecimal(&quot;123.4567&quot;); System.out.println(bd.multiply(bd)); // 15241.55677489 BigDecimal用scale()表示小数位数，例如 BigDecimal d1 = new BigDecimal(&quot;123.45&quot;); System.out.println(d1.scale()); // 2,两位小数 通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal： BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;); BigDecimal d2 = d1.stripTrailingZeros(); System.out.println(d1.scale()); // 4 System.out.println(d2.scale()); // 2,因为去掉了00 BigDecimal d3 = new BigDecimal(&quot;1234500&quot;); BigDecimal d4 = d3.stripTrailingZeros(); System.out.println(d3.scale()); // 0 System.out.println(d4.scale()); // -2，表示这个数是个整数，并且末尾有2个0 可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断： public class Main { public static void main(String[] args) { BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); } } 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： BigDecimal d1 = new BigDecimal(&quot;123.456&quot;); BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;); BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入 BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 还可以对BigDecimal做除法的同时求余数： public class Main { public static void main(String[] args) { BigDecimal n = new BigDecimal(&quot;12.345&quot;); BigDecimal m = new BigDecimal(&quot;0.12&quot;); BigDecimal[] dr = n.divideAndRemainder(m); System.out.println(dr[0]); // 102 System.out.println(dr[1]); // 0.105 } } 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： BigDecimal n = new BigDecimal(&quot;12.75&quot;); BigDecimal m = new BigDecimal(&quot;0.15&quot;); BigDecimal[] dr = n.divideAndRemainder(m); if (dr[1].signum() == 0) { // n是m的整数倍 } 比较BigDecimal比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等。 必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！ BigDecimal d1 = new BigDecimal(&quot;123.456&quot;); BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;); System.out.println(d1.equals(d2)); // false,因为scale不同 System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2 System.out.println(d1.compareTo(d2)); // 0 常用工具类MathMath类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算 生成一个随机数x，x的范围是0 &lt;= x &lt; 1： Math.random(); // 0.53907... 每次都不一样 如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下： // 区间在[MIN, MAX)的随机数 public class Main { public static void main(String[] args) { double x = Math.random(); // x的范围是[0,1) double min = 10; double max = 50; double y = x * (max - min) + min; // y的范围是[10,50) long n = (long) y; // n的范围是[10,50)的整数 System.out.println(y); System.out.println(n); } } Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 RandomRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： Random r = new Random(); r.nextInt(); // 2071575453,每次都不一样 r.nextInt(10); // 5,生成一个[0,10)之间的int ...... 每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。 这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列 Random r = new Random(12345); 前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。 SecureRandomSecureRandom就是用来创建安全的随机数的： SecureRandom sr = new SecureRandom(); System.out.println(sr.nextInt(100)); 实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： public static void main(String[] args) { SecureRandom sr = null; try { sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 } catch (NoSuchAlgorithmException e) { sr = new SecureRandom(); // 获取普通的安全随机数生成器 } byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); } SecureRandom`的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Python入门与进阶","slug":"Python入门与进阶","date":"2020-05-25T17:04:11.000Z","updated":"2020-06-12T05:45:11.373Z","comments":true,"path":"2020/05/26/Python入门与进阶/","link":"","permalink":"/2020/05/26/Python入门与进阶/","excerpt":"","text":"Python特点1.Python是一门编程语言，它只是众多编程语言中的一种。 2.语言简洁、优雅，编写的程序容易阅读。 3.跨平台，可以运行在Windows、Linux以及MacOS 4.易于学习。如果把编程语言当作解决问题的工具，python确实比C++、Java、JavaScript等语言要易于学习和掌握。 5.极为强大而丰富的标准库与第三方库，比如电子邮件，比如GUI界面。 6.Python是面向对象的语言。面向对象是一种思想。 个人理解（供参考）：面向对象理解成代码的体制和构建的方式。由面向对象来组织代码，让整个工程或项目更佳清晰，组织方式合理，源代码更易阅读和管理。项目足够庞大时，面向过程的思想不易于代码的管理。 个人喜欢Python原因1.简洁，灵活，优雅，哲学 简洁胜于复杂。 做也许好过不做，但不假思索就动手还不如不做。 2.易于上手难于精通 3.Python既有动态脚本的特性，又有面向对象的特性，非常具有自己的特点。 Python的缺点相较于C、C++、Java，运行效率较慢 主流语言分两大类，编译型语言（C、C++）、解释型语言（JavaScript、Python）。 编译型语言在程序执行前会预先编译，将源代码编译成机器码，执行效率高。 解释型语言没有编译过程，执行时解释。 Java和C #没有严格的划分。有编译过程，编译成中间代码（非机器码） 运行效率与开发效率，鱼与熊掌不可兼得。适合的才是最好的。 一个学习编程的经典误区不要把思维局限在web编程，这只是编程的一个应用方向。 用途爬虫、大数据与数据分析（Spark）、自动化运维与测试、web开发(Flask、Django等)、机器学习(Tensor Flow)、胶水语言（混合其他语言来编程，能够把其他语言制作的各种模块很轻松的连接在一起）。 Python环境安装1.Windows下一键环境安装包【Python官网】—【downloads】—【Windows】 2.安装Python1.打开安装包，按下图方式安装。推荐自定义安装 2.默认勾选，pip一定要选 3.下一步，选择安装位置 4.完成安装，阅读官方使用说明文档documentation 3.IDLE与第一段Python代码 代码与写代码代码是现实世界事物在计算机世界中的映射 写代码是将现实世界中的事物用计算机语言来描述 计算机语言的基本数据类型是构成代码的基础。 基本数据类型 Number:数字整数：int 浮点数：float 布尔类型：bool 表示真、假 True、False 复数：complex 其他语言：浮点数有单精度float,双精度double的分别。python中只有float代表浮点数 ​ 整数有short,int,long的分别，python只有int 数值运算 在加减乘计算时，如果有浮点数参与运算，Python会把结果转换成为浮点数。 除法中， / 返回浮点数，// 返回整数(只保留整数部分)。 进制二进制0b开头，八进制0o开头，十六进制0x开头 不同进制间的转换 bin(10) #十进制转二进制 bin(0o7) #八进制转二进制 int(0b111) #二进制转十进制 int(0o77) #八进制转十进制 hex(888) #十进制转十六进制 oct(0x777) #十六进制转八进制 ······ 只要是非0的数都表示布尔真，只有0、空值表示布尔假 bool(2) #True bool(2.2) #True bool(-1.1) #True bool(&#39;abc&#39;) #True bool(0) #False bool(&#39;&#39;) #False bool([]) #False bool(None) #False 函数 描述 int() 转十进制 bin() 转二进制 oct() 转八进制 hex() 转十六进制 ord() 转ascii bool() 转bool（非空、非0、非None，则为True） String字符串单引号、双引号、多行字符串注意引号必须成对出现 &#39;hello world&#39; &quot;hello world&quot; &quot;let&#39;s go&quot; #单双引号是为了在引号中引用引号 &#39;&#39;&#39; hello world &#39;&#39;&#39; #三（单双）引号可以显示多行字符串，print(&quot;hello\\nworld&quot;)有同样效果 &#39;1&#39; #str类型 转移字符特殊的字符：表示无法“看见”的字符、与语言本身语法有冲突的字符 \\n #换行 \\r #回车 \\&#39; #单引号 \\t #横向制表符 print(&#39;c:\\northwind\\northwest&#39;) #输出结果会换行 print(&#39;c:\\\\northwind\\\\northwest&#39;) 或print(r&#39;c:\\northwind\\northwest&#39;) #输出结果c:\\northwind\\northwest #加上r后不是一个普通的字符串，而是一个原始字符串（所见即所得） ······ 字符串运算字符串拼接 &quot;hello&quot;+&quot;world&quot; #输出helloworld 字符串复制 &quot;hello&quot;*n #hello拼接n次 字符串访问 &quot;hello world&quot;[下标a:下标b] #从左往右以0开始，从右往左以-1开始,截取序列的[a,b) &quot;hello world&quot;[n] #从左往右以0开始，反之以-1开始,访问单个字符 #输出world的方法 &quot;hello world&quot;[6:] &quot;hello world&quot;[-5:] 组列表list[1,2,3,4] [&quot;hello&quot;,1.9,True,[1,2]] #列表内部元素的类型不是固定的 列表的基本操作 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;][n] #方法同string [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;][a:b] #方法同上 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]+[&quot;pear&quot;,&quot;lemon&quot;] #两个列表合并 [&quot;apple&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]*3 #重复3次 元组tuple(1,2,3,4) (&quot;hello&quot;,1.9,True,(1,2)) #元组内部元素的类型不是固定的 元组的基本操作 (1,2,3,4)[0] #方法同上 (1,2,3,4)[0:2] (1,2,3)+(4,5,6) (1,2,3)*3 元组和列表的区别元组的元素不能修改，列表的元素可以修改。 注意：当元组内只有一个元素时，其类型是单个元素对应的类型。如（1）为int，（‘asd’）为str。而当列表内只有一个元素时，仍然是list类型。 type((1)) 只有一个元素时，内部的（）做成运算符号处理。若要定义一个只有一个元素的元组，（1，） Python中，str,list,typle都是序列 序列共有特征 #根据序号找值 #根据切片（范围）找值 # *复制 # a not in [序列] 判断元素a是否（不）在序列中 #len(序列) 序列的元素长度 #max(序列) 集合set① 格式{元素1，元素2...}或set(&#39;元素1元素2元素3...&#39;) ② 特性集合是无序的，且元素不重复。 注意：创建空集合必须用 set()而不是 { }，因为 { } 是用来创建一个空字典。 {1,1,1,2,2,3} #最后显示{1,2,3} ③ 操作集合 运算符 功能 - 差集 \\ 并集 &amp; 交集 a ^ b a和b不同时存在的元素 {1,2,3,4,5,6}-{3,4} #{1,2,5,6} {1,2,3,4,5,6}&amp;{3,4} #{3,4} {1,2,3,4,5,6}|{3,4} #{1,2,3,4,5,6,7} 字典Dictionary① 格式{‘键1’:’值1’,’键2’:’值2’…} {&#39;w&#39;:&#39;上&#39;,&#39;a&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;} ② 特性 键名不可以重复，若重复，后面的值会替换前面相同的键名；键名为不可变类型，可以为number、string、tuple类型。 ③ 操作字典 操作 功能 字典[键名] 访问字典中的某个元素值 {&#39;w&#39;:&#39;上&#39;,&#39;a&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[&#39;w&#39;] #访问得到上 {1:&#39;上&#39;,&#39;1&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[1] #显示上 {1:&#39;上&#39;,&#39;1&#39;:&#39;左&#39;,&#39;s&#39;:&#39;下&#39;,&#39;d&#39;:&#39;右&#39;}[&#39;1&#39;] #显示左 变量变量命名规则 系统关键字不能用在变量名中。 Python中的变量名区分大小写。 变量名由字母，数字，下划线构成，开头不能是数字。 python中不存在变量的定义，变量本身没有类型，一般说把X赋值给变量，不说定义变量为X（动态性语言的特性体现） a = 1 a = &#39;1&#39; a = [1,2,3] 值类型和引用类型a = 1; b = a; a = 3; print(b) #b=1,b的值并没有改变 ********************************** a = [1,2,3] b = a a[0] = &#39;1&#39; print(a) #[&#39;1&#39;,2,3,4,5] print(b) #[&#39;1&#39;,2,3,4,5],此时b改变了 引用类型是可变的，值类型是不可变的 int str tuple值类型(不可改变) list set dict引用类型(可变) a = &#39;hello&#39; id(a) # a = a + &#39;python&#39; id(a) # ******a有不同的id，说明相加后得到的a是新的变量python****** &#39;python&#39;[0] #显示p &#39;python&#39;[0] = a #报错，值类型不可改变 列表和元组的对比元组定义好后就无法改变，列表可更改。 建议用元组 。避免合作开发过程中对方更改造成的报错。 a = (1,2,3,[1,2,4]) #如何访问4 a[3][2] a = (1,2,3,[1,2,[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]]) #访问c a[3][2][2] 运算符算术运算符python中算符运算符并不是只能对数字做运算 +加、-减、*乘、/除、//取整除、%取余、**幂 赋值运算符= +=、-=、*=、/=、//=、%=、**=注意：python中没有自增/自减运算符 c=1 c=c+1等效于c+=1 用法同其他语言 逻辑运算符and与、or或、 not非 主要操作布尔类型 非布尔类型参与运算的结果要根据计算机的运算流程判断 1 and 2 #返回2 ，计算机的运算流程，需要2才能给出结果 1 or 0 #返回1 到1即可给出结果 比较（关系）运算符== != &gt; &lt; &gt;= &lt;= 产生布尔值的运算结果 字符串、列表等均可进行比较 身份运算符 运算符 用法 功能 is 元素 is 序列 检测两个变量身份(内存地址)是否全等 not is 元素 not is 序列 检测两个变量身份(内存地址)是否不等 == 比较值，is 比较身份，类型 type判断 对象三个特征 id 、value、type ******is和==的区别******** a = 1 b = 1.0 a == b #true a is b #false ==比较值是否相等，is比较两个变量的身份（内存地址）是否相等 id(a)和id(b)不等 a = {1,2,3} b = {2,1,3} a == b #True 集合是无序的，所以不会影响最终取值 a is b #False 地址不同 ---------------- c = (1,2,3) d = (2,1,3) c == d #False 元组是序列，有序 c is d #False 内存地址不同 ---------------- 判断变量的类型 isinstance(a,str) #判断a是否是str类型 isinstance(a,(int,str,float)) #判断a是否是下面的三种类型之一 注意：python中没有===运算符 成员运算符 运算符 用法 功能 in 元素 in 序列 检测序列中是否包含指定元素 not in 元素 not in 序列 检测序列中是否不包含指定元素 注意：字典的成员运算符是针对键 b = &#39;c&#39; b in {&#39;c&#39;:1} #true 位运算符&amp;按位与 |按位与 ^按位异或 -按位取反 &lt;&lt; 左移动&gt;&gt;右移动 都是把数字当做二进制数进行运算 表达式运算符优先级 运算符 用法 { } 括号（分组） f(args…) 函数调用 x[index:index] 切片 x[index] 索引值 x.attribute 属性 ** 指数 ~x 取反 +x,-x 正、负值 *、/、% 乘、除、求余 +、- 加、减 &lt;&lt;、&gt;&gt; 左移、右移 &amp; 按位 AND ^ 按位 XOR \\ 按位 OR in、is、is not、&lt; 、&lt;=、&gt;、&gt;=、&lt;&gt;、!=、== 比较、算数、身份 not x 布尔 NOT and 布尔 AND or 布尔 OR lambda lambda 表达式 ******可以通过括号使先后顺序更清楚或强行改变顺序******** not a or b + 2 == c #(not a) or ((b+2) == c) a or b and c #a or (b and c) 语句python中语句不用括号，依据空格和换行分隔。 python没有switch 条件控制if 条件1: 语句 elif 条件2: 语句 else: 语句 pass空语句/占位语句，保持代码结构域的完整性 while循环while 条件： 语句 else: 语句 说明：在条件语句为 false 时，执行 else 的语句块 for循环# 第一种情况 #主要用来遍历/循环 for 元素 in 序列/集合/字典: 语句 else: 语句 # 第二种情况 for 变量 in range(范围): 语句 else: 语句 break跳出循环（内循环），continue停止当前操作，直接继续下面的循环 说明：在for语句遍历完毕时，执行 else 的语句块，并不要求强行使用elserange()的参数说明： range(x)：从0遍历到x，默认偏移量为1（遍历到x之前的数，取不到x,下同） range(x,y)：从x遍历到y，默认偏移量为1 range(x,y,z)：从x遍历到y，偏移量为z。若x&gt;y，则为递减，反之递增 a = [1,2,3,4,5,6,7,8] for i in range(1,len(a),2) print(a[i],end=&#39;|&#39;) *******等效于*********** b = a[0:len(a):2] print(b) 包、模块python项目的组织结构 Python包与模块的名字包的名字就是文件夹的名字，模块的名字就是文件的名字 不同包下两个同名的模块区分：包名.模块名 包下面可以包含子包 python如何区分一个普通的文件夹和包：在文件夹下面有一个特殊的文件_init_.py _init_.py这个模块的名字就是包名。 模块导入import模块导入的意义是引用别的模块的组织资源import module_name python导入一个模块时，会执行该模块的代码 语句 功能 import 模块 引入模块 from 包 import 模块/* 引入指定/全部模块 from 模块 import 部分/* 引入模块的指定/全部部分 说明：可以设置星号*所涵盖的内容，在被导入的文件中，设置__all__=[&#39;name1&#39;,&#39;name2&#39;...] import t.c7 #需要引用不同包（t包）下C7模块的a变量 print(t.c7.a) ****************** import c7 #需要同包下C7模块的a变量 print(c7.a) ****************** import t.t1.t2.c7 as m #如果命名空间过长，可以用m（自定义）代替命名，简化引用名 print(m.a) ************************************ from t.c7 import a print(a) #不需要加全部的命名空间 ****************** from t import c7 print(c7.a) ****************** from t.c7 import * #*引入全部部分或指定部分(在被导入的文件中，设置了`__all__=[&#39;name1&#39;,&#39;name2&#39;...]`) print(a) print(b) __init__.py 的用法Python杂谈: init.py的作用 包和模块是不会被重复导入的 避免循环导入（互相导入（形成环）对方的内容） 函数 功能性 隐藏细节 避免编写重复的代码 函数定义 def 函数名(参数列表): ... return 返回值1,返回值2.... 参数列表可以没有 若没写return，则返回None 若return返回多个值，则返回类型为元组 推荐使用变量1,变量2...=函数()的形式获取返回值（序列解包），不推荐使用元组[索引]获取，会降低代码可读性 序列解包a = 1 b = 2 c = 3 #等价于 a,b,c = 1,2,3 d = 1,2,3 #d是tuple类型 a,b,c = d #序列解包。需要注意的是元素的个数要相等 函数参数 类型 格式 说明 必须参数 调用时函数(实参) 形参和实参顺序要求一致 关键字参数 调用时函数(形参=实参) 形参和实参顺序可以不一致 默认参数 函数定义时def 函数名(形参=值) 实参可覆盖默认参数。注意：默认参数需写在形参列表的最后 def add(x, y): #x,y是形参 ······ add(3,2) #3,2是实参 x=3,y=2 add(y=3,x=2) #关键字参数 内置函数 函数 功能 len() 返回元素个数 id() 查看变量内存地址 type() 类型判断 isinstance(变量名,(类型1，类型2..)) 变量是否属于其中的一个类型 input([‘提示语’]) 接收用户输入的信息，返回为 string 类型 round(数值,保留位数) 四舍五入 字符串.index(子串,起始位置,结束位置) 返回开始的索引值，没找到则抛出异常。 主串.replace(‘旧子串’,’新子串’,匹配次数) 替换 字典.get(键名, 默认值) 返回指定键的值，如果不存在则返回默认值 其他 None不是False、&#39;&#39;、0、[]，尤其在判空时需要注意 对象存在不代表其一定为True，对象的bool值由__bool__或__len__内置函数决定 使用\\或()可实现跨行书写 讲解面向对象的概念。包括面向对象的三大特性（继承、封装、多态）、类的基本构成元素、python的内置类属性、方法重写、运算符重载、静态方法等 类的定义class 类名: #类命名建议第一个字母大写，驼峰命名 pass class Student(): name = &#39;&#39; age = 0 def print_file(self): #加固定的参数self，否则会报错,后面会解释 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) 类实例化对象名=类名([实参]) # 形参写在类的构造函数中 演示（在另外一个模块中引用类）： from c1 import Student student1 = Student() #类的实例化 student1.print_file() #调用类下面的方法 note:类的基本作用是封装代码。 方法要加参数self,访问实例变量方式是self.变量 类内部只做定义，不推荐在类内部实例化和调用方法 类中的变量称谓数据成员 方法：设计层面来讲 函数：程序运行，过程式的一种称谓 变量： 变量 访问 实例变量 通过self.变量名访问 类变量 通过cls.变量访问 如果在实例化对象中找不到变量，则会去相应的类中寻找，若也没有，则去所在类的父类中寻找… 在构造函数内，直接通过变量名访问的是形参，而非实例对象。 类与对象类的定义 类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起 对象的定义 对象是实例化的类 构造函数def __init__(self): #构造函数 pass 作用:生成不同的对象 构造函数__init__在实例化类时，将自动调用 构造函数是个实例方法 构造函数只能返回None 对象的参数由构造函数接收，构造函数的第一个参数为self 在构造函数内部，通常初始化类的特征值 class Student(): name = &#39;&#39; age = 0 def __init__(self,name,age): #构造函数 #初始化对象的属性 name = name #wrong age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 #行为与特征 def print_file(self): #加固定的参数，否则会报错 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) student1 = Student(&#39;石敢当&#39;，18) print(student1.name) #这里输出结果是空值，说明构造函数里的赋值并没有改变变量name的取值 释疑： student1 = Student(&#39;石敢当&#39;，18) #print(student1.name) print(student1.__dict__) #__dict__作用保存对象下的所有变量 #输出结果是空子典{}，说明不存在实例变量 类变量和实例变量实例变量和对象相关联。 class Student(): name = &#39;yuyu&#39; #类变量 age = 0 def __init__(self,name,age): #注意是两条下划线 #构造函数 #初始化对象的属性 self.name = name #定义实例变量，和对象相关，与类无关 self.age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 print(self.name) #实例对象的name student1 = Student(&#39;yanglin&#39;, 18) student2 = Student(&#39;yu&#39;, 20) print(student1.name) #此时输出正确结果 yanglin print(student2.name) #yu print(Student.name) #yuyu 类与对象的变量查找顺序 机制：访问一个实例变量，先在对象的实例列表里查找有没有该变量，没有则会去相应的类中寻找，若也没有，则去类的父类中查找…… self与实例方法定义实例方法时，需要参数,调用实例方法时，不需要传参 def __init__(self,name,age): #self可以自己更改，python中建议使用self #构造方法 #初始化对象的属性 self.name = name self.age = age #行为与特征 def print_file(self): #加固定的参数，否则会报错 print(&#39;name:&#39; + self.name) print(&#39;age:&#39; + str(self.age)) self就是当前调用方法的对象,self代表的是实例不是类 如：sutdent1.print_file() self代表student1 实例方法 # 定义 def funcname(self): pass # 调用 实例.方法() 在实例方法中访问实例变量与类变量方法代表类的行为，变量代表刻画类的特征。方法需要对变量对运算和逻辑上的操作，改变类的特征。 实例方法操作实例变量 self.变量名访问 def __init__(self,name,age): #注意是两条下划线 #构造函数 #初始化对象的属性 self.name = name #定义实例变量，和对象相关，与类无关 self.age = age print(name) #在构造函数内，直接通过变量名访问的是形参，而非实例对象。 print(self.name) #实例对象的name 实例方法访问类变量： class Student(): total = 0 def __init__(self): #注意是两条下划线 print(total) #访问错误 ******正确访问类变量的方式1******* print(Student.total) #访问成功 ******正确访问类变量的方式2******* print(self.__class__.total) #访问成功 类方法下面是实例方法改变类变量的例子 class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.__class__.sum += 1 print(&quot;当前班级学生总数为：&quot;+ str(self.__class__.sum)) #每当创建一个学生对象，班级学生总数加一 student1 = Student(&quot;yu&quot;, 18) student2 = Student(&quot;yu1&quot;, 18) student3 = Student(&quot;yu2&quot;, 18) print(Student.sum) 类方法的定义： @classmethod def plus_sum(cls): pass # 调用 类.方法() 上述方法用类方法操作改进: class Student(): sum = 0 name = &#39;&#39; age = 0 def __init__(self, name, age): self.name = name self.age = age @classmethod #类方法 def plus_sum(cls): cls.sum += 1 print(cls.sum) student1 = Student(&quot;yu&quot;, 18) Student.plus_sum() student2 = Student(&quot;yu1&quot;, 18) Student.plus_sum() student3 = Student(&quot;yu2&quot;, 18) Student.plus_sum() 类方法和实例方法的区别：关联的对象不同，一个是类，一个是对象 类方法不能访问实例变量 静态方法 @staticmethod def funcname(parameter_list): pass # 调用 类.方法()或实例.方法() 静态方法可以被对象和类调用 静态方法的内部可以访问类变量 静态方法不能访问实例变量 建议不要经常使用静态方法，和普通的函数基本没有区别 和C#，java中的静态方法有区别 成员可见性：公开与私有 在变量或方法名前加__，则变为私有 细节理解：在创建私有的实例变量时，实际python会把变量名改为_类名__变量名，所以在外部访问私有变量__变量名时，实际是创建了新变量__变量名。但是通过_类名__变量名可以修改和访问！ 建议：对类变量，建议不要直接修改，而是通过方法来修改，这样有利于保护变量 内建属性 内建属性 说明 __class__ 表示实例所在的类 __dict__ 查看类或实例的自定义属性 继承继承from 文件 import 父类 # 子类的定义 class 子类(父类): pass 建议：一个文件夹只写一个类，那么只需在子类文件上写from 文件 import 父类* 多继承：一个子类继承多个父类。python支持多继承 调用父类构造函数 父类： class Human(): sum = 0 def __init__(self, name, age): self.name = name self.age = age def get_name(self): print(self.name) 子类： from c2 import Human class Student(Human): def __init__(self, school, name, age): #注意：这里包含了子类形参和父类形参 self.school = school #self.子类变量=值 # Human.__init__(self, name, age) #子类构造函数中调用父类的构造函数 #父类.__init__(self[,父类形参]) # 注意：这里包含了父类的self及父类形参 #为什么要传self: #上面语句是一个类调用一个实例方法(不合规的)。对象实例化中调用构造函数时，python会自己 #帮我们补全，而普通方法的调用，需要传去全部的参数 super(Student,self).__init__(name,age) #推荐使用 student1 = Student(&#39;china&#39;,&#39;yuyu&#39;, 18) print(student1.name) print(student1.age) print(student1.sum) print(Student.sum) student1.get_name() 细节理解：为什么在上述代码中，父类的构造函数调用需要写self形参，但是实例化父类时，参数中却不需要写self？原因：实例化父类过程中，对于self的指向，会由python帮我们自动完成。而上述代码，并没有实例化父类，python不会帮我们自动完成，而需要我们显式地写出self。 推荐 class 子类(父类): def __init__(self[,子类及父类形参]): self.子类成员变量=值 super(子类,self).__init__(父类形参) 父子方法同名问题若父类和子类具有同名的实例方法，则在调用的是子类的。如果想调用父类同名实例方法，需要在定义子类方法时，加上super(子类,self).方法() #### 正则表达式也是文本解析中非常重要的知识点。本章我们将讲解什如何在Python中编写正则表达式与常见的正则表达式。此外，JSON作为非常重要的数据格式，我们会重点讲解，包括JSON对象，JSON字符串，Python类型与JSON的转换。 正则表达式初识正则表达式是一个特殊的字符序列，检测一个字符串是否与我们所设定的这样的字符序列相匹配。如果匹配，帮助我们快速检索文本，实现一些替换文本的操作。可以用正则表达式来1.检测一串数字是否是电话号码2.检测一个字符串是都符合email3.把一个文本里指定的单词替换为另一个单词等等 例：判断A中是否含python A = &#39;C|C++|Java|Python|Javascript&#39; #我们可以采用python中的内置函数,优先考虑内置函数 print(A.index(&#39;Python&#39;)&gt;-1) #True print(&#39;Python&#39; in A) #True 采用正则表达式 import re A = &#39;C|C++|Java|Python|Javascript&#39; #re.findall(&#39;正则表达式&#39;, A) #A是要匹配的字符串 r = re.findall(&#39;Python&#39;, A) #A是要匹配的字符串,r是列表 #print(r) #返回结果是一个列表 if len(r) &gt; 0 print(&#39;字符串中包含Python&#39;) 元字符与普通字符普通字符：正常文本字符，如上例中的’python’ 元字符：在正则表达式中具有特殊意义的专用字符,如‘\\d’。 示例： #找出A中的所有数字 import re A = &#39;C0C++34Java5Python56Javascript&#39; r = re.findall(&#39;\\d&#39;, A) #A是要匹配的字符串 print(r) #返回结果是一个列表 正则表达式全集 字符集#找出中间字母是c到f的单词 import re S = &#39;abc,acc,adc,aec,afc,ahc&#39; r = re.findall(&#39;a[c-f]c&#39;, S) #A是要匹配的字符串 print(r) #返回结果是一个列表 字符 含义 [] 或 () 分组，且 [^] 非 ^ 开头 $ 结尾 [a-b] 数字或字母范围 概括字符集 字符 含义 . 除换行之外的所有字符 \\d 数字 \\D 非数字 \\s 空白字符 \\S 非空白字符 \\w 下划线、字母、数字 \\W 非下划线、字母、数字 \\w即[0-9A-Za-z_]，\\W匹配任何非单词字符。等价于[^A-Za-z0-9_]。概括字符集表述更加简洁 数量词import re S = &#39;python 1111java6784php&#39; #提取3个单词 #r = re.findall(&#39;[a-z]{3}&#39;, S) #匹配a-z的数量是固定的3个 r = re.findall(&#39;[a-z]{3,6}&#39;, S) print(r) #返回结果是一个列表，[&#39;python&#39;, &#39;java&#39;, &#39;php&#39;] #问题：为什么匹配到3字符的时候不输出pyt,而是到python? #解：贪婪 贪婪与非贪婪数量词有贪婪和非贪婪之分，默认情况下是贪婪的方式 贪婪：数量词限定在一个区间之内，python倾向于尽可能多的取最大的值，一直到某个字符不满足条件时停止 非贪婪：[a-z]{3,6}? 匹配0次1次或者无限多次import re S = &#39;pytho1python6pythonn&#39; #*匹配0次或者无限多次 [&#39;pytho&#39;, &#39;python&#39;, &#39;pythonn&#39;] #+匹配1次或者无限多次 [&#39;python&#39;, &#39;pythonn&#39;] #？匹配0次或者1次 [&#39;pytho&#39;, &#39;python&#39;, &#39;python&#39;] 会把正确的匹配结果纳入（可用来去重） r = re.findall(&#39;python*&#39;, S) print(r) #返回结果是一个列表 字符 含义 {a,b} 指定前一个字符的出现次数(贪婪) * 前面的一个字符出现0到n次 + 前面的一个字符出现1到n次 ? 前面的一个字符出现0到1次 边界匹配符^ $ import re qq = &#39;10000013332&#39; #要求qq在4-8位 r = re.findall(&#39;^\\d{4,8}$&#39;, qq) #^从字符串的开始匹配，$从字符串的末尾开始匹配 print(r) #返回结果是一个列表 组import re A = &#39;PythonPythonPythonPythonPython&#39; #要求判断字符串里是否包含3个python r = re.findall(&#39;(Python){3}&#39;, A) #括号括起来成为组，一组的字符重复3次 print(r) #返回结果是一个列表 [abc]或关系，（ABC）组关系 匹配模式参数r = re.findall(&#39;正则表达式&#39;, 字符串，模式1|模式2)多个模式用|连在一起 匹配 findall 格式：re.findall(子串,主串[,模式|模式2...])功能：匹配返回：以列表形式，返回匹配到的子串说明：模式中\\|表示且 字符 含义 re.I 忽视大小写 re.S 使 . 匹配包括换行在内的所有字符，改变.号的行为 re模块下的其他正则表达式re.sub格式：re.sub(原内容，新内容/函数，主串，替换次数)功能：替换返回：返回新的主串说明：替换次数为0表全体换，为n表示替换n个 #示例 import re language = &#39;PythonC#JavaPHPC#&#39; r = re.sub(&#39;C#&#39;,&#39;Go&#39;,language,1) print(r) #PythonGoJavaPHPC# 进阶： 动态替换，根据不同的匹配结果进行不同的替换 &lt;re.Match object; span=(6, 8), match=’C#’&gt; 返回的第一个C#之前有6个字符，自己占7,8 import re def convert(value): #print(value) matched = value.group() return &#39;!!&#39; + matched + &#39;!!&#39; language = &#39;PythonC#JavaPHPC#&#39; r = re.sub(&#39;C#&#39;,convert,language) print(r) #Python!!C#!!JavaPHP!!C#!! 把函数作为参数传递的作用import re a = &#39;A8C3721D86&#39; #找出所有数字，&gt;=6的统一替换成9,&lt;6替换成0 def convert(value): matched = value.group() if int(matched) &gt;= 6: #默认字符串形式存储 return &#39;9&#39; else: return &#39;0&#39; r = re.sub(&#39;\\d&#39;, convert, a) print(r) # A9C0900D99 search与match函数match、search、findall用法区别 match 格式：re.match(子串,主串)功能：匹配（仅匹配一个）说明：从首字符开始匹配，若没找到对应的结果返回空,若想获取返回Match对象转为值，则用group()方法 search 格式：re.search(子串,主串)功能：匹配到一个结果（仅匹配一个），就返回结果.若想获取返回Match对象转为值，则用group()方法 match、search的比较示例代码： import re a = &#39;A8C3721D86&#39; r1 = re.match(&#39;\\d&#39;, a) print(r1) r2 = re.search(&#39;\\d&#39;, a) print(r2) # 输出结果 None &lt;re.Match object; span=(1, 2), match=&#39;8&#39;&gt; match、search、findall的比较示例代码： import re a = &#39;8C3721D86&#39; r1 = re.match(&#39;\\d&#39;, a) print(r1) r2 = re.search(&#39;\\d&#39;, a) print(r2) r3 = re.findall(&#39;\\d&#39;, a) print(r3) # 输出结果 &lt;re.Match object; span=(0, 1), match=&#39;8&#39;&gt; &lt;re.Match object; span=(0, 1), match=&#39;8&#39;&gt; [&#39;8&#39;, &#39;3&#39;, &#39;7&#39;, &#39;2&#39;, &#39;1&#39;, &#39;8&#39;, &#39;6&#39;] group分组 函数 功能 .group() 用来提取出分组截获的字符串 .span() 返回匹配到的子串在主串中的位置 import re s = &#39;life is short,i use python&#39; r = re.search(&#39;life(.*)python&#39;,s) print(r.group(1)) #获取分组的匹配 #0永远记录正则表达式的完整匹配结果 用findall import re s = &#39;life is short,i use python&#39; r = re.findall(&#39;life(.*)python&#39;,s) print(r) #获取分组的匹配 理解JSONJavaScript Object Notation JavaScript对象标记 JSON是一种轻量级的数据交换格式。 JSON载体：JSON字符串，字符串是json的表现形式 JSON优势：易于阅读、易于解析、网络传输效率高，适合跨语言交换数据 JSON字符串：是指符合JSON格式的字符串 注意：JSON中只能使用双引号，轻量相对于xml而言，符合JSON格式的字符串叫做JSON字符串 json是一种数据格式，适合跨语言交换数据 反序列化和序列化由字符串到语言下的某一数据结构叫反序列化 python字典转化为字符串 JSON函数 函数 功能 json.loads(json字符串) 反序列化，JSON字符串转Python对象 json.dumps(python对象) 序列化，Python对象转JSON字符串 JSON与Python类型的对照 JSON Python object dict array list string str number(int) int number(real) float true True flase False null None #反序列化 import json json_str = &#39;{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39; #数字不用加引号 #json有很多数据类型，如数组&#39;[{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18，“},{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}]&#39; #把json字符串转换成python自己的数据类型(字典) student = json.loads(json_str) print(type(student)) #dict字典类型 print(student) print(student[&quot;name&quot;]) print(student[&quot;age&quot;]) ******************** json_str = &#39;[{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39;,{&quot;name&quot;:&quot;qiyue&quot;, &quot;age&quot;:18}&#39;] #序列化 import json student = [ {&#39;name&#39;:&#39;qiyue&#39;, &#39;age&#39;:18 ,&#39;flag&#39;:False}, {&#39;name&#39;:&#39;qiyue&#39;, &#39;age&#39;:18} ] #把json字符串转换成对应的python结构(字典) json_str = json.dumps(student) print(type(json_str)) print(json_str) JSON对象，JSON，JSON字符串？ JSON对象在JavaScript中概念成立 JSON有自己的数据类型，虽然它和JavaScript的数据类型有些相似 REST服务的标准格式：JSON 本章节我们揭开Python进阶部分的高级特性，详细讲解枚举、闭包，并对函数式编程做出介绍 枚举枚举是一个类from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 print(VIP.YELLOW) #VIP.YELLOW 打印出的是名字，类型是enum VIP VIP.YELLOW = 6 #会报错 ，不可更改 for v in VIP #for v in VIP.__members__: 把标签的别名也遍历得到 print(v) #枚举的遍历 枚举和普通类相比的优势 如果没有枚举类,在模块中通过变量表示枚举类型 yellow = 1 #法一 green = 2 {&#39;yellow&#39;:1,&#39;green:2&#39;} #法二 class TypeDiamond(): #法三 yellow = 1 green = 2 字典和类都是可变的。没有防止相同值的功能 枚举类型、枚举名称与枚举值print(VIP.YELLOW.value)获取枚举值 #6 print(VIP.YELLOW.name) 获取枚举名字 #YELLOW print(VIP[&#39;GREEN&#39;]) 获取枚举类型 #VIP.GREEN 枚举 比较运算from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 result = VIP.GREEN == VIP.BLACK #False result = VIP.GREEN == 2 #虽然不报错，但显示False 枚举类型直接不能做大小比较 枚举注意事项 其标签值不可修改 其不允许相同标签 其标签不支持大于小于比较符 其若有多个标签是同值的，则后续的都看做第一个标签的别名。在遍历枚举类时，别名不会被打印出来 其不允许实例化 @unique 装饰器，则不允许标签同值 枚举转换数据库中存储枚举类型最好采用值（数字） 代码中不建议用数值，建议用枚举类if a == VIP.YELLOW from enum import Enum class VIP(Enum): #继承Enum类 YELLOW = 1 #数字可以替换成任意数据类型，只要不同就行 GREEN = 2 BLACK = 3 RED = 4 把数字转为枚举数据类型 a = 1 print(VIP(a)) from enum import Enum, unique # 如果枚举类继承的是IntEnum，则标签值只允许为int类型 from enum import IntEnum # @unique 加上这个，则不允许标签同值 class VIP(Enum): Yellow = 1 Yellow_ALIAS = 1 # Yellow = 2 # 报错，枚举类不允许相同标签 Green = 2 Black = 3 class VIP1(Enum): Yellow = 1 Yellow_ALIAS = 1 Green = 2 Black = 3 class Common: Yellow = 1 Black = 3 Red = 4 print(&#39;-------枚举类型及值-------&#39;) print(VIP.Yellow) print(VIP[&#39;Yellow&#39;]) print(VIP.Yellow.name) print(type(VIP.Yellow)) print(type(VIP[&#39;Yellow&#39;])) print(type(VIP.Yellow.name)) print(&#39;-------枚举类型与普通类对比-------&#39;) print(VIP.Yellow.value) print(Common.Yellow) Common.Yellow = 2 # VIP.Yellow=2 # 报错，枚举类不可修改 # 遍历枚举类——Yellow_ALIAS不会被打印 print(&#39;-------for v in VIP-------&#39;) for v in VIP: print(v) # Yellow_ALIAS会被打印 print(&#39;-------for v in VIP.__members__-------&#39;) for v in VIP.__members__: print(v) print(&#39;-------for v in VIP.__members__.items()-------&#39;) for v in VIP.__members__.items(): print(v) print(&#39;-------成员变量的别名及比较运算符-------&#39;) print(VIP.Yellow_ALIAS) print(VIP.Yellow is VIP.Yellow_ALIAS) print(VIP.Yellow == VIP.Yellow_ALIAS) print(VIP.Yellow == VIP1.Yellow_ALIAS) # print(VIP.Yellow&lt;VIP.Black) # 报错，枚举类不支持大于小于运算符 print(&#39;-------枚举转换-------&#39;) a = 1 print(VIP(a)) # 输出结果 -------枚举类型及值------- VIP.Yellow VIP.Yellow Yellow &lt;enum &#39;VIP&#39;&gt; &lt;enum &#39;VIP&#39;&gt; &lt;class &#39;str&#39;&gt; -------枚举类型与普通类对比------- 1 1 -------for v in VIP------- VIP.Yellow VIP.Green VIP.Black -------for v in VIP.__members__------- Yellow Yellow_ALIAS Green Black -------for v in VIP.__members__.items()------- (&#39;Yellow&#39;, &lt;VIP.Yellow: 1&gt;) (&#39;Yellow_ALIAS&#39;, &lt;VIP.Yellow: 1&gt;) (&#39;Green&#39;, &lt;VIP.Green: 2&gt;) (&#39;Black&#39;, &lt;VIP.Black: 3&gt;) -------成员变量的别名及比较运算符------- VIP.Yellow True True False -------枚举转换------- VIP.Yellow 扩展： from enum import IntEnum，unique #强制要求值是数字,限制值不能相同 加强设计模式的学习,进阶学习 闭包函数：其他语言中，函数只是一段可执行的代码，并不是对象，不能实例化。 在python中，一切皆对象。可以把函数赋给一个变量，可以把一个函数当做另一个函数的参数 示例： def curve_pre(): #调用curve_pre函数，拿到的是一个函数结果 a = 25 def curve(x): return a*x*x return curve #把curve函数作为结果返回给curve_pre f = curve_pre() print(f(2)) #100 def curve_pre(): #调用curve_pre函数，拿到的是一个函数结果 a = 25 def curve(x): return a*x*x return curve #把curve函数作为结果返回给curve_pre实际是返回了闭包 a = 10 f = curve_pre() print(f(2)) #100 没有取a=10来运算（闭包的取值） 闭包定义 闭包 = 函数 + 环境变量 （环境变量必须函数定义时的外部变量，且不为全局变量） 闭包的意义：把函数调用的现场保护起来了，不受外部变量的影响 闭包的经典误区def f1(): a = 10 def f2(): a = 20 #a被ptython认为是一个局部变量，此时并不引用外面的环境变量，因此不是闭包 print(a) #20 print(a) #10 第一次打印 f2() #执行f2,a=20 print(a) #10内部的a(局部变量)不会影响外部的a f1() #1.执行 f1,开始调用f1函数 结论：如果没有在函数中引用全局变量，或者仅引用局部变量，都不会形成闭包 练习： 编写函数，得到旅行者的位置（关键需要保存上一次函数调用的结果状态） 非闭包方法 代码质量不高，在函数内部定义全局变量，代码自封性不强（因为可能其他代码段也会改变全局变量） #编写函数，得到旅行者的位置 #关键需要保存上一次函数调用的结果状态 origin = 0 def go(step): global origin #声明origin是全局变量 new_pos = origin + step origin = new_pos #python认为等号左边origin此时是局部变量，是存在的， #不会在外面引用,解决方法：增加global origin return new_pos print(go(2)) print(go(3)) print(go(6)) 闭包方法： origin = 0 #这是工厂模式 def factory(pos): #参数是当前旅行者正处于的位置,pos是环境变量，有保存现场功能 def go(step): nonlocal pos #强制让pos不是局部变量 new_pos = pos +step pos = new_pos #pos此时会认为是局部变量 return new_pos return go tourist = factory(origin) print(tourist(2)) print(tourist(3)) print(tourist(5)) 函数式编程本章节进一步介绍函数式编程的lambda、mapeduce、filter以及装饰器 匿名函数：lambda表达式 def add(x, y): return x+y ---------用匿名函数实现-------------- #lambda parameter_list: expression #不能再表达式中用代码块（如赋值语句等） f = lambda x,y: x+y f(1,2) #匿名函数的调用 --------配合正则表达式使用会更方便------ 三元表达式其他语言：a &gt; y ? x : y 判断条件？结果1：结果2 python:条件为真时返回的结果 if 条件判断 else 条件为假时返回的结果 x if x&gt;y else y map闭包不建议在业务代码使用，在架构编写方面可以推荐。 map推荐在python中多使用 list_x = [1,2,3,4,5,6,7,8] def square(x): return x*x -------使用for循环------ for x in list_x: square(x) --------使用map------ r = map(square,list_x) print(r) #map对象 print(list(r)) map函数映射，把原来集合元素通过函数关系映射到另一个集合。 --------使用map和lambda精简-------- r = map(lambda x: x*x,list_x) #map多参数的传入， #x,y参数个数要相等，否则结果有缺失 list_x = [1,2,3,4,5,6,7,8] list_y = [1,2,3,4,5,6,7,8] r = map(lambda x,y: x*x+y,list_x,list_y) reducefrom functools import reduce #连续计算，连续调用lambda 每一次lamnda的计算结果将作为下一次表达式的参数作为运算，直至遍历结果 list_x = [1,2,3,4,5,6,7,8] r = reduce(lambda x,y: x+y,list_x) print(r) 1+2 3（上一次表达式的结果）+3 6+4 ((((1+2)+3)+4)+5) ... lambda是联系计算，计算操作表达式内定义 扩展：大数据计算模型（map/reduce） 映射 规约 并行计算 filter#filter list_x = [1, 0, 1, 0, 0, 1] r = filter(lambda x:True if x == 1 else False, list_x) print(list(r)) 命令式编程vs函数式编程命令式编程关键点： def if else for 函数式编程： map reduce filter lambda算子 lisp 函数式编程的鼻祖 装饰器import time def f1(): print(time.time()) #结果是unix时间戳，1591168510.2112603 print(&#39;This is a function&#39;) #如果有100个函数，都需要自带打印时间的功能。 #原则：当需求产生变更的时候，尽量不改变函数、对象或类下面的具体实现 #对修改是封闭的，对扩展是开放的 f1() 解决方案： import time def f1(): print(&#39;This is a function&#39;) #如果有100个函数，都需要自带打印时间的功能。 #原则：当需求产生变更的时候，尽量不改变函数、对象或类下面的具体实现 #对修改是封闭的，对扩展是开放的 def f2(): print(&#39;This is a function&#39;) def print_current_time(func): print(time.time()) func() print_current_time(f1) print_current_time(f2) 上述缺点：新增的功能是属于每个函数的，最好能和原来的函数绑定 改进： import time #装饰器结构 def decorator(func): def wrapper(): print(time.time()) func() return wrapper def f1(): print(&#39;this is a function&#39;) f = decorator(f1) #改变了调用方式 f() 改进： import time #装饰器结构 def decorator(func): def wrapper(): print(time.time()) func() return wrapper @decorator #语法糖，不改变原来的调用方式 def f1(): print(&#39;this is a function&#39;) f1() #不改变原来的调用方式 体现了AOP的设计思想 支持不同参数： import time #装饰器结构 def decorator(func): def wrapper(*args): #支持不同参数的个数 print(time.time()) func(*args) return wrapper @decorator #不改变原来的调用方式 def f1(func_name): print(&#39;this is a function&#39;+func_name) @decorator #不改变原来的调用方式 def f2(func_name1,func_name2): print(&#39;this is a function&#39;+func_name1) f1(&#39;test func&#39;) f2(&#39;test func1&#39;,&#39;test func2&#39;)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"SOURCETREE 3.1.3 版本跳过BITBUCKET注册方法（亲测好用）","slug":"SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）","date":"2020-05-21T14:25:21.000Z","updated":"2020-05-21T14:34:00.962Z","comments":true,"path":"2020/05/21/SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）/","link":"","permalink":"/2020/05/21/SOURCETREE-3-1-3-版本跳过BITBUCKET注册方法（亲测好用）/","excerpt":"","text":"1.首先下载并安装好git程序。 2.接着下载并执行SourceTreeSetup-3.1.3.exe，会进入登录或注册bitbucket的界面，我只是想用软件，并不想去注册账号。怎么办？请往下看。 3.打开 %LocalAppData%\\Atlassian目录，接着进入SourceTree目录，创建accounts.json文件，并修改accounts.json内容如下： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot;&quot;, &quot;Email&quot;: null }, &quot;IsDefault&quot;: false } ] 4.打开 %LocalAppData%\\Atlassian，进入“SourceTree.exe_Url_iayhtc13zv3obzuz5vchezjs1az2q5ef”（注该目录可能和版本相关，不同版本的路径可能不完全一样。） 接着进入”3.1.3.3158“目录，打开user.config文件，在里面加入六行代码。 &lt;setting name=&quot;AgreedToEULA&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;True&lt;/value&gt; &lt;/setting&gt; &lt;setting name=&quot;AgreedToEULAVersion&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;20160201&lt;/value&gt; &lt;/setting&gt; 5.再次执行SourceTreeSetup-3.1.3.exe，即可跳过注册，完成安装。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"git教程","slug":"git教程","date":"2020-05-21T11:44:51.000Z","updated":"2020-06-12T05:26:39.082Z","comments":true,"path":"2020/05/21/git教程/","link":"","permalink":"/2020/05/21/git教程/","excerpt":"","text":"Git简介Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是Linus Torvalds为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是现在很多其他自由软件项目中也使用了 Git。 SVN与Git的区别SVN是集中式版本控制系统，版本库集中放在中央服务器，干活的时候，用的都是自己的电脑，所以首先要从中央服务器那里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 Windows 平台上安装下载打开Git 官网 ，点击自己需要的版本，按照提示根据自己电脑系统版本下载相应Git,Mysysgitt是 windows版的Git。 安装打开下载好的Git安装包后，一直点击Next，保持默认选项，直到出现Install，点击Install，安装完成后点击Finish 使用安装好后，在电脑桌面或者打开某一本地磁盘，在空白位置右击鼠标会发现多了两个选项Git GUI Here和Git Bash Here，如图所示，点击Git Bash Here即可从当前位置打开并使用使用Git。 自己遇到的问题：git bash/gui here找不到应用程序 由于移动过git的安装目录，因此选择git bash here 时windows无法访问指定设备路径或文件报错解决办法：https://blog.csdn.net/weixin_39643135/article/details/79440222 配置Git环境1.打开GitHub官网，注册一个账号，注册好后，双击桌面上的Git Bash快捷图标，进行环境配置。 2.配置用户名git config --global user.name &quot;username&quot; ##username是自己的账户名，global表示所有仓库都会使用这种配置，可针对某个仓库进行配置 3.配置邮箱git config --global user.email &quot;username@email.com&quot; ##username@email.com注册账号时用的邮箱 因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。 4.命令查看之前的配置是否成功 键入git config --global --list 5.生成ssh秘钥 键入ssh-keygen -t rsa生成ssh，连敲三次回车键，结束后去系统盘目录下（一般在 C:\\用户\\当前用户\\ .ssh）查看是否生成 .ssh 文件夹，此文件夹中包含以下两个文件：id_rsa、id_rsa.pub ssh-keygen -t rsa -C &quot;你的邮箱&quot; #邮箱是github的注册邮箱 Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 6.在 GitHub 账户中添加你的公钥 运行下面命令，将公钥的内容复制到剪切板clip &lt; ~/.ssh/id_rsa.pub 打开【github】—【settings】—【SSH and GPG keys】—【new ssh key】—【把内容粘到key区域】—【add SSH key】 7.测试配置是否成功 在Git Bash命令框中键入ssh -T git@github.com命令，回车后若出现下面情况，则说明环境配置成功。(连网状态下) $ ssh -T git@github.com Hi sunshine98yy! You&#39;ve successfully authenticated, but GitHub does not provide shell access. git的图形化界面操作软件选择sourcetree作为git的图形化操作软件，可以根据自己的需要选择不同的图形化操作软件。 安装过程很简单。本人安装完后碰到需要注册的问题，由于是外国网站，访问可能会有问题，提供下面绕过注册的方法。 SOURCETREE 3.1.3 版本跳过BITBUCKET注册方法（亲测好用）) git操作创建版本库版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 下面演示创建本地版本库，提交文件到本地版本库 示例在【D盘】 下新建一个demo1版本库，创建demo1文件夹，文件夹为空。 1.通过命令 git init 把这个目录变成git可以管理的仓库这时候你当前demo1目录下会多了一个.git的目录（.表示此文件隐藏），这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。 2.把文件添加到版本库中。在版本库中新建test.txt文件，文件内容git repo1。 echo &quot;git repo1&quot; &gt;&gt; test.txt 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 ​ 第一步：使用命令 git add readme.txt添加到暂存区里面去。git add test.txt ​ 第二步：用命令 git commit告诉Git，把文件提交到仓库。git commit -m &quot;repo1 first commit&quot; git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；1 insertions：插入了一行内容（readme.txt有一行内容）。 现在我们已经提交了一个test.txt文件，我们下面可以通过命令git status来查看是否还有文件未提交。显示working tree clean ,说明没有任何文件未提交。 现在继续来改下test.txt内容，比如我在下面添加一行change内容，继续使用git status来查看下结果，如下： git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交修改。 查看test.txt文件改了什么内容？可以使用命令git diff test.txt： 如上可以看到，test.txt文件内容从一行git repo改成 二行 添加了一行change内容。知道了对test.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。 小结初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add，注意，可反复多次使用，添加多个文件； 使用命令git commit -m，完成。 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退你已经学会了修改文件，然后把修改提交到Git版本库，现在我继续对test.txt文件进行修改，再增加一行内容为second change，并提交到本地仓库。 示例现在我已经对test.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？ 使用命令git log ，命令显示从最近到最远的提交日志。我们也可以使用命令 git log --pretty=oneline来精简显示信息 注：commit id（版本号）需要用这么一大串数字？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，可以使用如下命令： git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可。 文本中的内容会回退到对应版本的内容。此时git log显示的最新的版本是回退的版本。后面新的版本不会显示。如下图，最新的second add 不会显示 此时我又想回退到最新的版本second add。内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者second add内容的版本号我并不知道呢？要如何知道增加second add内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下： 通过上面的显示我们可以知道，增加内容second add的版本号是 b65c2d7。我们现在可以命令git reset --hard b65c2d7来恢复了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是改变了HEAD的指向。 小结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区与暂存区工作区(Working Directory)工作区：就是你在电脑上看到的目录，比如目录下demo1里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)工作区有一个隐藏目录.git,这个不属于工作区，这是git的版本库。 版本库里面存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步：第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 管理修改Git跟踪并管理的是修改，而非文件。 如果我们的操作流程是第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit，会发现第二次的修改没有被提交 Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 撤销修改情景一工作区做了改动并添加到暂存区，未提交，此时需要恢复到改动前的版本: 一：如果知道要删掉哪那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 二：用命令git reset HEAD可以把暂存区的修改撤销掉（unstage），重新放回工作区，丢弃工作区的修改。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 情景二只是工作区做了改动，此时需要恢复到改动前的版本： git checkout -- file 可以丢弃工作区的修改，如下命令：git checkout -- test.txt, 把test.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：1.test.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。2.另外一种是test.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。对于第二种情况，我想我们继续做demo来看下，假如现在我对test.txt添加一行 内容为1111，我git add 增加到暂存区后，接着添加内容2222，我想通过撤销命令让其回到暂存区后的状态。如下所示： 注意：命令git checkout – test.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。 情景三现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？使用版本回退可以回退到上一个版本，git reset --hard HEAD^ 。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。 删除文件在版本库demo1目录添加一个文件b.txt,提交,然后直接在文件管理器中把没用的文件删了，或者用rm命令删除 git add b.txt git commit -m &#39;添加b.txt文件&#39; rm b.txt #可以直接在目录下删除b.txt文件或者使用命令rm b.txt 执行完上述步骤后，此时有两个选择: 1.彻底从版本库中删掉此文件，那就用命令git rm删掉，并且git commit $ git rm b.txt rm &#39;test.txt&#39; $ git commit -m &quot;remove test.txt&quot; [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 2.删错了,想在版本库中恢复此文件，使用命令git checkout -- b.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 远程仓库目前使用的git命令都是在本地执行，如果想通过git分享我们的代码，或者想与其他开发人员合作，就需要将数据放到一台其他人员能连接的服务器上。 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要先设置SSH。 添加远程仓库我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以让其他人通过该仓库来协作。 新建一个名为testgit的仓库，效果如下 GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 运行如下命令 git remote add origin https://github.com/sunshine98yy/testgit.git #本地仓库与远程仓库关联命令 git push -u origin master #推到远程仓库上命令 执行git remote就是先将本地仓库与远程仓库建立一个连接，origin是你为远端仓库所起的名字，一般都叫orign,后接远端仓库真实地址。 下一步，就可以把本地库的所有内容推送到远程库上。由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 注意master是你要上传的分支的名字，如果当前所在的分支不叫master，会提示错误git show-ref显示远端的相关分支 从现在起，只要本地作了提交，就可以通过如下命令：git push origin master把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 克隆远程仓库实际开发中需要多人合作，所以需要将远程仓库的代码克隆到本地，然后在本地进行开发，开发完成后需要推送到远程仓库中，方便协作。（远程代码拷贝一份到本地，基于本地的代码进行开发） git clone git@github.com:sunshine98yy/clone_demo.git #（远程代码拷贝到本地）–&gt;提交改动到本地仓库–&gt;本地仓库push到远程仓库克隆仓库默认跟远程仓库分支绑定！！直接命令git push到远程仓库 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改; 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但ssh协议速度最快。 分支管理创建与合并分支Git把每次的提交串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 首先，我们来创建dev分支，然后切换到dev分支上。如下操作： git checkout -b dev #创建并切换分支 Switched to a new branch &#39;dev&#39; git branch #查看当前的分支 git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令 git branch dev git checkout dev git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。 我们在dev分支上继续做demo，比如我们现在在test.txt再增加一行3333，以下为dev分支未添加内容之前和添加内容之后 现在dev分支工作已完成，现在我们切换到主分支master上，继续查看test.txt内容如下 因为不是分支demo，所以3333不显示 我们把dev分支上的内容合并到分支master上，可以在master分支上，使用如下命令git merge dev : git merge命令用于合并指定分支到当前分支上，合并后，再查看test.txt内容，可以看到，和dev分支最新提交的是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。合并完成后，我们可以接着删除dev分支了:git branch -d dev switch我们注意到切换分支使用git checkout，而前面讲过的撤销修改则是git checkout --，同一个命令，有两种作用，确实有点令人迷惑。 实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支： 创建并切换到新的dev分支，可以使用： $ git switch -c dev 直接切换到已有的master分支，可以使用： $ git switch master 使用新的git switch命令，比git checkout要更容易理解。 小结Git鼓励大量使用分支 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 或者git switch name 创建+切换分支：git checkout -b或者git switch -c 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突合并分支往往也不是一帆风顺的 准备新建一个分支，比如名字叫fenzhi1，在test.txt添加一行内容8888，然后提交 同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为5555。如下左图： 现在，master分支和feature1分支各自都分别有新的提交，变成了如下右图： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突 现在我们需要在master分支上来合并fenzhi1，果然冲突了！Git告诉我们，test.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改成和主干代码上一样（fenzhi1删除8888，改5555和master保持一致）再保存。可参考git处理冲突合并 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 分支管理策略通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。如git merge –no-ff -m “注释” dev。将dev分支删除后，用git log还能查看被删除的分支信息。 首先，仍然创建并切换dev分支： $ git switch -c dev Switched to a new branch &#39;dev&#39; 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m &quot;add merge&quot; [dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： $ git switch master Switched to branch &#39;master&#39; 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev Merge made by the &#39;recursive&#39; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit * e1e9c68 (HEAD -&gt; master) merge with no-ff |\\ | * f52c633 (dev) add merge |/ * cf810e4 conflict fixed ... 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活； 干活一般情况下在新建的dev分支上干活，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 小结Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 bug分支在开发中，会经常碰到bug问题，有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号404的bug的任务时，很自然地，你想创建一个分支issue-404来修复它，但是，当前正在dev上进行的工作还没有提交。并不是不想提交，而是工作进行到一半时候，我们还无法提交，预计完成还需1天时间，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。git stash git checkout dev git stash #将当前的工作现场隐藏起来 git status #查看状态是干净的 用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 现在可以通过创建issue-404分支来修复bug了。首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下： git checkout -b issue-404 #创建临时分支 *****修改test文件bug******** git add test.txt git commit -m &#39;fix bug 404&#39; git checkout master #切换到master分支 git merge --no-ff -m &quot;merge bug 404&quot; issue-404 #合并分支issue-404内容 ****合并分支后查看内容，和issue-404内容一致**** git branch -d issue-404 #在master分支上删除临时分支 现在回到dev分支上干活 git checkout dev #从master分支切换到dev分支 git status 工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令git stash list来查看下。工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。2.另一种方式是直接使用git stash pop,恢复的同时把stash内容也删除了。再用git stash list查看，就看不到任何stash内容了。 在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。 那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？ 有木有更简单的方法？ 有！Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支，用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git switch -c feature-vulcan Switched to a new branch &#39;feature-vulcan&#39; 5分钟后，开发完毕： $ git add vulcan.py $ git status On branch feature-vulcan Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: vulcan.py $ git commit -m &quot;add feature vulcan&quot; [feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： $ git switch dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： $ git branch -d feature-vulcan error: The branch &#39;feature-vulcan&#39; is not fully merged. If you are sure you want to delete it, run &#39;git branch -D feature-vulcan&#39;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 287773e). 终于删除成功！ 实际工作中，策划经常改需求的说，怕需求变更太频繁，用上一节的stash隐藏就行了。 多人协作当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。要查看远程库的信息 使用 git remote要查看远程库的详细信息 使用 git remote –v 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： git push origin master 要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev那么一般情况下，那些分支要推送呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫demo2，接着进入testgit2目录，进行克隆远程的库到本地来git clone git@github.com:sunshine98yy/testgit.git（如下左图），现在目录下生成（如下右图） 默认情况下，你的小伙伴只能看到本地的master分支，现在我们的小伙伴要在dev分支上做开发，就必须创建远程的origin的dev分支到本地，于是可以使用这个命令创建本地dev分支： git checkout –b dev origin/dev #创建远程origin的dev分支到本地来 ****可以在dev上继续修改提交，时不时地把dev分支push到远程***** git push origin dev #把现在的dev分支推到远程去 小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时。 由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 git pull也失败了，是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系)。根据命令行提示只需要执行以下命令即可,设置dev和origin/dev的链接:分支的upstream git branch --set-upstream-to=origin/远程分支的名字(我的是dev) 本地分支的名字(我的是dev) 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push 现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。 git push origin dev #继续推送到远程仓库中 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的不得不先pull，在本地合并，然后才能push成功。每次合并再push后，分支会有分叉： Git有一种称为rebase的操作，把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： $ git log --graph --pretty=oneline --abbrev-commit * 582d922 (HEAD -&gt; master) add author * 8875536 add comment * d1be385 (origin/master) init hello * e5e69f1 Merge branch &#39;dev&#39; |\\ | * 57c53ab (origin/dev, dev) fix env conflict | |\\ | | * 7a5e5dd add env | * | 7bd91f1 add new env ... 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： $ git push origin master To github.com:michaelliao/learngit.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &#39;git@github.com:michaelliao/learngit.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： $ git pull remote: Counting objects: 3, done. remote: Compressing objects: 100% (1/1), done. remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:michaelliao/learngit d1be385..f005ed4 master -&gt; origin/master * [new tag] v1.0 -&gt; v1.0 Auto-merging hello.py Merge made by the &#39;recursive&#39; strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： $ git status On branch master Your branch is ahead of &#39;origin/master&#39; by 3 commits. (use &quot;git push&quot; to publish your local commits) nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * e0ea545 (HEAD -&gt; master) Merge branch &#39;master&#39; of github.com:michaelliao/learngit |\\ | * f005ed4 (origin/master) set exit=1 * | 582d922 add author * | 8875536 add comment |/ * d1be385 init hello ... 如果现在把本地分支push到远程，有没有问题？有！不好看！ 这个时候，rebase就派上了用场。我们输入命令git rebase试试： $ git rebase First, rewinding head to replay your work on top of it... Applying: add comment Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py Applying: add author Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * 7e61ed4 (HEAD -&gt; master) add author * 3611cfe add comment * f005ed4 (origin/master) set exit=1 * d1be385 init hello ... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程,再用git log看看效果,远程分支的提交历史也是一条直线。 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。Git有commit，为什么还要引入tag？commit号复杂，tag简介。 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch * dev master $ git checkout master Switched to branch &#39;master&#39; 然后，敲命令git tag就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： $ git log --pretty=oneline --abbrev-commit 12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101 4c805e2 fix bug 101 e1e9c68 merge with no-ff f52c633 add merge cf810e4 conflict fixed 5dc6824 &amp; simple 14096d0 AND simple b17d20e branch test d46f35e remove test.txt b84166e add test.txt 519219b git tracks changes e43a48b understand how stage works 1094adb append GPL e475afc add distributed eaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： $ git tag v0.9 f52c633 再用命令git tag查看标签： $ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息： $ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 操作标签如果标签打错了，也可以删除： $ git tag -d v0.1 Deleted tag &#39;v0.1&#39; (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin： $ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin --tags Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9 Deleted tag &#39;v0.9&#39; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9 To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git tag用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 使用gtihub我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone： git clone git@github.com:michaelliao/bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址`git@github.com:twbs/bootstrap.git`克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样： 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。 小结 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 git总结友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用： Git Cheat Sheet 新建代码库git init # 在当前目录新建一个Git代码库 git init [project-name] # 新建一个目录，将其初始化为Git代码库 git clone [url] # 下载一个项目和它的整个代码历史 配置git config --list # 显示当前的Git配置 git config -e [--global] # 编辑Git配置文件 git config [--global] user.name &quot;[name]&quot; # 设置提交代码时的用户信息 git config [--global] user.email &quot;[email address]&quot; # 设置提交代码时的用户邮箱信息 增加/删除文件git add [file1] [file2] ... # 添加指定文件到暂存区 git add [dir] # 添加指定目录到暂存区，包括子目录 git add . # 添加当前目录的所有文件到暂存区$ git add -p # 添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] ... # 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] # 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] # 改名文件，并且将这个改名放入暂存区 代码提交git commit -m [message] # 提交暂存区到仓库区 git commit [file1] [file2] ... -m [message] # 提交暂存区的指定文件到仓库区 git commit -a # 提交工作区自上次commit之后的变化，直接到仓库区 git commit -v # 提交时显示所有diff信息 git commit --amend -m [message] # 使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend [file1] [file2] ... # 重做上一次commit，并包括指定文件的新变化 分支git branch # 列出所有本地分支 git branch -r # 列出所有远程分支 git branch -a # 列出所有本地分支和远程分支 git branch [branch-name] # 新建一个分支，但依然停留在当前分支 git checkout -b [branch] # 新建一个分支，并切换到该分支 git branch [branch] [commit] # 新建一个分支，指向指定commit git branch --track [branch] [remote-branch] #新建一个分支，与指定的远程分支建立追踪关系 git checkout [branch-name] # 切换到指定分支，并更新工作区 git checkout - # 切换到上一个分支 git branch --set-upstream [branch] [remote-branch] # 建立追踪关系，在现有分支与指定的远程分支之间 git merge [branch] # 合并指定分支到当前分支 git cherry-pick [commit] # 选择一个commit，合并进当前分支 git branch -d [branch-name] # 删除分支 git push origin --delete [branch-name] git branch -dr [remote/branch] # 删除远程分支 标签git tag # 列出所有tag git tag [tag] # 新建一个tag在当前commit git tag [tag] [commit] # 新建一个tag在指定commit git tag -d [tag] # 删除本地tag git push origin :refs/tags/[tagName] # 删除远程tag git show [tag] # 查看tag信息 git push [remote] [tag] # 提交指定tag git push [remote] --tags # 提交所有tag git checkout -b [branch] [tag] # 新建一个分支，指向某个tag 查看信息git status # 显示有变更的文件 git log # 显示当前分支的版本历史 git log --stat # 显示commit历史，以及每次commit发生变更的文件 git log -S [keyword] # 搜索提交历史，根据关键词 git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --grep feature # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 git log --follow [file] git whatchanged [file] # 显示某个文件的版本历史，包括文件改名 git log -p [file] # 显示指定文件相关的每一次diff git log -5 --pretty --oneline # 显示过去5次提交 git shortlog -sn # 显示所有提交过的用户，按提交次数排序 git blame [file] # 显示指定文件是什么人在什么时间修改过 git diff # 显示暂存区和工作区的差异 git diff --cached [file] # 显示暂存区和上一个commit的差异 git diff HEAD # 显示工作区与当前分支最新commit之间的差异 git diff [first-branch]...[second-branch] # 显示两次提交之间的差异 git diff --shortstat &quot;@{0 day ago}&quot; # 显示今天你写了多少行代码 git show [commit] # 显示某次提交的元数据和内容变化 git show --name-only [commit] # 显示某次提交发生变化的文件 git show [commit]:[filename] # 显示某次提交时，某个文件的内容 git reflog# 显示当前分支的最近几次提交 远程同步git fetch [remote] # 下载远程仓库的所有变动 git remote -v # 显示所有远程仓库 git remote show [remote] # 显示某个远程仓库的信息 git remote add [shortname] [url] # 增加一个新的远程仓库，并命名 git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 git push [remote] [branch] # 上传本地指定分支到远程仓库 git push [remote] --force # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --all # 推送所有分支到远程仓库 撤销git checkout [file] # 恢复暂存区的指定文件到工作区 git checkout [commit] [file] # 恢复某个commit的指定文件到暂存区和工作区 git checkout . # 恢复暂存区的所有文件到工作区 git reset [file] # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset --hard # 重置暂存区与工作区，与上一次commit保持一致 git reset [commit] # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset --hard [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --keep [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git revert [commit] # 新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支 git stash git stash pop # 暂时将未提交的变化移除，稍后再移入","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Hexo搭建个人网站(步骤篇)","slug":"Hexo搭建个人博客网站（步骤篇）","date":"2020-05-21T11:20:00.000Z","updated":"2020-05-21T13:58:07.576Z","comments":true,"path":"2020/05/21/Hexo搭建个人博客网站（步骤篇）/","link":"","permalink":"/2020/05/21/Hexo搭建个人博客网站（步骤篇）/","excerpt":"","text":"环境部署安装gitNode.js官网 点击自己需要的版本，一路next默认安装即可。教程可参见之前的博客 安装Node.jsGit 官网 点击自己需要的版本默认安装即可。教程可参见博客,写的很详细了nodejs安装与环境变量配置 安装HexoHexo就是我们的个人博客网站的框架， 这里需要自己在某个磁盘里创建一个文件夹，Hexo框架和以后你自己发布的网页都在这个文件夹中，我在D盘创建一个YY_Blog的文件夹。 1.使用npm下载hexo：在命令行上（任意目录）使用npm install -g hexo 全局安装hexo； 2.安装完成后，在你喜爱的文件夹下（如D:\\YY_Blog），执行以下指令hexo init(在D:\\YY_Blog内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件；（过程有点慢，耐心等待） 3.安装依赖包：npm install至此，hexo博客环境已经搭建完成，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000即可查看效果： $ hexo g #等价于hexo generate 生成静态网页 $ hexo s #等价于hexo server 启动预览服务器，开启-d选项时可以预览草稿 将hexo部署到github上上文已经在本地部署好了hexo博客系统，但仅仅本地能够访问。如果想让别人访问到你的博客，你可以租一台云主机，然后把hexo系统部署到云主机上，好处是带宽、容量可以得到保证，缺点是需要花费一笔租金。还有另一种免费的方法，就是把hexo部署到githu pages或者gitcafe pages上，本文以github为例。 关于git的安装配置以及github添加公钥的流程可以参见我的博客 [[git的安装配置]]: d 1.创建repository【your repositories】—【new】 如下图所示，这里要注意，repository名称一定是github的用户名+.github.io,否则github pages无法访问。 2.在github中添加公钥打开git bash输入以下命令 $ git config --global user.name &quot;你的用户名&quot; $ git config --global user.email &quot;你的邮箱&quot; 每次使用git命令从github上同步代码时，需要SSH连接认证。这时就需要你在本地先生成SSH KEY(命令如下)，然后把其拷贝到github上。点击Git Bash Here 输入以下命令： $ ssh-keygen -t rsa -C &quot;你的邮箱&quot; #邮箱是github的注册邮箱 Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 运行下面命令，将公钥的内容复制到剪切板 clip &lt; ~/.ssh/id_rsa.pub 打开github—&gt;settings—&gt;SSH and GPG keys—&gt;new ssh key—&gt;把内容粘到key区域—&gt;add SSH key 如下图 3.部署hexo1.编辑_config.yml(在D:\\YY_Blog下)，repository是在github中申请的地址。如下： 注意：所有的冒号后面空一格 deploy: type: git repository: https://github.com/sunshine98yy/sunshine98yy.github.io.git branch: master 2.执行下面命令 生成、部署hexo博客到github上,这样，你就可以在sunshine98yy.github.io来访问你的博客了。(后面会有专门一栏讲如何绑定自己专属域名) hexo g hexo d 注意 在执行hexo d命令时，有可能会显示如下错误信息：ERROR Deployer not found : github 解决方法如下： 在hexo的配置文件中，把deploy的type改成git 运行如下命令：npm install hexo-deployer-git --save 文献参考https://blog.csdn.net/ParanoidYang/article/details/71436028 https://blog.csdn.net/guoxiaorui666/article/details/99623023 https://lanjingling.github.io/2015/09/23/hexo%E7%AE%80%E4%BB%8B/","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo搭建个人博客网站（原理篇）","slug":"Hexo搭建个人博客网站（原理篇）","date":"2020-05-20T15:14:57.000Z","updated":"2020-05-21T13:33:12.332Z","comments":true,"path":"2020/05/20/Hexo搭建个人博客网站（原理篇）/","link":"","permalink":"/2020/05/20/Hexo搭建个人博客网站（原理篇）/","excerpt":"","text":"前言学习HEXO的初衷是想建立一个博客网站，分享记录日常所学。参考了网上很多的资料，在安装、配置、开发的过程中补过坑，也接触了新的领域。挖掘新事物的过程就像从开始发现一粒沙到后来窥探到瀚海星辰一般有趣。在结合资料的基础上，将整个过程梳理记录一下。 首先需要阐明本文使用Windows环境配置。 Hexo这章我们主要来讲一下 Hexo 是怎样生成 HTML 的。 Hexo简介hexo是使用nodejs开发的一个快速、简洁、高效、开源的静态博客生成器。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 为什么选择Hexo hexo非常小巧，使用nodejs开发，下载安装时只需要几个npm命令即可。 纯静态博客，不需要什么额外的mysql数据库、php环境…仅仅需要一个nodejs环境即可。 由于是静态博客，所以，可以非常方便部署到github、gitcafe上(后者是国内的，速度可能更有保证) 支持markdown语法、兼容windows linux mac，高可扩展性和自定义，而且有非常多的hexo主题… 工作原理hexo文件架构├── node_modules： #依赖包-安装插件及所需nodejs模块。 ├── public #最终网页信息。即存放被解析markdown、html文件。 ├── scaffolds #模板文件夹。即当您新建文章时，根据 scaffold生成文件。 ├── source #资源文件夹。即存放用户资源。 | └── _posts #博客文章目录。 └── themes #存放主题。Hexo根据主题生成静态页面。 ├── _config.yml #网站的配置信息。标题、网站名称等。 ├── db.json： #source解析所得到的缓存文件。 ├── package.json # 应用程序信息。即配置Hexo运行需要js包。 首先本地文件夹的source就是数据库，以.md（markdown）格式存储文章，theme文件夹是主题文件（决定页面模板）。 我们可以通过部署流程来逐步详尽分析。以下先来了解hexo有哪些部署命令，再分析部署的步骤流程 hexo命令总览hexo可以粗略分为三个子项目，分别是: hexo-cli hexo (下文中用hexo core来指代) hexo plugins hexo-cli：hexo命令行，作用是： 1.启动hexo命令进程和参数解析机制。每次我们输入hexo xxx命令后，都会通过node调用hexo-cli中的entry函数(比如，可以把’hexo init’视为’node hexo-cli/entry.js init’)，hexo init命令仅仅在安装时调用 2.实现hexo命令的三个初始参数：init/version/plugins 3.加载hexo核心模块，并初始化 hexo core：hexo核心，作用是：实现hexo的new、generate、publish等功能 hexo plugins: 指一些能够扩展hexo的插件。插件可以按功能分成两类: 1.扩展hexo命令的参数，如hexo-server(安装这个插件以后才能使用hexo server命令) 2.扩展hexo解析文件的”能力”，如增加jade模版解析功能的hexo-render-jade插件 介绍hexo主要命令： hexo n title #等价于 hexo new [layout] title 发布新文章 hexo p filename #等价于hexo publish filename 将_drafts下的文件放到_posts下，也就是发布草稿 hexo g #等价于hexo generate 生成静态网页 hexo s #等价于hexo server 启动预览服务器，开启-d选项时可以预览草稿 hexo d #等价于hexo deploy 发布到远程服务器，开启–generate选项可以在deploy前自动generate hexo s –debug #使用hexo s 启动本地服务后，如果修改了配置或者文章内容，需要停止服务后重新启动才能生效。这样，在调试或写文章阶段非常不方便，可以使用下面命令，以debug的方式启动，这样每次修改后就无需重启服务了。 部署的流程hexo g：生成静态文件。将我们的数据和界面模板相结合生成静态文件的过程。Hexo（node.js程序）遍历主题文件中你的source目录（js、css、img等静态资源），建立索引，再根据索引生成由html、js、css、img建立的纯静态文件并放在public文件夹里。public就是你的博客了，而这些恰好能被git pages识别。 hexo d：部署文件。主要是根据在_config.yml中配置的git仓库或者coding的地址，将public文件通过git方式push到上传到github或coding的指定分支，然后在根据pages服务呈现出页面。当然把public文件部署至你的服务器也是OK滴。 Hexo的模板引擎模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离 1.请看Hexo文件结构，source文件夹与themes文件夹是同级的，进而我们就可以将source文件夹理解为数据库，而主题文件夹相当于界面。hexo g就将我们的数据和界面相结合生成静态文件public 2.Hexo模板引擎默认使用ejs编写（本文以ejs模板举例，其他的有swig、jade）。hexo首先会解析.md文件，然后根据layout变量判断布局类型，再调用相应布局文件，这样每一块内容都是独立的，提供代码的复用性。最终生成一个html页面 3.布局模板文件位于layout文件夹下，以下将布局模板简称模板。layout文件结构在不同主题下文件排布不一，但整体框架是一样的，有： 公共模板。里面引入了head、footer等公共组件，在其他模板下会自动引入公共模板 首页模板 文章模板 分类模板 归档模板 …… 每个模板都默认使用layout布局，您可在文章的前置申明中指定其他布局，比如“post”或者“page”或是设为false来关闭布局功能（如果不填默认是post，这个在_config.yml中可以设置默认值），您甚至可在布局中再使用其他布局来建立嵌套布局 我们使用的模板。hexo new [layout] &lt;title&gt;就会使用对应的模板。 数据填充上面解释了界面的原理，此篇将分析数据及数据如何与界面结合。 数据的填充主要是 hexo -g 的时候将数据传递给 ejs 模板，然后再由 ejs 模板填充到 HTML 中。 配置文件中的数据Hexo 的配置文件 _config.yml 使用 yml语法 。例如博客的名字、副标题等等之类。这些数据项组织在 config 对象中。可以是数字、字符串、对象、数组。 如果要在模板中使用某个具体的值，比如字符串、数字、逻辑变量或者对象的某个成员，可以在主题的模板文件 ejs中直接使用： {% block title %} {{ page.title }} | {{ config.title }} {% endblock %} Github PagesHexo搭建的博客项目源码托管在github，并享受github pages服务。 GitHub pages简称pages服务，每个仓库都有一个pages服务，可用来展示项目，通过简单的设置项目的index.html，并以此做为入口供用户参观访问。大部分的 pages 服务都是用来搭建个人博客的。言外之意不仅能搭建博客，还能做些其他的事情~ 生成博客的页面有动、静态页面之分，著名的博客 wordpress ，既是动态页面生成的博客，其思路是 php + MySql 。 博客hexo生成的是静态页面，而Github pages 又支持静态页面的解析。因此二者一拍即合能够用来生成 html 拼合成博客。 参考文献：https://hexo.io/zh-cn/docs/github-pages https://juejin.im/post/598eeaff5188257d592e55bb#heading-5","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo运营前记","slug":"Hexo运营前记","date":"2020-05-20T11:30:23.000Z","updated":"2020-05-20T11:19:52.510Z","comments":true,"path":"2020/05/20/Hexo运营前记/","link":"","permalink":"/2020/05/20/Hexo运营前记/","excerpt":"","text":"着手搭建博客是一件不在计划内的事情。起因是前段时间接触Linux的内容，讲到用SSH实现客户端到服务器端的免密登录时，有用一个hexo+github page搭建网站过程中的环节举例。虽然只是一句话带过的例子，在我尝试配置了本地SSH秘钥后，完全发现了一个新的探索方向（折腾方向）。 做博客就像打游戏，当你以为自己升到80级时，对于别人来说这仅仅处于20级的位置，层次浅到非常。 花在上面的时间前前后后有两周的晚上，开始照着官方文档来，实现基本配置。后面又浏览了下大佬们的博客，对比一下自己眼前毫无特色的主页不香了。于是推倒重建找主题，加美化插件。只能说一时折腾一时爽，永远折腾永远爽吧。 整个过程大致是换了两个主题，Icarus、Sakura。搭建用CDN加速连接的图库，熟悉hexo框架的基本命令，markdown的基本语法（没错，写博客更博客不像空间发状态那么直接），走了一遍git的工作流程，购买解析了域名。不停地倒腾配置文件，最主要的是找合适的优化插件。耗费这么多精力是我一开始没想到的。自己就像在海边捡起一枚贝壳，透过小小的贝壳看到大海的模样。下面是一开始Icarus的主题，其实还是挺好看的。作者最近用新的语言重新写了一套框架，因此想自己发挥的难度对我这种新手难度很大。 Icarus这款主题主打简洁大方，页面清爽。在上面增加了板娘的效果，评论打赏分类标签历程展示，基本都能实现，icarus也有缺点，无多级导航（仅仅是个人喜好）。后来浏览到sakura主题，也就是现在的主题。在简洁和酷炫之间还是选择了后者。模板用的人还不多，下载了主题star了下项目，感谢原作者的创作。下面是自己DIY的样式。 “工欲善其事必先利其器”，搭建的博客网站是记录自己历程的利器。也很是佩服自己这把年纪了还能这么折腾。 折腾被赋予了一个新的含义——走出舒适区。诚然，走出舒适区现在已然成许多人的口号，嘴上说说而已的口号，智商常常不在线的我更是如此。 漫长的道路，现在只是一个开始的起点。 A journey like life, welcome to my entire world!","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"画廊——日常","slug":"画廊","date":"2020-05-19T14:06:43.000Z","updated":"2020-05-21T06:14:52.200Z","comments":true,"path":"2020/05/19/画廊/","link":"","permalink":"/2020/05/19/画廊/","excerpt":"","text":"献给我琳~","categories":[],"tags":[{"name":"光影艺术","slug":"光影艺术","permalink":"/tags/光影艺术/"}],"keywords":[]},{"title":"SSM+Springboot商铺系统(一)","slug":"SSM-Springboot商铺系统","date":"2020-05-19T13:21:08.000Z","updated":"2020-05-19T13:31:48.298Z","comments":true,"path":"2020/05/19/SSM-Springboot商铺系统/","link":"","permalink":"/2020/05/19/SSM-Springboot商铺系统/","excerpt":"","text":"待更~","categories":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}],"tags":[],"keywords":[{"name":"项目","slug":"项目","permalink":"/categories/项目/"}]},{"title":"Linux核心技术与应用笔记（一）","slug":"Linux核心技术与应用笔记（一）","date":"2020-05-19T11:24:34.000Z","updated":"2020-05-19T11:42:58.713Z","comments":true,"path":"2020/05/19/Linux核心技术与应用笔记（一）/","link":"","permalink":"/2020/05/19/Linux核心技术与应用笔记（一）/","excerpt":"","text":"待更~~~~","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Sakura主题配置总结","slug":"Hexo-Theme-Sakura","date":"2020-05-19T02:45:01.000Z","updated":"2020-05-20T15:44:32.309Z","comments":true,"path":"2020/05/19/Hexo-Theme-Sakura/","link":"","permalink":"/2020/05/19/Hexo-Theme-Sakura/","excerpt":"","text":"前言搭建完框架后，为博客找一个主题。主题的搭建往往是无止境的，适合爱折腾的选手。在网上被迫欣赏大佬们的华丽主题后，我看着自己一开始配置的主题，突然觉得不香了。是时候换一拨了，挑选了一个用的人比较少的sakura主题，在github上star了项目，感谢原作者的辛勤创作。 一： 主题下载hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 二： 主题配置博客根目录下的_config配置站点（显示在浏览器导航页的信息） # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://sunshine98yy.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/sunshine98yy/sunshine98yy.github.io.git,backup # coding: https://git.coding.net/sunshine98yy/sunshine98yy.git,backup 顶部站点名字其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: YU YU 顶部导航栏# 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } 前面的path是网页路径，这个不建议修改，但可以修改。后面的如: fa: fas fa-home fa-1x 这个就是对应的图标设置,关于这个图标大家可以去fontawesome看教程以及选择自己喜欢的图标，导航栏下拉下拉菜单的图标修改和导航栏相同。 头像修改# favicon and site master avatar # 站点的favicon和头像 输入图片路径【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg 我这个是使用cdn后的路径，也可以修改为： favicon: https://cdn.jsdelivr.net/gh/sunshine98yy/mycdn/img/custom/avatar.jpg 大家可以用jsDeliver+github搭建自己的cdn,具体教程请点击查看我的另一篇博客其中有详细介绍！ # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"/tags/HEXO/"},{"name":"sakura","slug":"sakura","permalink":"/tags/sakura/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}